<search>
    
     <entry>
        <title>全站https</title>
        <url>https://farwmarth.com/post/https/</url>
        <categories>
          <category>技术</category>
        </categories>
        <tags>
          <tag>软件开发</tag>
        </tags>
        <content type="html"> 现在网站没再折腾,hugo生成,图片放在七牛云上,部署在coding.net.今天搞了一下把全部加上了https
coding.net coding静态网站https设置
 要注意的是coding申请https证书时会检测dns指向。如果是双线路部署github和coding的话要先暂停掉github的解析
 hugo 修改config.toml中BaseUrl 开头改为https
七牛云 生成证书 下载cerbot-auto wget https://dl.eff.org/certbot-auto sudo mv certbot-auto /usr/local/bin/certbot-auto sudo chown root /usr/local/bin/certbot-auto sudo chmod 0755 /usr/local/bin/certbot-auto /usr/local/bin/certbot-auto --help 获取证书 certbot-auto --manual --preferred-challenges dns certonly --输入域名 如farwmarth.bestnewbee.com --dns解析做下txt解析 生成的证书在/etc/letsencrypt/live/中
上传到七牛云 https://developer.qiniu.com/fusion/manual/4952/https-configuration 证书内容对应fullchain.pem 私钥对应privkey.pem
</content>
    </entry>
    
     <entry>
        <title>反编下某疫苗接种app</title>
        <url>https://farwmarth.com/post/umiao/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>疫苗</tag>
        </tags>
        <content type="html"> 前言 今天带小孩去打疫苗，发现之前的社区医院改成app预约了,下载app用了一下,真是无力吐槽,除了注册功能是好的。其他功能一点开全在转圏加载,预约教程页面还报了个sql语句错误.报着学习的态度想看看大佬们写的代码.
工具准备  夜神模拟器 Packet Capture VirtuanXposed mt文件管理器2 FDex2 gda dex2jar jd-gui  撸起袖子 用packet capture抓了几个包看了下api。 基础api地址: http://api.new.umiaohealth.com
 登录 /account/login 找可预约记录 /vaccine/getreservationreservedlist 接种信息 /vaccine/getvaccinemain  模拟登录时有个token字段猜解死活不通过,看来只能反编译下app看下加密代码了. 用gda查了下壳,发现是360加固的. 用gda自带的进程dump连接模拟器老是进程无响应,无果。 祭出这个xposed脱壳模块FDex2(要先安装VirtuanXposed或者xposed). 用mt文件管理器把dump出的dex移动到夜神模拟器和pc的共享目录. 这里有多上dex,可以用gda打开看下主代码在哪个dex里.然后用dex2jar转换一下把dex转成jar 然后用jd-gui打开jar反编一下.class文件就行了。
最后找到了加密token的关键代码 HttpClientUtil.java
public void httpPost(Context paramContext, String paramString, AjaxParams paramAjaxParams, BaseParser&amp;lt;?&amp;gt; paramBaseParser, IDataCallback paramIDataCallback) { FinalHttp localFinalHttp = new FinalHttp(); localFinalHttp.configTimeout(30000); paramAjaxParams.put(&amp;#34;token&amp;#34;, Base64Utils.getSecretToken(paramContext)); Header[] arrayOfHeader = Base64Utils.getHttpHeader(paramContext); String str1 = ((ParentInfo)ParentInfo.findFirst(ParentInfo.class)).getPid(); String str2 = str1; if (TextUtils.isEmpty(str1)) { str2 = &amp;#34;0&amp;#34;; } paramAjaxParams.put(&amp;#34;pid&amp;#34;, str2); paramAjaxParams.put(&amp;#34;VersionChecked&amp;#34;, CommonUtil.getAppCurrentVersion(paramContext)); paramAjaxParams.put(&amp;#34;devicetype&amp;#34;, &amp;#34;android&amp;#34;); localFinalHttp.post(paramString, arrayOfHeader, paramAjaxParams, &amp;#34;application/x-www-form-urlencoded&amp;#34;, new HttpClientUtil.3(this, paramIDataCallback, paramString, paramAjaxParams, paramBaseParser, paramContext)); } Base64Utils.java
public static String getSecretToken(Context paramContext) { paramContext = (ParentInfo)ParentInfo.findFirst(ParentInfo.class); String str = paramContext.getToken(); Object localObject = paramContext.getPid(); paramContext = (Context)localObject; if (TextUtils.isEmpty((CharSequence)localObject)) { paramContext = &amp;#34;0&amp;#34;; } tktimes = System.currentTimeMillis() &#43; &amp;#34;&amp;#34;; int i = Integer.parseInt(tktimes.substring(12)); localObject = sortSeed[i]; sortIndex = String.valueOf(localObject[0]) &#43; String.valueOf(localObject[1]) &#43; String.valueOf(localObject[2]); localObject = getSortData(localObject[0], str, paramContext, tktimes) &#43; &amp;#34;,&amp;#34; &#43; getSortData(localObject[1], str, paramContext, tktimes) &#43; &amp;#34;,&amp;#34; &#43; getSortData(localObject[2], str, paramContext, tktimes) &#43; &amp;#34;,&amp;#34; &#43; sortIndex; paramContext = null; try { localObject = encrypt((String)localObject, &amp;#34;xxx加密&amp;#34;); paramContext = (Context)localObject; } catch (Exception localException) { for (;;) { localException.printStackTrace(); } } return paramContext; } 好了，我去写个预约疫苗的脚本去了
</content>
    </entry>
    
     <entry>
        <title>hexo自动化构建</title>
        <url>https://farwmarth.com/post/autohexo/</url>
        <categories>
          <category>hexo</category>
        </categories>
        <tags>
          <tag>hexo</tag><tag>github</tag><tag>coding</tag><tag>weghook</tag>
        </tags>
        <content type="html"> 最近发现博客的图片和文章数量增长后,hexo生成和发布的时间越来越长,而且换了电脑后hexo的环境又要倒腾一遍,实在是消耗时间。
但是又不想换简书这种单纯的写作平台，毕竟博客还是需要一点个性化的元素。
那能不能我写完markdown然后commit之后就可以自动生成静态页面自动发布呢？当然懒人们有很多种办法。研究了一下一般都是用webhook来实现,目前大概有几种方式:
hexo源文章仓库托管在github上然后编成静态文件分发到github和coding.net的pages服务上。一般用Travis CI来做集成,转一张kcen做的时序图 流程简化就是本地push源文章到github，触发webhook然后traivs帮你自动构建生成静态文件然后推送到page服务上。
为了追求速度,我把hexo文章仓库托管在coding.net的上,而且coding的私有项目不收费,也提供了webhook的功能.
在coding上也有像travis一样的国内服务,开始收费的flow.ci不予考虑, 看到这篇博客daocloud好像是个不错的选择，但是在部署的时候还是要暴露私钥给第三方平台,也没有选择这种方案。
正好手上有一台闲置的vps,就选择了云主机上搭建一个hexo的环境,push的时候触发coding的webhook，回调云主机上用nginx反代的node服务，然后执行一个shell脚本拉代码自动编译发布 基本流程没有变,只是把第三方的服务换成了自己的vps,把需要的密钥换成了部署公钥。
coding的部署公钥在此部署 webhook在此配置 vps上的项目目录，hexo是clone下来的博客源码，webhook下的是node server,部署公钥放最顶层
├── blog_rsa├── blog_rsa.pub #部署公钥├── hexo #博客源码│ ├── deploy.sh│ ├── source└── webhook # node服务├── config.js├── index.js├── logs因为部署公钥没有放.ssh目录下所以要在~/.ssh/config下指定一下
Host git.coding.netUser xxx@email.comPreferredAuthentications publickeyIdentityFile /data/publish/blog_rsaIdentitiesOnly yesHost github.comUser xxx@email.comPreferredAuthentications publickeyIdentityFile /data/publish/blog_rsaIdentitiesOnly yesnode服务代码很简单,判定一下coding的hook是不是push请求,友情提示,启动node服务的时候可以用forever模块启动forever start index.js index.js
var http = require(&amp;#39;http&amp;#39;);var exec = require(&amp;#39;child_process&amp;#39;).exec;var config = require(&amp;#39;./config.js&amp;#39;);var fs = require(&amp;#39;fs&amp;#39;);var util = require(&amp;#39;util&amp;#39;);var log4js = require(&amp;#39;log4js&amp;#39;);var logger = log4js.getLogger(&amp;#34;hook&amp;#34;);log4js.configure({appenders: [{type: &amp;#39;console&amp;#39;,level: &amp;#39;DEBUG&amp;#39;}, {type: &amp;#39;file&amp;#39;,filename: &amp;#39;logs/hook.log&amp;#39;,category: &amp;#39;hook&amp;#39;,level: &amp;#39;INFO&amp;#39;,maxLogSize: 20480,backups: 10,}]});var now = function() {return new Date().toLocaleDateString() &#43; &amp;#34; &amp;#34; &#43; nowDate.toLocaleTimeString();}var main = function(req, res, data) {if (data.commits) {console.log(data.token , config.token);if (data.token != config.token){logger.error(&amp;#34;error token!!!!!!!&amp;#34;);res.end();return;}var project_name = data.repository.name,commit_user = data.commits[0].committer.name,commit_user_email = data.commits[0].committer.email,commit_message = data.commits[0].short_message;let pro_item = config.projects[project_name];if (!pro_item) {logger.warn(&amp;#34;push project not in config&amp;#34;);res.end();return;}logger.info(util.format(&amp;#34;commit_message:%s, project_name:%s, commit_user:%s, commit_user_email:%s&amp;#34;, commit_message, project_name, commit_user, commit_user_email));exec(util.format(&amp;#34;sh %s&amp;#34;, config.projects.shell_name), {maxBuffer: 400 * 1024,cwd: pro_item.path}, function(err, stdout, stderr) {cmd_result = err ? stderr : stdout;logger.info(cmd_result);});res.end();logger.debug(&amp;#34;push trigger end&amp;#34;);} else if (data.zen) {//ping res.end();}else {res.end();}};var server = http.createServer(function(req, res) {var POST = &amp;#39;&amp;#39;;req.on(&amp;#39;data&amp;#39;, function(chunk) {POST &#43;= chunk;});req.on(&amp;#39;end&amp;#39;, function() {try {POST = JSON.parse(POST);} catch (Error) {POST = {};}main(req, res, POST);});});server.listen(config.port);logger.info(&amp;#34;Server runing at port: &amp;#34; &#43; config.port &#43; &amp;#34;.&amp;#34;);config.js
#启动端口var port = xxx;#与coding的token配置一致var token = &amp;#39;xxx&amp;#39;;var projects = {hexo: {path: &amp;#39;/data/publish/hexo/&amp;#39;,url: &amp;#39;git@git.coding.net:farwmarth/webhook.git&amp;#39;},//push请求要执行的脚本 shell_name: &amp;#34;deploy.sh&amp;#34;};var hook_log = &amp;#39;hook.log&amp;#39;;module.exports = {projects: projects,port: port,token: token,hook_log: hook_log,};deploy.sh
git pull origin master#为了拉主题git submodule update --recursive --inithexo cleanhexo generatehexo deploy部署好服务,配置好webhook后，可以愉快地写完文章直接commit,而不用再等待deploy了.
安全性总结  用travis记得将私钥加密 如果要用密钥最好用项目部署公钥,并控制好读写权限 webhook最好设置token </content>
    </entry>
    
     <entry>
        <title>hexo图片迁移至七牛</title>
        <url>https://farwmarth.com/post/hexo%E5%9B%BE%E7%89%87%E8%BF%81%E7%A7%BB%E8%87%B3%E4%B8%83%E7%89%9B/</url>
        <categories>
          <category>hexo</category>
        </categories>
        <tags>
          <tag>hexo</tag><tag>qiniu</tag>
        </tags>
        <content type="html">  之前图片一直是直接到在page服务上的,最近发现图片越来越多,打算图片迁移到七牛上.
七牛可以cdn加速,每月有固定的免费流量,可以设置防盗链,可以自动压缩图片打水印。众多优点。对小博客来说真是有莫大的帮助。
七牛注册这些过程就略过不表了.前置工作
 注册七牛账号并创建对象空间，充十块自定义域名 绑定加速域名，自定义域名必须为中国大陆已备案。推荐使用二级域名。 设置一下防盗链和图片瘦身  获取AccessKey SecretKey  批量迁移 qrsync已经被七牛废弃了,现在使用qshell完成图片批量同步
我的迁移目录结构
├── gen4idx.py #生成索引├── images #要同步的图片,可多级├── qshell # 同步程序├── qsync.json #同步配置├── qsync.sh #同步shell└── upload.log #同步日志生成图片索引gen4idx 因为七牛上传的图片没有预览界面只能在对象存储中搜索查看,非常不方便,我们可以在同步前遍历一下目录生成一个html也同步到七牛对象空间中.这样访问html就可以检索所有的图片了,改造了一下其他人写的索引代码放在gist
#要遍历的根目录 指定的图片目录用逗号隔开python gen4idx.py images NULLqshell使用 初始化账户 ./qshell account AccessKey SecretKey配置qsync.json 配置参考文档
{&amp;#34;src_dir&amp;#34; : &amp;#34;/Users/far/Develop/tools/qiniu/&amp;#34;,&amp;#34;bucket&amp;#34; : &amp;#34;farwmarth&amp;#34;,&amp;#34;overwrite&amp;#34; : false,&amp;#34;check_exists&amp;#34; : true,&amp;#34;check_hash&amp;#34; : false,&amp;#34;check_size&amp;#34; : true,&amp;#34;rescan_local&amp;#34; : true,&amp;#34;skip_file_prefixes&amp;#34; : &amp;#34;qrsboxcli,qshell&amp;#34;,&amp;#34;skip_fixed_strings&amp;#34; : &amp;#34;.svn,.git&amp;#34;,&amp;#34;skip_suffixes&amp;#34; : &amp;#34;.DS_Store,.exe,.log,.sh,.py,.pyc,.json,.md&amp;#34;,&amp;#34;log_file&amp;#34; : &amp;#34;upload.log&amp;#34;,&amp;#34;log_level&amp;#34; : &amp;#34;info&amp;#34;,&amp;#34;log_rotate&amp;#34; : 1,&amp;#34;log_stdout&amp;#34; : true}同步 ./qshell qupload 2 qsync.json同步完成后会生成log,终端上也会有同步的过程和统计信息,如果同步异常中断了也会接着上次的进度续传的. 其他命令 #列举空间下的列表到控制台输出./qshell listbucket farwmarth stdout#列举目录中的文件到result.txt中./qshell dircache . result.txt替换图片 替换图片比较简单 几个上传七牛的写作插件  MWeb alfred插件上传: https://github.com/iammapping/alfred-uploader hexo插件: https://github.com/gyk001/hexo-qiniu-sync 极简图床: http://yotuku.cn/#/  试了 ulysses ia-write等一打写作工具后最后停留在了MWeb和Sublime上.MWeb的各项插件很齐全,写MarkDown体验也好.
</content>
    </entry>
    
     <entry>
        <title>初级运维指南</title>
        <url>https://farwmarth.com/post/%E5%88%9D%E7%BA%A7%E8%BF%90%E7%BB%B4%E6%8C%87%E5%8D%97/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>shell</tag>
        </tags>
        <content type="html"> 加固  CentOS 7防火墙换用Friewalld  SSH配置 安装ssh #安装yum install ssh#启动service sshd start#设置开机启动chkconfig ssd on#重启service sshd restart#重启网络service network restart#centos7systemctl restart sshd.service配置 配置文件目录: /etc/ssh/sshd_config ,参考
Port 22022 #对外端口,改了端口后别忘记了防火墙的出口端口设置Protocol 2 #协议RSAAuthentication yes #rsa登录PubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keysPermitRootLogin yes #允许root用户以任何认证方式登录 without-password noSyslogFacility AUTHPRIVPasswordAuthentication no #禁止密码登录只允许特定用户登录 在sshd_config中设置AllowUsersAllowUsers a b c重启sshd服务，则只有a/b/c3个用户可以登陆密钥生成 #生成ssh-keygen -t rsa#添加cat .ssh/id_rsa.pub &amp;gt;&amp;gt; .ssh/authorized_keys#检查cat .ssh/authorized_keys常见免密码登录失败分析 配置问题  检查配置文件/etc/ssh/sshd_config是否开启了AuthorizedKeysFile选项 检查AuthorizedKeysFile选项指定的文件是否存在并内容正常  目录权限问题  ~权限设置为700 ~/.ssh权限设置为700 ~/.ssh/authorized_keys的权限设置为600  sudo chmod 700 ~sudo chmod 700 ~/.sshsudo chmod 600 ~/.ssh/authorized_keys配置ssd防止暴力破解 # KeyError: &amp;#39;FAILED_ENTRY_REGEX10&amp;#39; 20161206居然有问题要还原代码编译 git reset --hard 65e1bc1#依赖pip install ipaddr#安装python steup.py install#编辑配置文件cp denyhosts.conf /etc#配置一下 /etc/denyhosts.conf#启动服务cp daemon-control-dist /etc/init.d/daemon-controlchown root /etc/init.d/daemon-controlchmod 700 /etc/init.d/daemon-control#编辑daemon-controlDENYHOSTS_BIN = &amp;#34;/usr/bin/denyhosts.py&amp;#34;#加入开机启动chkconfig --level 3 daemon-control on/etc/init.d/daemon-control start#日志tail -50 /var/log/denyhosts#https://github.com/denyhosts/denyhosts/blob/master/denyhosts.conf#linux版本相关 SECURE_LOG HOSTS_DENY LOCK_FILESECURE_LOG = /var/log/secure #ssh 日志文件，它是根据这个文件来判断的。HOSTS_DENY = /etc/hosts.deny #控制用户登陆的文件，根据UNIX版本不同配置不同PURGE_DENY = 15m #过多久后清除已经禁止的，默认为空，即马上清除掉，这个根据自己的需要设置。BLOCK_SERVICE = sshd #被加入hosts.deny后阻止的服务:阻止SSHD服务#允许无效用户失败的次数DENY_THRESHOLD_INVALID = 1#允许普通用户登陆失败的次数DENY_THRESHOLD_VALID = 10#允许root登陆失败的次数DENY_THRESHOLD_ROOT = 5#对WORK_DIR/restricted-usernames配置的用户次数判定DENY_THRESHOLD_RESTRICTED = 1WORK_DIR = /usr/share/denyhosts/data #工作目录SUSPICIOUS_LOGIN_REPORT_ALLOWED_HOSTS=YES #allowed-hosts中的用户有可疑登录行为如果此配置为YES则会报告HOSTNAME_LOOKUP=NO #是否做域名反解LOCK_FILE = /var/lock/subsys/denyhosts############ THESE SETTINGS ARE OPTIONAL ############ADMIN_EMAIL = wujiyu115@gmail.com #管理员邮件地址SMTP_HOST = localhostSMTP_PORT = 25SMTP_FROM = DenyHosts &amp;lt;nobody@localhost&amp;gt;SMTP_SUBJECT = Redocn-DenyHosts ReportAGE_RESET_VALID=5dAGE_RESET_ROOT=25dAGE_RESET_RESTRICTED=25dAGE_RESET_INVALID=10d######### THESE SETTINGS ARE SPECIFIC TO DAEMON MODE ##########DAEMON_LOG = /var/log/denyhosts #日志文件DAEMON_SLEEP = 30sDAEMON_PURGE = 1h http://skypegnu1.blog.51cto.com/8991766/1641064 https://help.aliyun.com/knowledge_detail/41212.html  Nginx配置 常用命令 #启动sudo nginx#关闭sudo nginx -s stop#检测配置是否正常:nginx –t#重新启动nginx -s reload配置 nginx反向代理长链接 upstream chat_cluster{##多server负载,根据ip_hash作分流也可以用weight权重分流server 127.0.0.1:10000;server 127.0.0.1:10001;ip_hash;keepalive 1024;}server{listen 80;server_name chat.rootk.com;location / {proxy_pass http://chat_cluster;proxy_http_version 1.1;# very important, nginx will waitting for the response from tornado# if the time have passed more than 7200, nginx send http 504 to clientproxy_read_timeout 7200;proxy_set_header Connection &amp;#34;&amp;#34;;proxy_set_header Host $host;proxy_set_header X-Real-Ip $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}}lnmp集成环镜 ##默认网站(虚拟主机)##/usr/local/nginx/conf/vhost#LNMP默认网站配置文件：/usr/local/nginx/conf/nginx.conf#LNMPA默认网站配置文件：/usr/local/nginx/conf/nginx.conf 和 /usr/local/apache/conf/extra/httpd-vhosts.conf#LAMP默认网站配置文件：/usr/local/apache/conf/extra/httpd-vhosts.conf#LAMP默认网站/home/wwwroot/default#做反代,nginx里面的server_name和tomcat那里的Host保持一致iptables #!!!!iptables ACCEPT要放在DROP前才生效 /etc/sysconfig/iptables#查看iptables的数据iptables -L -n#保存iptables的数据service iptables save#把某端口的权限开放给某个IPiptables -I INPUT -s 113.68.65.85 -p tcp --dport 3306 -j ACCEPTiptables -A INPUT -p tcp --dport 3306 -j DROPservice iptables save#把某端口权限打开 dport指本地，sport指外部iptables -A INPUT -p tcp --dport 8888 -j ACCEPTiptables -A OUTPUT -p tcp --sport 8888 -j ACCEPT#限制只能某个ip访问端口iptables -I INPUT -s 10.21.213.74 -p tcp --dport 8888 -j ACCEPTiptables -A INPUT -p tcp --dport 8888 -j DROP#插入到指定位置 -iiptables -I INPUT 2 -s 14.23.124.130 -p tcp --dport 8888 -j ACCEPT#添加允许之后要DROP掉其他端口的inputiptables -P INPUT DROP#查看INPUT的linnumberiptables -L INPUT –line-numbers#删除一条iptables -D INPUT 3#保存service iptables save#查看iptables状态service iptables status#iptables服务重启service iptables restartmysql配置 [mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0pid-file=/var/run/mysqld/mysqld.pidlog-bin=mysql-bin[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid忘记密码： service mysqld stopmysqld_safe --user=root --skip-grant-tablesmysql -u rootuse mysqlupdate user set password=password(&amp;#34;new_pass&amp;#34;) where user=&amp;#34;root&amp;#34;;flush privileges;为root添加远程连接的能力： GRANT ALL PRIVILEGES ON *.* TO root@&amp;#34;%&amp;#34; IDENTIFIED BY &amp;#34;root&amp;#34;;use mysql;update user set Password = password(&amp;#39;xxx&amp;#39;) where User=&amp;#39;root&amp;#39;;flush privileges;#修改 Mysql 配置文件 sudo vi /etc/mysql/my.cnf#注释#bind-address = 127.0.0.1重启sudo /etc/init.d/mysql restart创建用户 CREATE USER &amp;#39;herogame&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;xxx&amp;#39;加到开机列表: chkconfig -add mysqld一条命令解决mysql_config not found: #遇到过几次pip安装mysql-python的时候出现如题的问题，在这里记录一下解决方法。#找不到mysql_config一般是由于通过lnmp.org或者其他方式安装mysql以后mysql_config是在/usr/local/mysql/bin/里面，这里面的文件不是在任意位置都可以访问的#解决方法：ln -s /usr/local/mysql/bin/mysql_config /usr/local/bin/mysql_config#将mysql_config链接到/usr/local/bin目录下jdk安装 http://blog.csdn.net/sonnet123/article/details/9290561Tomcat加固 Tomcat帐号安全  将$CATALINA_HOME\conf\tomcat-users.xml中文件的所有用户都注释掉 删除除了需要部署上去的应用，其余位于$CATALINA_HOME\webapps文件夹中的应用 禁止Tomcat显示目录列表,确保$CATALINA_HOME\conf\web.xml中listings的值为false 配置shutdown端口:&amp;lt;Serverport=&amp;quot;未被占用的端口&amp;quot; shutdown=&amp;quot;较为复杂的字符串&amp;quot;&amp;gt; 隐藏Tomcat版本catalina.jar\org\apache\catalina\util\ServerInfo.properties  server.info=需要展现的信息如SmartCityserver.number=SmartCityserver.built=20140101开机管理 sudo apt-get install sysv-rc-conf#直接加入启动程序，例如把 /etc/init.d/nginx 加入到系统自动 启动列表中：sudo sysv-rc-conf nginx on //开启sudo sysv-rc-conf nginx off //关闭入侵日志分析 #查看登录成功日志过滤自己的ip ,-v 是notlast |grep -v 113.68.65.85#查看登录日志,是否有暴力破解tail -500 /var/log/secure |grep &amp;#34;Failed password&amp;#34;#history日志,查看是不是自己的操作history#查看所有用户cat /etc/passwd#查看1天前修改过的常规文件,看别人删除或者修改你的文件没find . -type f -mtime -1#查看开启的服务chkconfig --list | grep &amp;#39;3:on&amp;#39;#查看进程ps aux | grep python#端口情况sudo lsof -isudo netstat -lptusudo netstat -tulpnsudo netstat -ntlp#查看程序启动时间ps -eo pid,lstart,etime,cmd |grep skynet http://www.freebuf.com/articles/web/109001.html https://www.ibm.com/developerworks/cn/aix/library/au-sshlocks/ http://www.centoscn.com/CentOS/config/2015/0503/5347.html https://www.centos.bz/2012/12/block-port-scan-shell-script/ </content>
    </entry>
    
     <entry>
        <title>国内源</title>
        <url>https://farwmarth.com/post/%E5%9B%BD%E5%86%85%E6%BA%90/</url>
        <categories>
          <category>soft</category>
        </categories>
        <tags>
          <tag>npm</tag><tag>pypi</tag>
        </tags>
        <content type="html"> &amp;ndash;
清华大学的源太全面了: https://mirrors.tuna.tsinghua.edu.cn/
pypi 镜像状态监控: https://www.pypi-mirrors.org/
 豆瓣:http://pypi.douban.com/ 中国科学技术大学:http://pypi.mirrors.ustc.edu.cn/ 阿里云:http://mirrors.aliyun.com/pypi/simple  临时使用:
pip install -i https://&amp;lt;mirror&amp;gt;/simple &amp;lt;package&amp;gt;全局设置: 添加到 ~/.pip/pip.conf:
[global]index-url = https://&amp;lt;mirror&amp;gt;/simpleBrew proxychains brew install proxychains-ngvim /usr/local/Cellar/proxychains-ng/4.11/etc/proxychains.conf # 将最后一行的 socks4 127.0.0.1 9095 改成 socks5 127.0.0.1 1080 # 这个端口大家都懂什么意思吧proxychains4 brew install xxxxxxxhttp://ban.ninja/ # 设置环境变量 HOMEBREW_BOTTLE_DOMAIN 即可使用本镜像源加速下载 Homebrew 资源。# bash# 在 ~/.bashrc 中加入export HOMEBREW_BOTTLE_DOMAIN=http://7xkcej.dl1.z0.glb.clouddn.com# fish# 在 ~/.config/fish/config.fish 中加入set -x HOMEBREW_BOTTLE_DOMAIN http://7xkcej.dl1.z0.glb.clouddn.com清华大学开源软件镜像站 替换现有的git
cd /usr/localgit remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.gitcd /usr/local/Library/Taps/homebrew/homebrew-coregit remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.gitbrew update使用homebrew-science或者homebrew-python
cd /usr/local/Library/Taps/homebrew/homebrew-sciencegit remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-science.gitcd /usr/local/Library/Taps/homebrew/homebrew-pythongit remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-python.gitbrew updateHomebrew-bottles Homebrew-bottles 镜像使用帮助 注:该镜像是 Homebrew 二进制预编译包的镜像。本镜像站同时提供 Homebrew 的 formula 索引的镜像（即 brew update 时所更新内容），请参考 Homebrew 镜像使用帮助。
临时替换
export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles长期替换
echo &amp;#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&amp;#39; &amp;gt;&amp;gt; ~/.bash_profilesource ~/.bash_profilecoding.net cd /usr/local &amp;amp;&amp;amp; git remote set-url origin https://git.coding.net/homebrew/homebrew.gitcd $home &amp;amp;&amp;amp; brew updateyarn (https://github.com/yarnpkg/yarn)
淘宝源
yarn config set registry &amp;#39;https://registry.npm.taobao.org&amp;#39;npm 临时使用
npm --registry https://registry.npm.taobao.org install默认使用
npm set registry https://registry.npm.taobao.org或编辑 ~/.npmrc 添加安装淘宝的cnpm
npm install -g cnpm --registry=https://registry.npm.taobao.orggit proxy #设置git config --global http.proxy &amp;#39;socks5://127.0.0.1:1080&amp;#39;git config --global https.proxy &amp;#39;socks5://127.0.0.1:1080&amp;#39;#取消git config --global --unset http.proxygit config --global --unset https.proxy使用proxychains4 #安装brew install proxychains-ng#编译代理地址vim /usr/local/etc/proxychains.conf｀http xxx.com 8080｀#设置别名alias pc=&amp;#34;proxychains4&amp;#34;#使用pc git clone xxx.git</content>
    </entry>
    
     <entry>
        <title>域名解析的一些概念</title>
        <url>https://farwmarth.com/post/a%E8%AE%B0%E5%BD%95/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>domain</tag>
        </tags>
        <content type="html"> ##概念
  A记录（IP指向） 用户可以在此设置子域名并指向到自己的目标主机地址上，从而实现通过域名找到服务器找到相应网页的功能。 说明：指向的目标主机地址类型只能使用IP地址。
  CNAME（别名指向）
  通常称别名指向。您可以为一个主机设置别名。相当于用子域名来代替ip地址，优点是如果ip地址变化，只需要改动子域名的解析，而不需要逐一改变ip地址解析。
1. CNAME的目标主机地址只能使用主机名，不能使用IP地址；2. 主机名前不能有任何其他前缀，如：http://等是不被允许的；3. A记录优先于CNAME记录。即如果一个主机地址同时存在A记录和CNAME记录，则CNAME记录不生效。  MX记录  邮件交换记录。用于将以该域名为结尾的电子邮件指向对应的邮件服务器以进行处理。如：用户所用的邮件是以域名mydomain.com为结尾的，则需要在管理界面中添加该域名的MX记录来处理所有以@mydomain.com结尾的邮件。 说明：
1. MX记录可以使用主机名或IP地址；2. MX记录可以通过设置优先级实现主辅服务器设置，&amp;quot;优先级&amp;quot;中的数字越小表示级别越高。也可以使用相同优先级达到负载均衡的目的；3. 如果在&amp;quot;主机名&amp;quot;中填入子域名则此MX记录只对该子域名生效。  NS记录（Name Server）  是域名服务器记录。用来表明由哪台服务器对该域名进行解析。您注册域名时，总有默认的DNS服务器，每个注册的域名都是由一个DNS域名服务器来进行解析的，DNS服务器NS记录地址一般以以下的形式出现：
ns1.domain.comns2.domain.com说明：
1. &amp;quot;优先级&amp;quot;中的数字越小表示级别越高；2. &amp;quot;IP地址/主机名&amp;quot;中既可以填写IP地址，也可以填写像ns.mydomain.com这样的主机地址，但必须保证该主机地址有效。如，将 news.mydomain.com的NS记录指向到ns.mydomain.com，在设置NS记录的同时还需要设置ns.mydomain.com的 指向，否则NS记录将无法正常解析；3. NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。</content>
    </entry>
    
     <entry>
        <title>在CentOS 6.X 上升级 Python为 2.7</title>
        <url>https://farwmarth.com/post/%E5%8D%87%E7%BA%A7centos%E4%B8%8A%E7%9A%84python/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>centos</tag>
        </tags>
        <content type="html"> CentOS 6.X 自带的python版本是 2.6 , 但是2.6已经被不被官方支持了，今天写后台程序放到阿里云上运行发现2.6的一些api和2.7不一样了。于是想升级下python 安装依赖包 yum install -y zlib-devel bzip2-devel openssl-devel xz-libs wget源码编译 wget http://www.python.org/ftp/python/2.7.8/Python-2.7.8.tar.xz# 可以使用国内的源wget http://mirrors.sohu.com/python/2.7.8/Python-2.7.8.tar.xzxz -d Python-2.7.8.tar.xztar -xvf Python-2.7.8.tar安装详情： # 进入目录:cd Python-2.7.8# 运行配置 configure:./configure --prefix=/usr/local# 编译安装:makemake altinstall# 检查 Python 版本:[root@dbmasterxxx ~]# python2.7 -VPython 2.7.8链接python 为了使我们刚安装的2.7.8 生效要么加入PATH目录要么进入软连接：
加入PATH export PATH=&amp;#34;/usr/local/bin:$PATH&amp;#34;软连接 #如果连接时提示错误“ln: creating symbolic link `/usr/bin/python&amp;#39;: File exists”则先改名mv /usr/bin/python /usr/bin/python2.6ln -s /usr/local/bin/python2.7 /usr/bin/python检查 [root@dbmasterxxx ~]# python -VPython 2.7.8[root@dbmasterxxx ~]# which python /usr/bin/python安装 setuptools #获取软件包wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-1.4.2.tar.gz# 解压:tar -xvf setuptools-1.4.2.tar.gzcd setuptools-1.4.2# 使用 Python 2.7.8 安装 setuptoolspython2.7 setup.py install安装 PIP curl https://bootstrap.pypa.io/get-pip.py | python2.7 -
修复 yum 工具 此时yum应该是失效的，因为此时默认python版本已经是2.7了。而yum需要的是2.6 所以：
#修改 yum中的python 将第一行 #!/usr/bin/python 改为 #!/usr/bin/python2.6安装sqlite3 yum install sqlite-develpip install pysqlite#重新编译python</content>
    </entry>
    
     <entry>
        <title>给Iphone换个自定义的铃声</title>
        <url>https://farwmarth.com/post/%E7%BB%99iphone%E6%8D%A2%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%93%83%E5%A3%B0/</url>
        <categories>
          <category>soft</category><category>life</category>
        </categories>
        <tags>
          <tag>iphone</tag><tag>skill</tag>
        </tags>
        <content type="html"> &amp;ndash;
概述 iPhone的铃声格式是m4r格式，普通的mp3无法直接设置为铃声,所以需要使用铃声制作工具来转换,一般电话铃声的最长时长设置为40s,闹钟的时长最长为30s
制作工具 Ringer制作铃声 Ringer是Mac上制作铃声的工具,操作非常简单,将下载的歌曲播放到Ringer的主界面
 大音轨用于精确控制,双击大的音轨可以从点击处开始播放,设置头尾的Preview可以听整个铃声,下面的小音轨用来快速拖动预览声音 可以制作两种:铃声和立名声音,没发现太大的区别只是最大时长不一样 FadeOut/FadeIn : 为铃声添加淡入淡出效果 设置好后点击Create按钮即可将制作好的铃声自动导入到Itunes中  Itools制作铃声 Itunes制作铃声 其实Itunes也可以制作铃声,步骤稍微繁琐一些. 在显示简介界面来截取铃声长度,如果要预览可以点击确定,在itunes上面的播放区播放预览 转换AAC版本在新版在itunes中移动了位置，并不在右键菜单中,而在文件菜单 转换好后签名为m4r 切换到铃声选项 将刚才重命名的m4r文件添加资料库中,如果是在itnues音乐目录下直接改名的可能要移动到桌面或其他位置，不然会出现相同名字而导入失败 Itunes同步 Iphone上的铃声制作软件 iphone上在线下载设置铃声的软件不在少数,制作铃声的却寥寥无几。 目前只找到了这个： https://itunes.apple.com/cn/app/shou-ji-ling-sheng-mian-fei-ban/id435945279?mt=8 可以下载搜索并且自己裁剪铃声，但是有广告，体验也不是太好
设置铃声 同步成功后在iphone的铃声设置界面可以找到刚才我们自己制作的铃声
</content>
    </entry>
    
     <entry>
        <title>如何避免一些危险的指令操作</title>
        <url>https://farwmarth.com/post/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%B8%80%E4%BA%9B%E5%8D%B1%E9%99%A9%E7%9A%84%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>hook</tag>
        </tags>
        <content type="html"> git引发的事故 上周服务器的一位同事一个不小心用了git push -f,抹掉了我们一上午的工作内容,还好抹掉的记录不是太多大概八九条. 各自花了大概半小时恢复了数据
恢复过程 #查看所有的本地操作数据git reflog#或者查看所有数据,找到被抹掉的commitgit log -g#复制一个提交节点并在当前分支做一次完全一样的新提交。git cherry-pick commit_id可以看出强制提交这个命令的危险性,如何来禁止强制呢?
禁止强制推送 本地禁止强制推送 git config --global receive.denyNonFastForwards truegit config --global receive.denyDeletes truehook方式 https://gist.github.com/stefansundin/d465f1e331fc5c632088
gitbucket 远程仓库禁止强制推送 gitbucket提供了分支权限配置: 参考
Rewriting history 就是防止强制推送
github配置 https://help.github.com/articles/configuring-protected-branches/
gitlab配置 https://about.gitlab.com/2014/11/26/keeping-your-code-protected/
强制删除rm -rf mac下可以用zsh这样的终端rm -rf /会有二次确认
trash-cli #https://github.com/andreafrancia/trash-clieasy_install trash-clirmtrash brew install rmtrash#配置alias rm=&amp;#34;rmtrash&amp;#34;alias rmdir=&amp;#34;rmdirtrash&amp;#34;mv替代rm mkdir -p ~/.trashalias rm=trash alias r=trash alias rl=&amp;#34;ls ~/.trash&amp;#34;alias ur=undelfileundelfile(){mv -i ~/.trash/$@ ./}trash(){ mv $@ ~/.trash/}</content>
    </entry>
    
     <entry>
        <title>权重随机算法</title>
        <url>https://farwmarth.com/post/%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>随机</tag>
        </tags>
        <content type="html"> 带权随机算法在游戏开发中应用广泛,最近在做商店随机商品又遇到这种问题,重新思考并总结了一下带权随机的做法.
带权随机其实很好理解 比如我们希望抽到A的抽到的比重是10,B的比重是5,C的比重是1,如下图 权重和计算 常规做法是计算权重总和sum，然后在1到sum之间随机选择一个数R，之后遍历整个集合，统计遍历的项的权重之和，如果大于等于R，就停止遍历，选择遇到的项 好处:没有额外的空间占用，算法也比较简单。 坏处:选取的时候要遍历集合，时间复杂度是O（n）。
常规做法 math.randomseed(os.time())function pick(rules, count)local ret = {}local total_weight = 0for _, v in ipairs(rules) dototal_weight = total_weight &#43; v.weightendfor i=1, count dolocal rd = math.random(total_weight)for _, rule in ipairs(rules) doif rd &amp;lt;= rule.weight thentable.insert(ret, rule.item)breakelserd = rd - rule.weightendendendreturn retendfunction weight_unique_pick_one(rules, count)local ret = {}local function get_total_weight( rules )local total_weight = 0for _, v in ipairs(rules) dototal_weight = total_weight &#43; v.weightendreturn total_weightendlocal total_weight =get_total_weight(rules)for i=1, count dolocal rd = math.random(total_weight)for index, rule in ipairs(rules) doif rd &amp;lt;= rule.weight thentable.insert(ret, rule.item)table.remove(rules, index)total_weight =get_total_weight(rules)breakelserd = rd - rule.weightendendendreturn retend--test local ret = weight_unique_pick_one({{item=1,weight=1},{item=2,weight=50},{item=3,weight=4},{item=4,weight=4},{item=5,weight=4},{item=6,weight=4},{item=7,weight=50},{item=8,weight=4}},4)print(&amp;#34;------------------&amp;#34;)for i,v in ipairs(ret) doprint(i,v)end按照权重排序优化 对项目集按照权重排序。这样遍历的时候，概率高的项排在前面，减少遍历的项。 比较{A:5，B:2，C:2，D:1}和{B:2，C:2，A:5，D:1} 前者遍历步数的期望是5/101&#43;2/102&#43;2/103&#43;1/104而后者是2/101&#43;2/102&#43;5/103&#43;1/104。 好处:提高了平均选取速度。 坏处:需要进行排序，并且不易添加删除修改项。
实现很简单将上面的weight_unique_pick_one方法中rules按字段weight做一个高到低排序就可以了
function weight_unique_pick_one(rules, count)local ret = {}table.sort(rules,function(a, b) return b.weight &amp;lt; a.weight end )...end折半查找改进版本 折半查找的改进方法是将所有项的区间定义头尾,构造一个已排序的区间,然后用二分法加快查找random的区间
实现如下:
local function binsearch( t,value )local i_start,i_end,i_mid = 1,#t,0while i_start &amp;lt;= i_end doi_mid = math.floor( (i_start&#43;i_end)/2 )local value2 = t[i_mid]if value == value2 thenreturn i_midelseif value &amp;gt; value2 theni_end = i_mid - 1elsei_start = i_mid &#43; 1endendendlocal function bisect_left( t,value )local i_start,i_end,i_mid = 1,#t,0while i_start &amp;lt; i_end doi_mid = math.floor( (i_start&#43;i_end)/2 )local value2 = t[i_mid]if value2 &amp;lt; value theni_start = i_mid &#43; 1elsei_end = i_midendendreturn i_startendlocal function get_weight_interval( rules )local total_weight = 0local weight_interval = {}for _, v in ipairs(rules) dototal_weight = total_weight &#43; v.weighttable.insert(weight_interval,total_weight)endreturn total_weight,weight_intervalendfunction weight_unique_pick(rules, count)local ret = {}local total_weight,weight_interval =get_weight_interval(rules)for i=1, count dolocal rd = math.random(total_weight)local b_index = bisect_left(weight_interval,rd)local item = rules[b_index]table.insert(ret, item.item)table.remove(rules, b_index)total_weight,weight_interval =get_weight_interval(rules)endreturn retend--test local ret = weight_unique_pick({{item=1,weight=1},{item=2,weight=100},{item=3,weight=4},{item=4,weight=4},{item=5,weight=50}},3)print(&amp;#34;------------------&amp;#34;)for i,v in ipairs(ret) doprint(i,v)end纯算法实现 算法来源: http://utopia.duth.gr/~pefraimi/research/data/2007EncOfAlg.pdf 参考: http://kanglinxm.blogspot.jp/2013/10/blog-post.html
纯算法实现的关键实现:
for _,item in ipairs(rules) dolocal u = math.random();local w_i = 1 / item.weight;local k = math.pow(u, w_i);end随机一个0-1之间的小数作为底数,将1/权重作为幂,权重越大,随机数相同时结果越大.将k由大到小排序取前count个即为要随机的个数.这种算法缺点是必须随机所有的项得到随机结果集.
完整实现:
function weight_unique_math(rules, count)local ret = {}local all_random_weight = {}for _,item in ipairs(rules) dolocal u = math.random();local w_i = 1 / item.weight;local k = math.pow(u, w_i);table.insert(all_random_weight,{item =item.item,random_weight = k})endtable.sort(all_random_weight,function(a, b) return b.random_weight &amp;lt; a.random_weight end )for i=1,count dolocal item = all_random_weight[i].itemtable.insert(ret,item)endreturn retendlocal items = {{item=1,weight=1},{item=2,weight=50},{item=3,weight=4},{item=4,weight=4},{item=5,weight=4},{item=6,weight=4},{item=7,weight=50},{item=8,weight=4}}local ret = weight_unique_math(items,3)for i,v in ipairs(ret) doprint(i,v)end</content>
    </entry>
    
     <entry>
        <title>readthedocs切换到mkdocs</title>
        <url>https://farwmarth.com/post/mkdocs/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>mkdocs</tag>
        </tags>
        <content type="html"> 之前把学习笔记用sphinx生成然后托管在github上,然后用readthedocs的webhook自动build文章数量渐多感觉排版拥挤.于是google了一下找了个替代品,那就就是这篇文章的主角mkdocs
简介 mkdocs是一个支持markdown语法的项目文档管理工具，结构很简单,一个yml配置文件管理文档结构和主题信息,docs目录则是项目文档.官方文档(http://www.mkdocs.org/)
新建工程 #安装mkdocspip install mkdocs#新建工程目录mkdocs new my-project#切换到工程目录cd my-project工程目录如下:
├── mkdocs.yml├── docs│ ├── index.md启动 #启动服务器,默认端口是8000 Running at: http://127.0.0.1:8000/mkdocs serve所有命令 #生成htmlmkdocs build#新建工程目录mkdocs new my-project#部署到github的gh-deploy分支mkdocs gh-deploy -v#markdown生成json文件mkdocs json#启动预览mkdocs serve配置 我用的主题是material:
pip install mkdocs-material项目配置大概列了一,大致分为几部分：项目信息，托管信息，版权信息，主题与文档目录，配色信息,额外插件，还有就是项目文档目录结构有些配置与主题相关
# Project informationsite_name: farwmarth’s notesite_author: &amp;#39;farwmarth&amp;#39;site_url: &amp;#39;http://learndocs.farwmarth.com&amp;#39;# Repository# repo_name: &amp;#39;GitHub&amp;#39;# repo_url: &amp;#39;https://github.com/wujiyu115/learndocs&amp;#39;# Copyrightcopyright: &amp;#39;Copyright (c) 2016 farwmarth&amp;#39;# Documentation and themedocs_dir: &amp;#39;docs&amp;#39;theme: &amp;#39;material&amp;#39;# theme: &amp;#39;cinder&amp;#39;extra:palette:primary: &amp;#39;blue grey&amp;#39;accent: &amp;#39;blue grey&amp;#39;author:github: &amp;#39;wujiyu115&amp;#39;# Extensionsmarkdown_extensions:#高亮- codehilite(css_class=code)- admonition- toc:permalink: &amp;#39;#&amp;#39;pages:- Home: &amp;#39;index.md&amp;#39;- 数据结构与算法:- &amp;#39;排序算法介绍&amp;#39;: &amp;#39;data_algorithms/algorithms1_intro.md&amp;#39;- c&#43;&#43;基础:- &amp;#39;c&#43;&#43;环境搭建(Win)&amp;#39;: &amp;#39;cplus/cplus_win.md&amp;#39;- &amp;#39;编译过程&amp;#39;: &amp;#39;cplus/cplus4_complier.md&amp;#39;- &amp;#39;常量修饰符&amp;#39;: &amp;#39;cplus/cplus5_const.md&amp;#39;- python:- &amp;#39;语言简介&amp;#39;: &amp;#39;python/py1_intro.md&amp;#39;托管到github 之前误认为github只能有一个page页,看了 官方的介绍之后发现并非如此，有两种方式创建page页，一种是创建一个就{username}.github.com的库项目,另一种则是创建任意库项目可以在setting中Launch automatic page generator生成gh-pages分支，创建方式这里就不细说了,可以根据page官方的引导去操作。
这个表格是username库项目和任意库项项目对应的域名指向.
   Type of GitHub Pages site Pages default domain &amp;amp; host location on GitHub Location of the source files for building your Pages site     User Pages site username.github.io master   Project Pages site owned by a user account 、 master, gh-pages, or a /docs folder on master    username库项目毫无疑问地址就是username.github.io,任意库项项目生成的工程页则是username.github.io/projectname. 我现在的做法是在username库项目下的CNAME指向我的主域名farwmarth.com,learndocs库项项目的CNAME指向我的二级域名learndocs.farwmarth.com.
dnspod配置如下：
最后learndocs库项项目源文件托管到master分支,然后mkdocs gh-deploy把生成的html静态页面托管是gh-pages分支。注意master分支把生成的site目录忽略掉
echo &amp;#34;site/&amp;#34; &amp;gt;&amp;gt; .gitignore</content>
    </entry>
    
     <entry>
        <title>vsftpd使用</title>
        <url>https://farwmarth.com/post/vsftpd/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>vsftpd</tag>
        </tags>
        <content type="html"> 安装 vsftpd意思为“very secure FTP daemon(非常安全的FTP进程)”，是一个基于GPL发布的类UNIX类操作系统上运行的服务器的名字（是一种守护进程），可以运行在诸如Linux、BSD、Solaris、HP-UX以及Irix等系统上面。vsftpd支持很多其他传统的FTP服务器不支持的良好特性
命令 #安装yum install vsftpd#启动service vsftpd start#重启service vsfptd restart配置 配置文件 在/etc/vsftpd目录下的配置文件:
 vsfptd.conf:主配置 ftpusers:不允许登录的用户,不受任何配制项的影响 userlist_file:userlist_enable和userlist_deny控制,这两个参数配置不同他可以是白名单也可以是黑名单.创建tom: 在user_list中,jim:不在user_list中测试配置关系  Case 1: userlist_enable=YES, userlist_deny=YES tom: 拒绝登入 jim: 允许登录 Case 2: userlist_enable=YES, userlist_deny=NO tom: 允许登录 jim:拒绝登录（如user_list文件开头的注释所述，甚至不会提示输入密码，即无登入提示框，直接拒绝连接） Case 3: userlist_enable=NO,userlist_deny=NO tom: 允许登录 jim: 允许登录 Case 4: userlist_enable=NO,userlist_deny=YES tom: 允许登录 jim: 允许登录 userlist_enable和userlist_deny两个选项联合起来针对的是：本地全体用户（除去ftpusers中的用户）和出现在user_list文件中的用户以及不在在user_list文件中的用户这三类用户集合进行的设置。 当且仅当userlist_enable=YES时：userlist_deny项的配置才有效，user_list文件才会被使用；当其为NO时，无论userlist_deny项为何值都是无效的，本地全体用户（除去ftpusers中的用户）都可以登入FTP 当userlist_enable=YES时，userlist_deny=YES时：user_list是一个黑名单，即：所有出现在名单中的用户都会被拒绝登入； 当userlist_enable=YES时，userlist_deny=NO时：user_list是一个白名单，即：只有出现在名单中的用户才会被准许登入(user_list之外的用户都被拒绝登入)；另外需要特别提醒的是：使用白名单后，匿名用户将无法登入！除非显式在user_list中加入一行：anonymous    更改vsfptd.conf关键配置: #接受匿名用户anonymous_enable=NO#若为YES,则userlist_file中的用户将不能登录,为NO则只有userlist_file的用户可以登录userlist_deny=NO#监听端口listen_port = 21#指定默认用户目录local_root=/var/www/html#指定系统用户只能访问其主目录chroot_local_user=YESchroot_list_enable=YESchroot_list_file=YES#匿名用户目录anon_root=/var/www/html添加用户登录 #添加用户update主目录为/home/user_updateuseradd -d /home/user_update update -s /bin/bash#设置密码passwd update## 更改用户update的主目录为/updateusermod -d /user_update update#在 `/etc/vsftpd/userlist_file` 中添加`update`用户#更改目录权限给updatechown -R update client_update/chmod -R 755 目录防火墙 iptables -A INPUT -p tcp --dport 21 -j ACCEPTservice iptables saveservice iptables statusservice iptables restartcannot change directory:/root #设置切换目录setsebool -P ftpd_disable_trans 1#设置ftp读写控制setsebool -P allow_ftpd_full_access 1service vsftpd restartlinux vsftpd 550 create directory operation failed 关闭SELinux方法
#vi /etc/selinux/configSELINUX=disabled如果用root登录  注释 /etc/vsftpd/ftpusers 中root用户 在 /etc/vsftpd/userlist_file 中添加root用户  配详解 vsftpd.conf中文详解 /etc/vsftpd/vsftpd.conf
#################用户选项###############接受匿名用户anonymous_enable=YES#匿名用户login时不询问口令no_anon_password=YES#匿名用户主目录anon_root=(none)#接受本地用户local_enable=YES#本地用户主目录local_root=(none)#如果匿名用户需要密码,那么使用banned_email_file里面的电子邮件地址的用户不能登录deny_email_enable=YES#仅在没有pam验证版本时有用,是否检查用户有一个有效的shell来登录check_shell=YES#若启用此选项,userlist_deny选项才被启动userlist_enable=YES#若为YES,则userlist_file中的用户将不能登录,为NO则只有userlist_file的用户可以登录userlist_deny=NO#如果和chroot_local_user一起开启,那么用户锁定的目录来自/etc/passwd每个用户指定的目录(这个不是很清楚,很哪位熟悉的指点一下)passwd_chroot_enable=NO#定义匿名登入的使用者名称。默认值为ftp。ftp_username=FTP#################用户权限控制################可以上传(全局控制).write_enable=YES#本地用户上传文件的umasklocal_umask=022#上传文件的权限配合umask使用#file_open_mode=0666#匿名用户可以上传anon_upload_enable=NO#匿名用户可以建目录anon_mkdir_write_enable=NO匿名用户其它的写权利(更改权限?)anon_other_write_enable=NO如果设为YES，匿名登入者会被允许下载可阅读的档案。默认值为YES。anon_world_readable_only=YES#如果开启,那么所有非匿名登陆的用户名都会被切换成guest_username指定的用户名#guest_enable=NO所有匿名上传的文件的所属用户将会被更改成chown_usernamechown_uploads=YES匿名上传文件所属用户名chown_username=lightwiter#如果启动这项功能，则所有列在chroot_list_file之中的使用者不能更改根目录chroot_list_enable=YES#允许使用\&amp;#34;async ABOR\&amp;#34;命令,一般不用,容易出问题async_abor_enable=YES管控是否可用ASCII 模式上传。默认值为NO。ascii_upload_enable=YES#管控是否可用ASCII 模式下载。默认值为NO。ascii_download_enable=YES#这个选项必须指定一个空的数据夹且任何登入者都不能有写入的权限，当vsftpd 不需要file system 的权限时，就会将使用者限制在此数据夹中。默认值为/usr/share/emptysecure_chroot_dir=/usr/share/empty###################超时设置###################空闲连接超时idle_session_timeout=600#数据传输超时data_connection_timeout=120#PAVS请求超时ACCEPT_TIMEOUT=60#PROT模式连接超时connect_timeout=60################服务器功能选项################开启日记功能xferlog_enable=YES#使用标准格式xferlog_std_format=YES#当xferlog_std_format关闭且本选项开启时,记录所有ftp请求和回复,当调试比较有用.#log_ftp_protocol=NO#允许使用pasv模式pasv_enable=YES#关闭安全检查,小心呀.#pasv_promiscuous&#43;NO#允许使用port模式#port_enable=YES#关闭安全检查#prot_promiscuous#开启tcp_wrappers支持tcp_wrappers=YES#定义PAM 所使用的名称，预设为vsftpd。pam_service_name=vsftpd#当服务器运行于最底层时使用的用户名nopriv_user=nobody#使vsftpd在pasv命令回复时跳转到指定的IP地址.(服务器联接跳转?)pasv_address=(none)#################服务器性能选项###############是否能使用ls -R命令以防止浪费大量的服务器资源#ls_recurse_enable=YES#是否使用单进程模式#one_process_model#绑定到listen_port指定的端口,既然都绑定了也就是每时都开着的,就是那个什么standalone模式listen=YES#当使用者登入后使用ls -al 之类的指令查询该档案的管理权时，预设会出现拥有者的UID，而不是该档案拥有者的名称。若是希望出现拥有者的名称，则将此功能开启。text_userdb_names=NO#显示目录清单时是用本地时间还是GMT时间,可以通过mdtm命令来达到一样的效果use_localtime=NO#测试平台优化#use_sendfile=YES################信息类设置#################login时显示欢迎信息.如果设置了banner_file则此设置无效ftpd_banner=欢迎来到湖南三辰Fake-Ta FTP 网站.#允许为目录配置显示信息,显示每个目录下面的message_file文件的内容dirmessage_enable=YES#显示会话状态信息,关!#setproctitle_enable=YES############## 文件定义 ###################定义不能更改用户主目录的文件chroot_list_file=/etc/vsftpd/vsftpd.chroot_list#定义限制/允许用户登录的文件userlist_file=/etc/vsftpd/vsftpd.user_list#定义登录信息文件的位置banner_file=/etc/vsftpd/banner#禁止使用的匿名用户登陆时作为密码的电子邮件地址banned_email_file=/etc/vsftpd.banned_emails#日志文件位置xferlog_file=/var/log/vsftpd.log#目录信息文件message_file=.message############## 目录定义 ##################定义用户配置文件的目录user_config_dir=/etc/vsftpd/userconf#定义本地用户登陆的根目录,注意定义根目录可以是相对路径也可以是绝对路径.相对路径是针对用户家目录来说的.local_root=webdisk #此项设置每个用户登陆后其根目录为/home/username/webdisk#匿名用户登陆后的根目录anon_root=/var/ftp#############用户连接选项##################可接受的最大client数目max_clients=100#每个ip的最大client数目max_per_ip=5#使用标准的20端口来连接ftpconnect_from_port_20=YES#绑定到某个IP,其它IP不能访问listen_address=192.168.0.2#绑定到某个端口#listen_port=2121#数据传输端口#ftp_data_port=2020#pasv连接模式时可以使用port 范围的上界，0 表示任意。默认值为0。pasv_max_port=0#pasv连接模式时可以使用port 范围的下界，0 表示任意。默认值为0。pasv_min_port=0##############数据传输选项##################匿名用户的传输比率(b/s)anon_max_rate=51200#本地用户的传输比率(b/s)local_max_rate=5120000http://desert3.iteye.com/blog/1685734
</content>
    </entry>
    
     <entry>
        <title>脚本自动化手册</title>
        <url>https://farwmarth.com/post/%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%8B%E5%86%8C/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>shell</tag>
        </tags>
        <content type="html"> 同步文件 rsync(remote synchronize) 实现远程同步功能的软件,它在同步文件的同时,可以保持原来文件的权限、时间、软硬链接等附加信息.
rsync认证方式 rsync有两种常用的认证方式，一种是rsync-daemon方式，另外一种是ssh方式。在平时使用过程，我们使用最多的是rsync-daemon方式
rsync服务器架设 rsync的主要有以下三个配置文件rsyncd.conf(主配置文件)、rsyncd.secrets(密码文件)、rsyncd.motd(rysnc服务器信息)
 rsyncd.conf  #从远程机器同步文件到本机/usr/bin/rsync -rlptDvzHS --port=1111 --password-file=/etc/xx.password root@1.1.1.1::xx/bin/logic/ /data/xx/bin/logic/#本机目录同步,--delete-excluded:目标目录中存在在源目录不存在删除,并且如果 --exclude指定的也会删除rsync --delete-excluded -avzp --exclude=3rd target/ des/scp 复制rsa密钥到远程主机 scp C:\Users\Administrator\.ssh\vps_Identity.pub user@example.com:/home/user/.ssh/vps_far.publrzsz 便携的ssh上传下载工具 yum install lrzsz#从服务器下载sz download.txt#从本机选择文件上传rz压缩文件 haozip &amp;#34;D:\Program Files\HaoZip\HaoZipC.exe&amp;#34; a -tzip crt.zip C:\Users\Administrator.PC-20150720QKHJ\AppData\Roaming\VanDyke\Config\*tar 压缩 tar -zcvf $PackFile $Project &amp;gt; /dev/nulllinux 切割文件 split #按文件大小切割split -b 10m yybao_s1.out yybao_s1_#按文件行数切割split -l 100 test.txtlogrotate 强制执行某个日志的切,如log.config是在/etc/logrotate.d下文件的文件名logrotate -f log.config
基本配置 opt/clps_tomcat/logs/catalina.out #要切割的日志{daily #每日执行dateext #切换后的日志文件会附加上一个短横线和YYYYMMDD格式的日期copytruncate #复制日志后会清空在数据nocompress ##不压缩rotate 15 ##保留15次ratate日志#size=5MB # k,MB(M),GB(G)}mac 下 logrotate 安装 #执行brew install logrotate#.zshrcexport LOGROTATE_HOME=/usr/local/Cellar/logrotate/3.9.1/sbinexport PATH=${PATH}:${LOGROTATE_HOME}日志切割 ”/data/yxiii/bin/logs/*.out“{size 10mdateextcopytruncatenocompressrotate 20}linux 定时任务 at 命令 #明天四点执行shell.sh中的命令at -f shell.sh 4 am tomorrowat -f /home/far/Develop/heros/code/server/trunk/bin/stop.sh 4:00 tomorrow#查看指定任务at -c 8#查看列表atq#删除指定任务atrm 1crontab crontab脚本目录  /etc/crontab: 这个文件负责安排由系统管理员制定的维护系统以及其他任务的crontab /etc/cron.d/: 这个目录用来存放任何要执行的crontab文件或脚本 /var/spool/cron/far: 这个目录下存放的是每个用户（包括root）的crontab任务  crontab 服务查看  启动服务: /sbin/service crond start 关闭服务: /sbin/service crond stop 重启服务: /sbin/service crond restart 重新载入配置: /sbin/service crond reload 查看服务状态: /sbin/service crond status  crontab 选项  概要  crontab [ -u user ] filecrontab [ -u user ] [ -i ] { -e | -l | -r } -l:在控制台输出计划执行结果 -r :移除指定的文件计划 -e 编辑crontab默认配置文件 -i : -r移除之前加上确认 验证是否已删除 crontab 文件: ls /var/spool/cron/crontabs  基本配置 SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=rootHOME=/# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR#sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * command to be executed0 4 8 5 * /Users/far/Develop/workdir/heros_codingnet/bin/stop.sh43 23 7 5 * /Users/far/Develop/workdir/heros_codingnet/bin/stop.sh59 23 12 * * /bin/bash /root/stop_games.sh all实例 自动打包文件备份到指定目录 把/data下文件打包备份到/data/backup下以天为文件名,并清除七天以前的备份` 增加计划任务
export EDITOR=vicrontab -e0 0 * * * /data/bak.sh;bak.sh文件内容如下:
#!/bin/bashlogs_dir=/databak_dir=/data/backupbak_file=bak_`date &#43;%Y%m%d`echo &amp;#34;begining of tar&amp;#34;tar zcf $bak_dir/$bak_file.gz $logs_dir/*.*echo &amp;#34;clearing file.log&amp;#34;find $bak_dir -mtime &#43;7 -exec rm -rf {} \;#end</content>
    </entry>
    
     <entry>
        <title>驾考</title>
        <url>https://farwmarth.com/post/%E9%A9%BE%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>driver</tag><tag>life</tag>
        </tags>
        <content type="html"> 报考 驾照这个事情其实被搁置了很久,一来人太懒,再者觉得边上班还要请假练车是件比较让人头痛的事情,年初的时候被催着把这报名的事情给完成了,报名之前听说广州报个名,拿到证一年多是家常便饭,主要是排队时间太长了.
报考前也逛了一下附近的驾校,知乎上,贴吧上一些帖子也琢磨了下,一般驾校分快慢班,快班的意思就是广州练车可能就到湖南去考试,快班自然价格要贵一些，包括了长途的交通费用，还有一个就是手动档和自动档,一般都学习手动档,学费便宜一些,另外可以驾驶自动档的车型。
斟酌之后还是直接在帖吧里找了一个教练的qq,电话聊了一下觉得这个教练不错,简单约定了一下就把其他四个同事也拉过来报名了。把教练而不直接在驾校报名或者像猪兼强那种平台的原因是:最终都练车和时间分配的都是教练把握,不经过第三方中转价格也更透明一些。有的驾校场地比较小,虽然离得近但是练车时间太少了通过率不高。
科目一 3月份报的名,然后交了一部分定金,科目一考完后才把全额交完. 科目一的考试感觉就像是回到了小学时代.在考试前把一千多道题用&amp;laquo;驾考宝典&amp;raquo; 整个过一遍,然后针对自己把易错的题再捊一遍就差不多了。考试题目是一百道,及格是九十分,我列了一下科目一一些考试题:
#### 手势题学员所看到的交警手势都是镜面动作,不要考虑站在交警的角度上看动作.速记口决:左手过头勿前行，右手摆动靠边停。两手平伸右手摆，警察叔叔让直行。掌心向前你别动，哪手摆动向哪行。左手侧摆须待转，右手横摆道变更。变道安全很重要，右手下摆是慢行#### 易错点&#43; 拿到驾照后实习期为一年12个月&#43; 无中线,城三公四,同一向道,城五公七.&#43; 高速二车道:100,60,三车道110,90,60,最高120，最低60&#43; 虚线可以变道,实线无法变&#43; 转弯的机动车让直行车辆先行，右方道路来车先行，右转弯车让左转弯车先行.&#43; 白色菱形是人行道预警,要减速&#43; 夜间有前车时要超车,远近灯变换是提醒前车,左转向灯是提示后车我要超车&#43; 重新驾驶证:瞒1吊2贿赂撤3醉5逃终生&#43; 逃前人死3-7年，逃后人死7年以上，其余均为3年 闰&#43; 行驶的标志是用圆圈表示，而停车位是用矩形&#43; 酒驾20醉驾扣12分，醉驾80,约束至酒醒,五年内不得重新取得机动车驾驶证&#43; 黄灯前轮过线可通行,红灯,整车过线才可通行.黄灯闪烁瞭望确认无行人后通过&#43; 分离式路基公路左、右行车道分开修建的公路，包括中央分隔带不等宽的和左、右两侧行车道不等高的公路&#43; 有虚线的是紧急停车带,无的是错车道&#43; 高速公路字体黄色最高速度，黑色建议速度，白色最低速度&#43; 白色虚线，可跨越同向车道中心线，黄色虚线，指示标志，可超车掉头。&#43; 白色虚线和三角地带标组成标线:左入口右出口&#43; 箭头尾巴有弯折的是转弯，尾巴是弧线的是变道&#43; 机动车匝道驶入高速公路，开启左转向灯，进入减速车道开启右转向灯&#43; 发生故障时，高速在来车方向150以外设置警告标志，非高速50-100米，要开启危险报警闪光灯&#43; 不得连续驾驶4小时以上，休息20分钟&#43; 初得驾驶证有效期为6年，再是10年，长期&#43; 科目二三考试预约次数不得超过5次&#43; 准考证明的有效期是3年&#43; 申请驾驶证。汽车18-70岁，三轮车18-60岁&#43; 驾驶证过期后90日内换证，信息变更30日内，防撞带不需要信息变更&#43; 驶入左转向灯，驶出右转向灯 科目二 因为新平台运营的关系考试科目一通过后十天就可以预约科目二，这样节省了不少时间,刚开始对科目二挺没底的,因为以前只操作过两轮自行车&amp;hellip;.，练车大概流程是这样的：
第一天:转模拟方向盘,对于经常玩赛车游戏的同学来说是小菜一碟,练习打火,踩离合,挂挡,刹车,然后教练会带着你兜几圈熟悉一下开车的感觉。
第二天:练习倒车入库,为了应付考试教练一般都会有参考物,到固定参考点时转动方向盘,如果想提高容错率,前提是控制好离合让车速保持稳定,科目二都是在一档模式,转弯时会因为阻力变大要放部分离合保持速度.个人感觉最难把握的不是离合,而是入库时车身偏移时的方向修正。反正就是要反复练习,即使被教练骂得狗血淋头&amp;hellip;
第三天:就进入其他项练习了，上坡定点，侧方停车，曲线行驶和直角转弯,这里面没啥难点,主要是定点的时候参照物不好照,考场的车座位和参照物可能不一样,不过没太大影响，误差不太大只是扣分而已.还有就是直角转弯的时候要把握后转弯的时间点，这个也是有参考物的。
放上知乎大神们的原理剖析图,只做参考,最终还是按自己教练方法来,有时候看得方法一多脑子容易弄混. https://www.zhihu.com/question/24518251
下面是科目二的一些摘录:
### 离合踩到底时整腿跟进,从底返回时腿跟着往外移动一段距离,然后用脚跟作支撑点成角度压住离合.离合是提供动力是一个缓慢的过程:不要幅度过大.非空档时一定不要松离合.踩车未松开,不要将离合松到最大。### 刹车在要定点停车时，踩车脚要提前准备，速度过快也可以轻踏刹车来减速。### 档位换档和归空档都要将刹车踩到底换档前养成好习惯:先归空档,踩离合的左脚先松开调整位置再踩下去。再换档。### 方向盘记住转过去多少回转多少### 上下车顺序:上车:系安全带---&amp;gt;调整座位----&amp;gt;点火---&amp;gt;离合归空档调到1档---&amp;gt;拉起手刹---&amp;gt;轻松离合缓慢起步下车:归空档----&amp;gt;拉手刹---&amp;gt;熄火### 倒车入库#### 倒车入库顺序右边起点倒入库----&amp;gt;调整车身左转弯----&amp;gt;左边入库-----&amp;gt;右转弯开回右起点#### 右起点入库挂后退档,1档起步,观察左视镜下边缘-----&amp;gt;左视镜下边缘盖过起点黄线时方向盘向右打死(一圏半到时钟3点)-----&amp;gt;观察右视镜后方,先看到库左边线,当车尾与左顶角接触时将方向盘回拉四分之一圈(时钟12点方向)----&amp;gt;继续观察右视镜倒退后左库被盖过,此后只能看到右库边----&amp;gt;右库边与车身有三十公分左右间隙时宽度正合适,转过头观察左视镜注意左边车身与左库边----&amp;gt;当左库边出现在视野里时继续倒退----&amp;gt;当整条左库边线即将出现在视野时将方向盘回拉至九点方向再回转一圏(其实就是起点时转了一圈半后回拉一圈半)-----&amp;gt;观察左视镜与左库入口的黄线,下边缘刚盖过黄线时刹车归空档。#### 左转弯如果车身在右入库后有倾斜起步时踩低离合微调车身挂前起1档-----&amp;gt;直行时当我们自己的肩刚过左库入口边线时立即身左打方向盘1圈四分之一(逆时针12点方向)------&amp;gt;一直保持方向盘转弯到左侧虚线处,这个位置用眼镜观察左视镜下边缘过黄虚线大约两三个手指的视角踩车停止-----&amp;gt;归空档重踩左离合脚挂后退档，放刹车轻放离合后退-----&amp;gt;保持方向盘12点方向不动后退，观察右视镜,右后车轮中央踩上右库直边线时(如果不好理解就是想象将直边延长至车身处与右后胎中央相交)身左四分之一方向盘(即左边打满9点方向)------&amp;gt;转头观察左视镜,左库边将要全部出现在视野时方向盘回正(右转一圈半)----&amp;gt;后面的过程与右入库相同(观察左视镜与左库入口的黄线,下边缘刚盖过黄线时刹车归空档。)#### 开回起点1档起步压低离合-----&amp;gt;直行当车盖边边缘即将盖住道路实虚线时快速方向盘向(右边一圈半)-----&amp;gt;转变时不松一点离合不要让车身停止前进-----&amp;gt;要转完变时离合压低防止冲得太快来不及回调方向----&amp;gt;直视远方当车身与道路线平行时快速(左边一圈半)方向盘回位----&amp;gt;观察左视镜与起点黄虚线距离过两手指时刹车空档------&amp;gt;拉起手刹---&amp;gt;熄火下车。#### 偏差修正看视镜车尾与库边的距离,哪边宽方向盘往哪边打,修正幅度在45到90度内,太小轮胎转动过小### 坡道定点停车开至停车待上坡区------&amp;gt;轻松离合上坡(保证足够的动力不要上到一半车身间停)-----&amp;gt;眼睛瞄准调整车盘与右道路边线的轻微贴合观察水管与车内空调右角角度------&amp;gt;到个人估算角度时(矮一点的人是三点一线，高的人可能要过一点水管)同时刹车和离合-------&amp;gt;数5秒不要松开踩车,轻放离合直到车身震动有足够动力一二秒,保持这个离合位置------&amp;gt;轻松刹车上坡到坡顶------&amp;gt;下坡时离合踩到底刹车踩一半让车身保持惯性前行,不要忘记打方向盘转弯,如果方向盘没有即时转过来再下压点刹车降速------&amp;gt;到平地时先松踩车,方向盘转回,轻放离合(和平地起步一样)### 侧方停车开到虚线侧方停车前先观察前方的车辆是否已侧方完成------&amp;gt;开到侧方起点虚线处(角度也是左视镜下边缘与虚线二三手指)-----&amp;gt;归档后退档,后退起步当左视镜下边缘刚盖过虚线时方向盘(向右一周)---&amp;gt;继续后退观察右视镜,当车身右车尾与库顶点还有一点角度时(顶点快要出现在视野)方向盘(左转一圈)----&amp;gt;后退让后车轮中央正好踩在中央的虚线上立即将方向盘向左打满(一圈半9点方向)----&amp;gt;压低离合准备刹车脚,立即看前方的车盖左缝隙与边库虚线距离,当左缝隙刚过虚线内边缘时立刻刹车-----&amp;gt;归空档挂前进1档保持方向盘左满一直走,当左车角刚要接近道路边线方向盘回位(右一圈半)-----&amp;gt;(这时要踩低离合因为要转两圈边方向盘盘)当车盖圆盘接近道路线时方向盘(右一圈)-----&amp;gt;车身平时(左打回一圈)### 曲线行驶 直角转弯曲线行驶:倒八字走法,进曲线时先打一圈一直走然后车头跟着弯道线走，边走边转动方向盘。回拐脚处方向盘回位车头跟着弯道线走。直角转弯:车盖圆盘视角贴着边线内边缘,车盖将要盖到黄线时将方向一边打满(一圈半),车身直了回位一圈半. 长途考 长途考是广东省比较特殊的地方。权当一次短途旅行就好.大概是四人一车,每人开四十公里,沿途风景如画,速度跑起来要注意是的是方向盘微动就可以了. 我们去的是一个叫连南的县城,属于少数民族占比较多的地方,附近的小店里有瑶族的特色服装，吃了吃清远鸡,买了买茶,并没有传说中的大保健。
科目三 考试步骤倒是挺简单的,主要是细节比较多,要多练习形成肌肉反应,还有就是科目三的考场路况和路线都不尽相同,像化南和化东车辆比较少,考试毫无压力,路况对于新手来说大大增加了难度系数。科目三算是我最最悲剧的地方,居然挂在灯光上，还没起步。扭了两下灯光扭不动就跪了.
科目三考试可能有两种车型，传奇和捷达,所以考试前一般都会花一百五买钟练习一下传奇车型提升下成功率。传奇和捷达有几个地方不一样,第一是挂档可能要更向内侧用力。第二是手刹位置。第三是灯光。
下面是科目三不同考场的线路和操作摘录:
### 华观路下坡路，带刹车起步防止溜车（松一段离合，松完刹车）。一挡起步，左转下坡路（观察左方车辆），右转，最优左边第二条道（不要走第一四道），上二档，前方公交站后(变到最左边车道，在考试变更车道前变到最左边)，请变更车道(变最左)，直线通过路口（红绿灯🚥），超车（如果在最左道不用管请保持直线行驶），环岛掉头（左灯，车多换一挡注意环岛左边的车流），掉头快完成时水盖处右灯，选择左边第二条道(有点弯向右打点方向)，通过学校，通过人行道（红绿灯🚥）后（提前左灯，斑马线处开始变更左车道上二档），加减档（60时速标志处开始松油门），会车（红绿灯🚥），直线行驶，终点。### 化南绕车一圈检查（离车身30公分左右），上车准备，起步(追线右侧30公分)，（左转灯，喇叭，镜子，一挡，手刹），三秒右灯！！！，靠边停车（空挡手刹），再起步，（左转灯，喇叭，镜子，一挡，手刹），上二档，会车（左右看），加减档（先减到一挡，再升到二档，离合不要松太慢导致与提示不符），（变更右车道）右转弯，左边第二道。变更左车道（左灯，打灯反应时间五秒内），掉头（桥上减到一挡，左灯），直线行驶（匀加速到35左右，没特殊情况不减速，直线方向盘不要大幅度动），保持直线行驶，左转弯，靠边停车考试结束### 化东起步，一挡右转，右边第二条道，换二档，超车(左超)，返回原车道（只要打右灯），直行通过路口，变更左车道，前方掉头（1档），掉头后换二档，前方人行道，过路口加减档，60时速牌（没有前方加减档语音），会车，变更左车道，二档沿中线掉头（方向一圈），左边第二条道，直线行驶，变更车道（左）。靠边停车### 其他注意点&#43; 会车，人行道，学校，公交站，车速过30的话松油门，左右看&#43; 离合脚松完拿下来，油门脚不加油时脚尖松开&#43; 停车一挡起步#### 灯光两格近光，远光，跟车行驶(近光)，远光，交替灯光（远光打到近光再向上拨动），警示灯，关所有灯光(警示灯，近光灯)。灯光还要注意一点就是传奇车型和捷达的开关不一样。 科目四 科目三考完之后三天后就可以约考科目四了 科目四和科目一雷同，都是一个背题的过程。题目比科目一要少,只有50道,而题型除了单选和判断还增加了多选题。
end 8月份终于是拿到了,在广州来说算是快的,比较幸运的是这段时期新平台试运营,新平台上报考排队的人不是太多。回顾这几个月的过程,无论是练车时的专注度也好,上下班回来那么多趟也好.把一件事情完结总是有种大圆满的喜悦感。
</content>
    </entry>
    
     <entry>
        <title>xposed初探</title>
        <url>https://farwmarth.com/post/xposed%E5%88%9D%E6%8E%A2/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>xposed</tag>
        </tags>
        <content type="html"> xposed 概念 用一句话概念其牛b之处就是:可以hook到系统任意一个Java进程 官方wiki: https://github.com/rovo89/XposedBridge/wiki
 XposedInstaller，Xposed安装器,管理,下载,禁用Xposed Module,需要root权限。 Xposed，zygote的修改版.xposed实现的核心.这个zygote会替换系统原生的zygote。XposedInstaller会将它放到/system/bin目录下 XposedBridge。java部分,编译出来是一个XposedBridge.jar包,写hook模块时使用. XposedTools。帮助我们编译Xposed和XposedBridge。  xposed 原理 zygote (受精卵) http://blog.csdn.net/luoshengyang/article/details/6768304 http://www.cnblogs.com/innost/archive/2011/01/26/1945769.html 在Android系统中，所有的应用程序进程以及系统服务进程SystemServer都是由Zygote进程孕育（fork）出来的. Android系统是基于Linux内核的，而在Linux系统中，所有的进程都是init进程的子孙进程，也就是说，所有的进程都是直接或者间接地由init进程fork出来的。Zygote进程也不例外，它是在系统启动的过程，由init进程创建的。在系统启动脚本system/core/rootdir/init.rc文件中.zygote进程要执行的程序是/system/bin/app_process
 系统启动时init进程会创建Zygote进程，Zygote进程负责后续Android应用程序框架层的其它进程的创建和启动工作。 Zygote进程会首先创建一个SystemServer进程，SystemServer进程负责启动系统的关键服务，如包管理服务PackageManagerService和应用程序组件管理服务ActivityManagerService。 当我们需要启动一个Android应用程序时，ActivityManagerService会通过Socket进程间通信机制，通知Zygote进程为这个应用程序创建一个新的进程  xposed 工作原理 安装xposed框架时会把一个修改过的zygote版本安装到system/bin 中,当android系统启动时修改过的zygote在创建java虚拟机后,会调用XposedBridgeApi.jar 中的方法 来装载Xposed module .当执行一个android程序中的某一个方法 时,因为被xposed的hookMethodNative劫持,实际执行的是我们hook后的java代码.
Xposed module 创建一个Xposed module和普通的anroid应用并没有什么 区别,不一样的是要在AndroidManifest.xml 加一些特殊的元数据 meta-data
添加元数据 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt;&amp;lt;manifest xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;package=&amp;#34;com.far.xposedtest&amp;#34;android:versionCode=&amp;#34;1&amp;#34;android:versionName=&amp;#34;1.0&amp;#34; &amp;gt;&amp;lt;uses-sdk android:minSdkVersion=&amp;#34;15&amp;#34; /&amp;gt;&amp;lt;applicationandroid:icon=&amp;#34;@drawable/ic_launcher&amp;#34;android:label=&amp;#34;@string/app_name&amp;#34; &amp;gt;&amp;lt;meta-dataandroid:name=&amp;#34;xposedmodule&amp;#34;android:value=&amp;#34;true&amp;#34; /&amp;gt;&amp;lt;meta-dataandroid:name=&amp;#34;xposeddescription&amp;#34;android:value=&amp;#34;Easy example which makes the status bar clock red and adds a smiley&amp;#34; /&amp;gt;&amp;lt;meta-dataandroid:name=&amp;#34;xposedminversion&amp;#34;android:value=&amp;#34;30&amp;#34; /&amp;gt;&amp;lt;/application&amp;gt;&amp;lt;/manifest&amp;gt;实现模块接口 package de.robv.android.xposed.mods.tutorial;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;public class Tutorial implements IXposedHookLoadPackage {public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {XposedBridge.log(&amp;#34;Loaded app: &amp;#34; &#43; lpparam.packageName);}}log 定向到/data/data/de.robv.android.xposed.installer/log/debug.log .通过Xposed Installer可以读取 到查看程序log
asserts中xposed_init 入口点声明 de.robv.android.xposed.mods.tutorial.Tutorialhook a method findAndHookMethod 用于hook方法 ,在方法执行前后替换成我们的代码,官方教程是更改状态栏系统时钟的文字和颜色显示.
package de.robv.android.xposed.mods.tutorial;import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;public class Tutorial implements IXposedHookLoadPackage {public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {//判断 是不是要修改的系统UI if (!lpparam.packageName.equals(&amp;#34;com.android.systemui&amp;#34;))return;//hook这个&amp;#34;updateClock&amp;#34; 方法,修改其文字和颜色 findAndHookMethod(&amp;#34;com.android.systemui.statusbar.policy.Clock&amp;#34;, lpparam.classLoader, &amp;#34;updateClock&amp;#34;, new XC_MethodHook() {@Overrideprotected void beforeHookedMethod(MethodHookParam param) throws Throwable {// this will be called before the clock was updated by the original method }@Overrideprotected void afterHookedMethod(MethodHookParam param) throws Throwable {TextView tv = (TextView) param.thisObject;String text = tv.getText().toString();tv.setText(text &#43; &amp;#34; :)&amp;#34;);tv.setTextColor(Color.RED);}});}}Xposed 手册 XposedBridge类 log log方法用来捕获异常和打印信息,输出到标准logcat和/data/xposed/debug.log文件
hookAllMethods / hookAllConstructors hook一个类中指定名字所有的方法 或者是构造函数.要注意的是如果在一个方法调用前后去拿方法参数,可能在 一些ROM里这个方法已经被别的程序hook过了.
XposedHelpers类 在eclipse中设置 Window =&amp;gt; Preferences =&amp;gt; Java =&amp;gt; Editor =&amp;gt; Content Assist =&amp;gt; Favorites =&amp;gt; New Type,输入：de.robv.android.xposed.XposedHelpers.这样eclipse在你开始输入“get…”时会自动提示这个类中的方法。
findMethod / findConstructor / findField 这几个方法用来查找指定参数,名称的函数,构造器,和字段,而非反射方式：你可以用调用findMethodBestMatch(Class&amp;lt;?&amp;gt; clazz, String methodName, Object... args),用来匹配相近的方法.
callMethod / callStaticMethod / newInstance 利用上文提到的findXXX方法，可以用callxxx直接调用,或者用newInstance来构造 一个类实例。参数可以自动 匹配类型。如果你想明确的指定参数的类型，可以创建一个Class&amp;lt;?&amp;gt;数组，然后把它传递给callXXX/newInstance.你也可以参数数组都为null值，但是参数个数要匹配.
getXXXField / setXXXField / getStaticXXXField /setStaticXXXField 有对象引用时这几个方法都可以使用不用区分静态非静态,如果你想获得/设置一个静态字段，又没有对象的引用，你可以使用getStaticXXX和setStaticXXX方法。
getAdditionalXXXField / setAdditionalXXXField 这些方法让你将任何值与一个对象的实例或是整个类（像是一个静态字段）联系起来。这些值依照关键字-值对的方式存储。所以每个对象可以存储多个值。关键字可以是任何字符串，包括对象实际拥有的字段的名称。请注意你不能通过调用getAdditionalInstanceField获取你之前用setAdditionalStaticField存储的值。取而代之的是应该使用getAdditionalStaticField。它有一个变量来接受对象并自动查询它的类。
assetAsByteArray 这个方法以byte数组的形式返回资源。如果你想加载你模块的资源，你可以使用以下代码：
public class XposedTweakbox implements IXposedHookZygoteInit {@Overridepublic void initZygote(StartupParam startupParam) throws Throwable {Resources tweakboxRes = XModuleResources.createInstance(startupParam.modulePath, null);byte[] crtPatch = assetAsByteArray(tweakboxRes, &amp;#34;crtfix_samsung_d506192d5049a4042fb84c0265edfe42.bsdiff&amp;#34;);}}getMD5Sum 返回文件系统中一个文件的MD5值。需要读取权限
getProcessPid 按照进程的/proc/[pid]/cmdline的第一部分来寻找这个进程,并以字符串形式返回它的PID。
IXposedHookZygoteInit接口 要实现public void initZygote(StartupParam startupParam)方法,每次zygote启动时调用StartupParam存放类的路径
IXposedHookLoadPackage接口 主要hook操作,要实现public abstract void handleLoadPackage(LoadPackageParam lpparam).每次调用app的包时触发
IDE中使用Xposed 框架 所在的Xposed 模块都需要引用 Xposed 的jar,框架的公网发布地址是:https://bintray.com/rovo89/de.robv.android.xposed/api
Android Studio 在app/build.gradle配置如下:
repositories {jcenter();}dependencies {provided &amp;#39;de.robv.android.xposed:api:82&amp;#39;}使用provided 而不用compile的原因是在Android 4.x上会出现问题,使用provided只是维持引用,真正的代码在xposed框架安装时提供.
Eclipse 如果你使用的是eclipse时你可以从https://jcenter.bintray.com/de/robv/android/xposed/api/下载jar. 我建议你放到lib目录下,手动添加到库路径,而不是放到libs目录中,因为libs目录中的类eclipse会自动编译API到apk中。
API 版本 一般情况 下api版本和xposed的版本是一样的, 也尽量保持向下兼容. api 的文档地址:http://api.xposed.info/
替换资源 简单资源替换 @Overridepublic void initZygote(IXposedHookZygoteInit.StartupParam startupParam) throws Throwable {XResources.setSystemWideReplacement(&amp;#34;android&amp;#34;, &amp;#34;bool&amp;#34;, &amp;#34;config_unplugTurnsOnScreen&amp;#34;, false);}@Overridepublic void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable {// replacements only for SystemUI if (!resparam.packageName.equals(&amp;#34;com.android.systemui&amp;#34;))return;// different ways to specify the resources to be replaced resparam.res.setReplacement(0x7f080083, &amp;#34;YEAH!&amp;#34;); // WLAN toggle text. You should not do this because the id is not fixed. Only for framework resources, you could use android.R.string.something resparam.res.setReplacement(&amp;#34;com.android.systemui:string/quickpanel_bluetooth_text&amp;#34;, &amp;#34;WOO!&amp;#34;);resparam.res.setReplacement(&amp;#34;com.android.systemui&amp;#34;, &amp;#34;string&amp;#34;, &amp;#34;quickpanel_gps_text&amp;#34;, &amp;#34;HOO!&amp;#34;);resparam.res.setReplacement(&amp;#34;com.android.systemui&amp;#34;, &amp;#34;integer&amp;#34;, &amp;#34;config_maxLevelOfSignalStrengthIndicator&amp;#34;, 6);}简单的替换数据类型支持: Boolean, Color, Integer, int[], String and String[]
全局的资源替换在initZygote中调用XResources.setSystemWideReplacement(...)方法。对于特定app的资源,你需要根据包名判断之后在hookInitPackageResources中调用res.setReplacement。
替换Drawable也大同小异,便要注意的是可能一个Drawable实例被多个ImageView引用,所以要包装一个要替换的Drawable
resparam.res.setReplacement(&amp;#34;com.android.systemui&amp;#34;, &amp;#34;drawable&amp;#34;, &amp;#34;status_bar_background&amp;#34;, new XResources.DrawableLoader() {@Overridepublic Drawable newDrawable(XResources res, int id) throws Throwable {return new ColorDrawable(Color.WHITE);}});复杂的资源替换 像动画Drawables这种复杂的资源替换,必须引用到你模块中自带的资源.以替换电池图标为例,代码如下:
package de.robv.android.xposed.mods.coloredcirclebattery;import android.content.res.XModuleResources;import de.robv.android.xposed.IXposedHookInitPackageResources;import de.robv.android.xposed.IXposedHookZygoteInit;import de.robv.android.xposed.callbacks.XC_InitPackageResources.InitPackageResourcesParam;public class ColoredCircleBattery implements IXposedHookZygoteInit, IXposedHookInitPackageResources {private static String MODULE_PATH = null;@Overridepublic void initZygote(StartupParam startupParam) throws Throwable {MODULE_PATH = startupParam.modulePath;}@Overridepublic void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable {if (!resparam.packageName.equals(&amp;#34;com.android.systemui&amp;#34;))return;XModuleResources modRes = XModuleResources.createInstance(MODULE_PATH, resparam.res);resparam.res.setReplacement(&amp;#34;com.android.systemui&amp;#34;, &amp;#34;drawable&amp;#34;, &amp;#34;stat_sys_battery&amp;#34;, modRes.fwd(R.drawable.battery_icon));resparam.res.setReplacement(&amp;#34;com.android.systemui&amp;#34;, &amp;#34;drawable&amp;#34;, &amp;#34;stat_sys_battery_charge&amp;#34;, modRes.fwd(R.drawable.battery_icon_charge));}}最简单的做法就是把battery_icon.png,battery_icon_charge.png放到res/drawables目录下，当然你也可以用xml定义一个animation-list. 要做资源适配的话,你可以自己准备几套不同分辨率的资源放到res对应的目录里.
上面替换资源的做法对于常规的 app都是有效的.
修改布局 虽然上面的全局修改资源的方案是可行的,但是多个模块同时修改时还是有竞争问题，而且这样替换资源对于ROM的稳定性不太好.所以我推荐另外一种方案.就是在布局完成后去hook
@Overridepublic void handleInitPackageResources(InitPackageResourcesParam resparam) throws Throwable {if (!resparam.packageName.equals(&amp;#34;com.android.systemui&amp;#34;))return;resparam.res.hookLayout(&amp;#34;com.android.systemui&amp;#34;, &amp;#34;layout&amp;#34;, &amp;#34;status_bar&amp;#34;, new XC_LayoutInflated() {@Overridepublic void handleLayoutInflated(LayoutInflatedParam liparam) throws Throwable {TextView clock = (TextView) liparam.view.findViewById(liparam.res.getIdentifier(&amp;#34;clock&amp;#34;, &amp;#34;id&amp;#34;, &amp;#34;com.android.systemui&amp;#34;));clock.setTextColor(Color.RED);}}); }每当status_bar布局被填充后,会回调方法handleLayoutInflated,从回传的LayoutInflatedParam对象中你可以得到View对象,然后就可以对其进行修改了.
奇淫技巧 Xposed 接管系统所有广播包 findAndHookMethod(&amp;#34;com.android.server.firewall.IntentFirewall&amp;#34;,lpparam.classLoader,&amp;#34;checkBroadcast&amp;#34;,Intent.class, // intent int.class, // callerUid int.class, // callerPid String.class, // resolvedType int.class, // receivingUid new XC_MethodHook() {@Overrideprotected void beforeHookedMethod(MethodHookParam param) throws Throwable {int callerUid = (int) param.args[1];int receivingUid = (int) param.args[4];XposedBridge.log(&amp;#34;hook IntentFirewall.checkBroadcast : &amp;#34; &#43; &amp;#34;broadcast from &amp;#34; &#43; callerUid &#43; &amp;#34; to &amp;#34; &#43; receivingUid);Intent intent = (Intent) param.args[0];String action = intent.getAction();if (action == null)return;if (action.equals(&amp;#34;android.intent.action.SCREEN_OFF&amp;#34;))XposedBridge.log(&amp;#34;hook IntentFirewall.checkBroadcast : &amp;#34; &#43; &amp;#34;screen off&amp;#34;);if (action.equals(&amp;#34;android.intent.action.SCREEN_ON&amp;#34;))XposedBridge.log(&amp;#34;hook IntentFirewall.checkBroadcast : &amp;#34; &#43; &amp;#34;screen on&amp;#34;);}});嵌套hook监控前台应用 findAndHookMethod(&amp;#34;com.android.server.net.NetworkPolicyManagerService&amp;#34;,lpparam.classLoader,&amp;#34;systemReady&amp;#34;,new XC_MethodHook() {@Overrideprotected void beforeHookedMethod(MethodHookParam param) throws Throwable {XposedBridge.log(&amp;#34;hook NetworkPolicyManagerService.systemReady&amp;#34;);XposedBridge.log(&amp;#34;hook NetworkPolicyManagerService.systemReady : &amp;#34; &#43; param.thisObject.getClass());Object mProcessObserverClass = XposedHelpers.getObjectField(param.thisObject, &amp;#34;mProcessObserver&amp;#34;);XposedBridge.log(&amp;#34;hook NetworkPolicyManagerService.systemReady : &amp;#34; &#43; mProcessObserverClass.getClass());findAndHookMethod(mProcessObserverClass.getClass(),&amp;#34;onForegroundActivitiesChanged&amp;#34;,int.class, // pid int.class, // uid boolean.class, // foregroundActivities new XC_MethodHook() {@Overrideprotected void afterHookedMethod(MethodHookParam param) throws Throwable {if ((boolean) param.args[2])XposedBridge.log(&amp;#34;hook NetworkPolicyManagerService.onForegroundActivitiesChanged : foreground uid = &amp;#34; &#43; param.args[1]);}});}});xposed进程读取文件 package com.example.idhyt.xposedExtend;import android.os.Environment;import android.util.Log;import org.json.JSONException;import org.json.JSONObject;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import de.robv.android.xposed.SELinuxHelper;import de.robv.android.xposed.services.FileResult;/**** Created by idhyt on 2015/12/10.** This class is used to read file from data/data/xxx/files directory,* same as XSharedPreferences, read-only and without listeners support.*/public class XFiles {private static final String TAG = &amp;#34;XFiles&amp;#34;;private final File mFile;private final String mFilename;private ByteArrayOutputStream mFileOutputStream;private boolean mLoaded = false;private long mLastModified;private long mFileSize;/*** Read settings from the specified file.* @param file The file to read.*/public XFiles(File file) {mFile = file;mFilename = mFile.getAbsolutePath();startLoadFromDisk();}/**** @param packageName The package name.*/public XFiles(String packageName) {this(packageName, packageName &#43; &amp;#34;_files&amp;#34;);}/**** @param packageName The package name.* @param fileName The file name with suffix (.txt, .json, etc..)*/public XFiles(String packageName, String fileName) {mFile = new File(Environment.getDataDirectory(), &amp;#34;data/&amp;#34; &#43; packageName &#43; &amp;#34;/files/&amp;#34; &#43; fileName);mFilename = mFile.getAbsolutePath();startLoadFromDisk();}/*** Tries to make the files file world-readable.** This will only work if executed as root (e.g. {@code initZygote()}) and only if SELinux is disabled.** @return {@code true} in case the file could be made world-readable.*/public boolean makeWorldReadable() {if (!SELinuxHelper.getAppDataFileService().hasDirectFileAccess())return false; // It doesn&amp;#39;t make much sense to make the file readable if we wouldn&amp;#39;t be able to access it anyway.if (!mFile.exists()) // Just in case - the file should never be created if it doesn&amp;#39;t exist. return false;return mFile.setReadable(true, false);}/*** Returns the file that is backing these preferences.** &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Warning:&amp;lt;/strong&amp;gt; The file might not be accessible directly.*/public File getFile() {return mFile;}private void startLoadFromDisk() {synchronized (this) {mLoaded = false;}new Thread(&amp;#34;XFiles-load&amp;#34;) {@Overridepublic void run() {synchronized (XFiles.this) {loadFromDiskLocked();}}}.start();}@SuppressWarnings({ &amp;#34;rawtypes&amp;#34;, &amp;#34;unchecked&amp;#34; })private void loadFromDiskLocked() {if (mLoaded) {return;}ByteArrayOutputStream fileOutputStream = null;ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();FileResult fileResult = null;try {fileResult = SELinuxHelper.getAppDataFileService().getFileInputStream(mFilename, mFileSize, mLastModified);InputStream inputStream = fileResult.stream;if (inputStream != null) {int length = inputStream.available();byte [] buffer = new byte[length];int readLength;while ((readLength = inputStream.read(buffer)) != -1) {byteArrayOutputStream.write(buffer, 0, readLength);}fileOutputStream = byteArrayOutputStream;}} catch (FileNotFoundException ignored) {// SharedPreferencesImpl has a canRead() check, so it doesn&amp;#39;t log anything in case the file doesn&amp;#39;t exist } catch (IOException e) {Log.w(TAG, &amp;#34;getSharedPreferences&amp;#34;, e);} finally {if (fileResult != null &amp;amp;&amp;amp; fileResult.stream != null) {try {fileResult.stream.close();} catch (RuntimeException rethrown) {throw rethrown;} catch (Exception ignored) {}}}mLoaded = true;if (fileOutputStream != null) {mFileOutputStream = fileOutputStream;mLastModified = fileResult.mtime;mFileSize = fileResult.size;} else {mFileOutputStream = new ByteArrayOutputStream();}notifyAll();}/*** Reload the settings from file if they have changed.** &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Warning:&amp;lt;/strong&amp;gt; With enforcing SELinux, this call might be quite expensive.** @return true if execute reload;*/public synchronized boolean reload() {if (hasFileChanged()) {startLoadFromDisk();return true;}return false;}/*** Check whether the file has changed since the last time it has been loaded.** &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;Warning:&amp;lt;/strong&amp;gt; With enforcing SELinux, this call might be quite expensive.*/public synchronized boolean hasFileChanged() {try {FileResult result = SELinuxHelper.getAppDataFileService().statFile(mFilename);return mLastModified != result.mtime || mFileSize != result.size;} catch (FileNotFoundException ignored) {// SharedPreferencesImpl doesn&amp;#39;t log anything in case the file doesn&amp;#39;t exist return true;} catch (IOException e) {Log.w(TAG, &amp;#34;hasFileChanged&amp;#34;, e);return true;}}private void awaitLoadedLocked() {while (!mLoaded) {try {wait();} catch (InterruptedException unused) {}}}public String getFileContent() {synchronized (this) {awaitLoadedLocked();return mFileOutputStream.toString();}}public JSONObject getJsonFileContent() throws JSONException {return new JSONObject(getFileContent());}}###判断xposed框架是否生效
 首先我们生成一个配置文件setting.xml 定义一个函数  public void setXposedStatus(boolean bStatus) {this.getSharedPreferences(&amp;#34;setting&amp;#34;, Context.MODE_WORLD_READABLE).edit().putBoolean(&amp;#34;xposed_enabled&amp;#34;, bStatus).apply();}应用每次启动时候调用函数setXposedStatus 在xposed中hook函数setXposedStatus调用前，并将参数改为true  这样我们要想知道xposed框架是否生效可用，读取setting.xml中xposed_enabled字段值即可。
http://www.infoq.com/cn/articles/android-in-depth-xposed http://blog.idhyt.com/2015/11/28/android-injection-xposed-usage/
</content>
    </entry>
    
     <entry>
        <title>lua数据序列化的选择</title>
        <url>https://farwmarth.com/post/lua%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%80%89%E6%8B%A9/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>json</tag><tag>lua</tag>
        </tags>
        <content type="html"> 在寻找lua的json库时并没有找到太如意的方案.都是年久失修的库.
 DKJSON 2.1 http://dkolf.de/src/dkjson-lua.fsl/home Lua YAJL 2.0 https://github.com/brimworks/lua-yajl Lua CSJON 2.0.0 http://www.kyne.com.au/~mark/software/lua-cjson.php  http://www.kyne.com.au/~mark/software/lua-json-performance.html 最高选择了把cjson整合到项目 中
cjson 支持UTF-8,支持Lua-5.1&amp;ndash;Lua-5.3 http://www.kyne.com.au/~mark/software/lua-cjson-manual.html lua5.3的支持可以下载云风的修改 https://github.com/cloudwu/lua-cjson
cjon macosx的修改 #修改!!!!!!!!!!!!LUA_VERSION = 5.3TARGET = cjson.soPREFIX = /usr/local#CFLAGS = -g -Wall -pedantic -fno-inlineCFLAGS = -O3 -Wall -pedantic -DNDEBUGCJSON_CFLAGS = -fpic#修改!!!!!!!!!!!!CJSON_LDFLAGS = -bundle -undefined dynamic_lookupLUA_INCLUDE_DIR = $(PREFIX)/includeLUA_CMODULE_DIR = $(PREFIX)/lib/lua/$(LUA_VERSION)LUA_MODULE_DIR = $(PREFIX)/share/lua/$(LUA_VERSION)LUA_BIN_DIR = $(PREFIX)/bin..........##### Number conversion configuration ####### Use Libc support for number conversion (default)# FPCONV_OBJS = fpconv.o#修改!!!!!!!!!!!!FPCONV_OBJS = g_fmt.o dtoa.oCJSON_CFLAGS &#43;= -DUSE_INTERNAL_FPCONVCJSON_CFLAGS &#43;= -DIEEE_BIG_ENDIANCJSON_CFLAGS &#43;= -pthread -DMULTIPLE_THREADS cjson 基本用例  new local cjson2 = cjson.new() 创建一个cjson模块的独立副本给cjson2,可以拥有各自不同的encoding buffer和默认配置 decode 字符串转换成table  local test_str = &amp;#39;[true, {&amp;#34;foo&amp;#34;:&amp;#34;bar&amp;#34;}]&amp;#39;local test= json.decode(test_str) encode table转换成字符串  local test = {[1]=1,[3]=3}local test_str= json.encode(test) encode_sparse_array 允许稀疏数组  json.encode_sparse_array(true)local test ={ [1000] = &amp;#34;excessively sparse&amp;#34; }local test_str= json.encode(test)print(test_str) encode_max_depth 允许的最大深度 encode_invalid_numbers 编码时是否允许非法数字 infinity,NaN等,有三个选项true: 允许非法数字 false :不允许非法数字 nil:将非法数字转换成nil值 ** encode_keep_buffer** 默认为true.true表示JSON encoding buffer会一直被重用，直到JSON模块被垃圾回收为止 decode_invalid_numbers 解码是是否允许非法数字 encode_number_precision precision为1至14，默认为14用来设置JSON中数字的精度（有效位数） decode_max_depth depth为正整数，默认为1000层.为了防止溢栈，我们可以限制迭代的层数，超过指定的层数，就会报错 cjson.safe 在decode时不会立即报错,而是返回nil和一条错误信息  cjson遇到的问题 稀疏数组的问题 当索引不连续时就会造成稀疏数组问题,有两种方案可以解决
 方案一: encode_sparse_array(true),可以解决,但是设置这个选项后会发现转换的值中出现null. 比如lua中结构如下local test ={[1]=1,[3]=3}解析成json后就成了[1,null,3] ,在反序列化时得处理这个null值.  local json = require &amp;#34;cjson&amp;#34;json.encode_sparse_array(true)local test = {[1]=1,[3]=3}local test_str= json.encode(test)-- local test_str= bson.encode(test) print(test_str)local te1= json.decode(test_str)for k,v in pairs(te1) doif v== json.null thente1[k] = nilendendfor k,v in pairs(te1) doprint(k,v)end输出:
[1,null,3]1 13 3 方案二: 在json.encode()前先将稀疏数组的key转换成string,这样就不会出现这个问题了,但是同样的反序列化时要将这个string的key转换成number.  --key tostring,解决稀疏数组问题 function tableutil.map_key_tostring(maps)local stable ={}for k,v in pairs(maps or {}) dok = tostring(k) or kif type(v) == &amp;#34;table&amp;#34; thenstable[k] = tableutil.map_key_tostring(v)elsestable[k] = vendendreturn stableendfunction tableutil.map_key_tonumber(maps)local stable = {}for k,v in pairs(maps or {}) dok = tonumber(k) or kif type(v) == &amp;#34;table&amp;#34; thenstable[k] = tableutil.map_key_tonumber(v)elsestable[k] = vendendreturn stableendskynet中使用sharedata后cjson无法序列化 sharedata 的数据cjosn在encode时抛出Cannot serialise userdata: type not supported 也是两种解决方案:
 方案一: 打个patch,正常的用json_safe序列化,出异常时先深拷贝  local json = require &amp;#34;cjson&amp;#34;local json_safe = require &amp;#34;cjson.safe&amp;#34;local old_encode = json.encodelocal tableutil = require &amp;#34;public/util/tableutil&amp;#34;json.encode = function ( tab )local safe_resuslt = json_safe.encode(tab)if safe_resuslt thenreturn safe_resusltend-- print(&amp;#34;-------json is null need json_patch----&amp;#34;) local other_table = tableutil.deep_copy(tab)return old_encode(other_table)end 改写cjson,遍历 table 的时候支持 __pairs 方法  更好的选择bson http://bsonspec.org/ BSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型.目前主要用于MongoDB中 优点:
 更快的遍历速度 (它会将JSON的每一个元素的长度存在元素的头部，这样你只需要读取到元素长度就能直接seek到指定的点上进行读取了) 额外的数据类型(增加了“byte array”数据类型。这使得二进制的存储不再需要先base64转换后再存成JSON)  缺点:
 更占内存空间  对比了一下cjson和bson的encode,decode效率,bson比cjson快一倍左右.
</content>
    </entry>
    
     <entry>
        <title>redis初探</title>
        <url>https://farwmarth.com/post/redis%E5%88%9D%E6%8E%A2/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>redis</tag>
        </tags>
        <content type="html"> 安装 http://redis.io/
#安装brew install redis-server#启动redis-server#附带configredis-server /path/to/redis.conf#检查版本redis-server --version#检查是否成功redis-cliping PONG#关闭redis-cli shutdownTo have launchd start redis at login:ln -sfv /usr/local/opt/redis/*.plist ~/Library/LaunchAgentsThen to load redis now:launchctl load ~/Library/LaunchAgents/homebrew.mxcl.redis.plistOr, if you don&amp;#39;t want/need launchctl, you can just run:redis-server /usr/local/etc/redis.confubuntu 默认位置: /etc/redis/redis.conf
配置详解 http://www.cnblogs.com/tmpt/p/redis_conf_detail_annotation.html 基于这篇修改
# redis version 3.0.7# 1k =&amp;gt; 1000 bytes# 1kb =&amp;gt; 1024 bytes# 1m =&amp;gt; 1000000 bytes# 1mb =&amp;gt; 1024*1024 bytes# 1g =&amp;gt; 1000000000 bytes# 1gb =&amp;gt; 1024*1024*1024 bytes# 只用最新的，所以可以放到最后。# include /path/to/local.conf# include /path/to/other.conf################################ 通用 ###################################### 是否后台执行daemonize yes# 后台执行的pid文件# pidfile /var/run/redis.pid# 0的话，不接受TCP连接port 6379# TCP listen() backlog. 虽然listen有两个参数int listen(int s, int backlog); 但是第二个参数会被/proc/sys/net/core/somaxconn覆盖。比如nginx设置的是511，但是也会被这个覆盖成默认的128,# 所以要/etc/sysctl.conf中添加net.core.somaxconn = 2048 然后 sysctl -p ，就是说，如果软件设置大于linux配置，就是linux配置，软件设置小于linux，就用软件的，就是用最小的那个。tcp-backlog 511# 绑定IP请求来源# bind 192.168.1.100 10.0.0.1# 在空闲多少秒后关闭链接（0是禁用此功能）timeout 0# TCP keepalive# Linux内核里，下边的值以秒记，相当于tcp_keepalive_time，要用两倍的这个时间才能杀死（画外音，也就是probes*intvl=如下的值了，详见EverNote搜索“linux 在线服务器优化配置”）# 设成60比较好tcp-keepalive 0# 日志记录等级debug》verbose》notice（生产环境）》warningloglevel notice# 日志名。空字符串意味着输出到 标准输出。后台运行的redis标准输出是/dev/null。（画外音，所以要设置个文件名）logfile &amp;#34;&amp;#34;# 是否把log记到系统日志里。标示是什么？# syslog-enabled no# syslog-ident redis#设置db的数量，默认db是0，你可以用SELECT &amp;lt;dbid&amp;gt; dbid在0到下边的值-1；databases 16################################ 快照 ################################# 保存时间间隔，更新数量。如果1个key更新了，15min保存一次。10个key更新了，5分钟保存一次，10000个key更新了，每1分钟保存一次。主动调用SAVE()会阻塞所有客户端！一般是BGSAVE异步的。save 900 1save 300 10save 60 10000# 如果最后一次的后台保存RDB snapshot出错，redis就会拒绝所有写请求。这样也相当于一个报警吧。等后台保存继续工作后，redis就允许写了。# 如果你自己配置好了redis的持久化进程的监控，你可以关闭下边：stop-writes-on-bgsave-error yes# 是否压缩dump后的 .rdb 数据库？默认压缩。会省硬盘，但耗CPU。rdbcompression no# 是否校验rdb快照？CRC64校验值会放在文件尾部。会导致10%性能下降。关闭后，校验值用0填充rdbchecksum yes# DB名称dbfilename dump.rdb# 工作目录# DB会写入这个目录，以上边的名字。“仅追加文件”也会存在这个目录。注意：这里必须是目录名，不能是文件名！dir ./################################# 复制集 ################################## 主从复制。用slaveof去复制另一份redis。# 1）redis复制是异步的。但你可以让主redis拒绝写请求，当少于某个个数的从redis在线。# 2）如果复制进程暂停了一小会儿，slave可以进行重新进行部分同步，你可以设置一下复制backlog大小# 3）是自动的，无需干预。# slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;# 如果主机需要鉴权，则需要配置密码# masterauth &amp;lt;master-password&amp;gt;# 当slave和master断了，会有两种情况：# 1）默认：slave-serve-stale-data yes 这时，slave接受请求并返回老数据# 2）如果是no了，则对任何命令都返回SYNC with master in progress，INFO和SLAVEOF命令除外！slave-serve-stale-data yes# 2.6之后，redis默认slave都是read-only的，但是slave默认可以执行所有管理员命令。CONFIG,DEBUG等。你可以用rename-command去重命名危险的命令，隐藏他们。slave-read-only yes# 复制集同步策略：磁盘或者socket# 新slave连接或者老slave重新连接时候不能只接收不同，得做一个全同步。需要一个新的RDB文件dump出来，然后从master传到slave。可以有两种情况：# 1）基于硬盘（disk-backed）：master创建一个新进程dump RDB，完事儿之后由父进程（即主进程）增量传给slaves。# 2）基于socket（diskless）：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。# 基于硬盘的话，RDB文件创建后，一旦创建完毕，可以同时服务更多的slave。基于socket的话， 新slave来了后，得排队（如果超出了repl-diskless-sync-delay还没来），完事儿一个再进行下一个。# 当用diskless的时候，master等待一个repl-diskless-sync-delay的秒数，如果没slave来的话，就直接传，后来的得排队等了。否则就可以一起传。# disk较慢，并且网络较快的时候，可以用diskless。（默认用disk-based）repl-diskless-sync no# 设置成0的话，传输开始ASAPrepl-diskless-sync-delay 5# Slave发送ping给master。默认10s# repl-ping-slave-period 10# 超时时间，包括从master看slave，从slave看master，要大于上边的repl-ping-slave-period# repl-timeout 60# SYNC完毕后，在slave的socket里关闭TCP_NODELAY。# 如果是yes,reids发送少量的TCP包给slave，但可能导致最高40ms的数据延迟。# 如果是no，那可能在复制的时候，会消耗 少量带宽。# 默认我们是为了低延迟优化而设置成no，如果主从之间有很多网络跳跃。那设置成yes吧。repl-disable-tcp-nodelay no# 复制集后台backlog大小# 越大，slave可以丢失的时间就越长。# repl-backlog-size 1mb# 多久释放backlog，当确认master不再需要slave的时候，多久释放。0是永远不释放。# repl-backlog-ttl 3600# 当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。而配置成0，永远不会被选举。（必须≥0）。默认是100slave-priority 100# slave小于几个，网络lag大于几秒的时候，master停止接受write请求。默认对slave数目无限制，给0。网络延迟给10s# min-slaves-to-write 3min-slaves-max-lag 10################################## 安全 #################################### 多数情况下无需密码鉴别slave。同时，由于redis处理速度太快，所以爆破速率可达150K/S。10万/S。所以如果你要设置密码，必须设置超强的密码。# requirepass foobared &amp;lt;--这就是密码# 命令重命名# 在一个shared环境里，可以对危险的命令，比如CONFIG，进行重命名：也可以用空字符串，达到完全屏蔽此命令的目的。# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52# rename-command CONFIG &amp;#34;&amp;#34;# 记录进AOF或者传给slave的重命名操作可能会引发问题哦~。################################### 限制 ##################################### 设置最大client连接数。默认(10000)一万个。如果redis没法控制最大文件数。则给到最低32.# maxclients 10000# 如果redis用内存超过了设置的限制，第一，开始用maxmemory-policy配置的策略往外删数据，如果配置成了noeviction。所有write都会拒绝，比如set，lpush等。所有读请求可以接受。# 主要用在把redis用在LRU缓存，或者用在一个内存吃紧又不能删除的策略上。# 如果你有slave，你应该把最大内存别设置的太大，留一些系统内存给slave output buffers（如果是noeviction策略，就无需这样设置了）# maxmemory &amp;lt;bytes&amp;gt;# 内存策略。# volatile-lru -&amp;gt;用LRU删除设置了ttl的key# allkeys-lru -&amp;gt;用LRU删除任何key# volatile-random -&amp;gt;随机删除有ttl的key# allkeys-random -&amp;gt;随机删除任何key# volatile-ttl -&amp;gt;删除即将ttl到期的key# noeviction -&amp;gt;不删，有write的时候报错。# 如下操作会返回错误# set setnx setex append# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby# getset mset msetnx exec sort# 默认是# maxmemory-policy volatile-lru# LRU和最小TTL并不是最精确的，但是差不多了也。默认redis每次取3个key然后取最符合删除策略的删除。你可以配置这个数。越低，删除的东西就会越多。比如设置100个，就能删百分之一。# maxmemory-samples 3############################## AOF ################################ 默认redis异步的dump数据到disk。但如果断电了，那么就会丢失一部分数据了（根据save的配置）。# AOF提供更好模式。比如用默认的AOF，redis只丢失最近一秒的数据（断电情况），或者最后一个write操作（redis自身错误，os正常）。每个write操作写一次AOF。# 当AOF文件太大了，redis会自动重写一个aof文件出来。# AOF和RDB持久化可以同时启用。redis会优先读AOF恢复数据。# Please check http://redis.io/topics/persistence for more informationappendonly no# 默认文件名appendfilename &amp;#34;appendonly.aof&amp;#34;# fsync()三种：# no：让OS托管，这样更快。# always：每次write都刷到log，慢，最安全。# everysec：每秒一次flush。（默认）# http://antirez.com/post/redis-persistence-demystified.html# appendfsync alwaysappendfsync everysec# appendfsync no# 当fsync为always或者everysec，当一个bgsave或者AOF rewrite线程正在耗费大量I/0，redis可能会在fsync上阻塞很久。发生之后就无法fix，即使是另一个线程跑fsync，也会阻塞我们同步的write方法。# 如下方法可以解决这个问题：当bgsave()或bgrewriteaof()在跑，主进程的fsync()就无法调用。也就是当子进程在save，那段时光相当于redis是appendaof no的。也就是有可能会丢失最多30s的log。# 所以如果你有lag问题，把下边改成yes，否则就用no。yes意思是暂停aof，拒绝主进程的这次fsync。no是redis是排队的，不会被prevent了，但主进程是阻塞的。no-appendfsync-on-rewrite no# 自动重写AOF# 当AOF文件大小到一定比例，就自动隐式调用BGREWRITEAOF# 过程：redis记住最后一次rewrite时aof文件大小（重启后没rewrite的话，就是启动时AOF文件的大小），如果现在AOF大小和上次的比例达到特定值就重写。也要指定最小AOF大小，防止到2倍：1M的时候也重写。# 把percentage改成0，就是禁用重写。auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb# AOF文件可能在尾部是不完整的（上次system关闭有问题，尤其是mount ext4文件系统时没有加上data=ordered选项。只会发生在os死时，redis自己死不会不完整）。那redis重启时load进内存的时候就有问题了。# 发生的时候，可以选择redis启动报错，或者load尽量多正常的数据。# 如果aof-load-truncated是yes，会自动发布一个log给客户端然后load（默认）。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。aof-load-truncated yes################################ REDIS 集群配置 ################################打开集群节点开关才能加入到集群中# cluster-enabled yes#每个集群节点都需要一个不同的节点文件名，由节点自动维护# cluster-config-file nodes-6379.conf#节点请求超时时间单位毫秒# cluster-node-timeout 15000##并没有实质的获取从机正确数据的做法，但有两种方法来提高这种准确性## 1)如果有多个从机能够实行故障转移机制，他们会以与主机数据偏差最小的作为排名来交换数据## 2) 每个从机都记录最后一次与主机连接的时间，如果最后的连接时间太旧了就不再进行故障转移。#第二点可以由用户来配置，从机最后和主机的交互时间不能大于下面的公式：# (node-timeout * slave-validity-factor) &#43; repl-ping-slave-period##举例来说如果node-timeout设置为30s,slave-validity-factor为10,repl-ping-slave-period默认配置为10s,那么如果从机和主机最后连接时间超过310s就不会进行故障转移## 一个过大的因子设置可能会导致将从机过旧的数据同步到集群中，而过小则会导致集群中这个从机被选择到的概率变小.## 为了获得最高的可用性,可以把slave-validity-factor设置为0，这意味着这个从机节点不管和主机连接的时间，总是会进行故障转移。##零值总能保证集群可以恢复数据运行.## cluster-slave-validity-factor 10# 集群的从机可以迁移成独立的主机模式.但是这样以独立主机运行在遇到故障时无法进行故障转移。##从节点迁移成独立主机必须满足的条件是，这前的集群主机的从机数量不少于配置值,这个配置值一般是1,如果想禁止迁移模式可以将值设置为0，0值只要在调试模式下是合理的。## cluster-migration-barrier 1#当检测到没有可用的哈希槽结点宕机时,redis会集群停止所有的查询服务,但是有时候你想这个集群在其他部分节点宕掉时还可以接受查询服务,你可以设置值luster-require-full-coverage为no# cluster-require-full-coverage yes################################ LUA SCRIPTING ################################ 如果达到最大时间限制（毫秒），redis会记个log，然后返回error。# 当一个脚本超过了最大时限。只有SCRIPT KILL和SHUTDOWN NOSAVE可以用。第一个可以杀没有调write命令的东西。要是已经调用了write，只能用第二个命令杀。# 设置成0或者负值，时限就无限。lua-time-limit 5000################################## SLOW LOG #################################### 线程阻塞不能服务其他请求的时间长度。两个参数：第一个是时长（以微秒为单位！，是毫秒的千分之一。）。第二个是log的size，超过了，就会删除之前的log。# 1000000是一秒。负值是所有请求都记log！下边是0.10S。100毫秒。slowlog-log-slower-than 10000# log长度的设置值是没限制。但是需要内存。slowlog-max-len 128################################ LATENCY MONITOR ############################### 用LATENCY打印redis实例在跑命令时的耗时图表。# 只记录大于等于下边设置的值的操作。0的话，就是关闭监视。可以动态开启。直接运行CONFIG SET latency-monitor-threshold &amp;lt;milliseconds&amp;gt;latency-monitor-threshold 0############################# Event notification ############################### 可以通知pub/sub客户端关于key空间的变化。http://redis.io/topics/notifications# 比如如果开着开关。一个client进行了DEL操作在“foo”key上在database0上。两个消息将会发布通过 pub/sub# PUBLISH __keyspace@0__:foo del# PUBLISH __keyevent@0__:del foo# 大部分人不需要这个功能，并且还需要一定开销，所以默认关闭。notify-keyspace-events &amp;#34;&amp;#34;############################### ADVANCED CONFIG ################################ hash结构存储，小数据量的用数组，大数据量用map（encoding保存结构信息）hash-max-ziplist-entries 512hash-max-ziplist-value 64# list同上。list-max-ziplist-entries 512list-max-ziplist-value 64# Set在一种情况下会用特殊encoding：整个set是string组成，但是突然需要变成64位带符号整数且是10为根。。不懂。set-max-intset-entries 512# zset同setzset-max-ziplist-entries 128zset-max-ziplist-value 64# HyperLogLog 不懂。大于16000完全不可接受！当CPU很顶得住的话，给10000可以。默认给3000.hll-sparse-max-bytes 3000# Active rehashing 越多次的操作进入了正在进行rehash的table，越多的rehash步骤需要执行。如果redis是空闲的，那么rehash操作是永远没法停止的，越多的内存也被消耗了。# 默认就用yes就行 了如果你想释放内存ASAP。activerehashing yes# client output buffer限制，可以用来强制关闭传输缓慢的客户端（比如redis pub的东西有比较慢的client无法及时sub）# client-output-buffer-limit &amp;lt;class&amp;gt; &amp;lt;hard limit&amp;gt; &amp;lt;soft limit&amp;gt; &amp;lt;soft seconds&amp;gt;# class可以为以下：## normal -&amp;gt; normal clients including MONITOR clients# slave -&amp;gt; slave clients# pubsub -&amp;gt; clients subscribed to at least one pubsub channel or pattern# 当hard限制到了会立即被关闭客户端。如果soft限制到了，会等soft秒。# 比如硬限制是32m，soft是16m，10secs。到32m就立即断，或者在16m以上停止了10secs。# 设置成0就是关闭。client-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60# redis内部调度（进行关闭timeout的客户端，删除过期key等等）频率，越大则调度频率越高。设置成100以上会对CPU造成大压力除非你对线上实时性要求很高。可以在1~500之间。hz 10# 当child进程在rewrite AOF文件，如果这个选项是yes，那么这个file每32MB会写fsync()。这个是保证增量写硬盘而防止写硬盘时I/O突增。aof-rewrite-incremental-fsync yes参考手册 http://redis.readthedocs.org/en/2.4/index.html http://redisdoc.com/
key值 key值用二进制是安全的,但是太长的key值太消耗内存，太短的key值不易阅读,”object-type:id:field”可以用这种形式来标识
 del del mykey 删除给定的一个或多个 key，不存在的 key 会被忽略，返回值：被删除 key 的数量 dump dump mykey 序列化给定 key，返回被序列化的值，使用 restore 命令可以将这个值反序列化为 redis 键 exists exists mykey 检查给定 key 是否存在,返回值1或者0 expire expire mykey 60为给定key设置有效时间,单位秒  &amp;gt; set key some-valueOK&amp;gt; expire key 5(integer) 1&amp;gt; get key (immediately)&amp;#34;some-value&amp;#34;&amp;gt; get key (after some time)(nil) expireat expire mykey 1355292000  这个key将在2012.12.12过期.为给定key设置有效时间，接受时间戳timestamp keys keys *查找所有符合给定模式 pattern 的 key;keys * 匹配数据库中所有 key；keys h?llo 匹配 hello，hallo等。keys h[ae]llo匹配hello和hallo migrate 将 key 原子性地从当前实例传送到目标实例的指定数据库上,一旦传送成功, key 保证会出现在目标实例上,而当前实例上的 key 会被删除.执行的时候会阻塞进行迁移的两个实例.KEYS的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的key，你最好还是用集合(Set) move move song 1 # 将song移动到数据库1. 将当前数据库的 key 移动到给定的数据库 db当中.因为两个数据库有相同的key，MOVE失败 object 从内部察看给定 key 的 redis 对象
object命令有多个子命令：  object refcount 返回给定key引用所储存的值的次数。此命令主要用于除错。 object encoding 返回给定key锁储存的值所使用的内部表示(representation)。 object idletime 返回给定key自储存以来的空转时间(idle， 没有被读取也没有被写入)，以秒为单位。
对象可以以多种方式编码： 字符串可以被编码为raw(一般字符串)或int(用字符串表示64位数字是为了节约空间)。 列表可以被编码为ziplist或linkedlist。ziplist是为节约大小较小的列表空间而作的特殊表示。 集合可以被编码为intset或者hashtable。intset是只储存数字的小集合的特殊表示。 哈希表可以编码为zipmap或者hashtable。zipmap是小哈希表的特殊表示。 有序集合可以被编码为ziplist或者skiplist格式。ziplist用于表示小的有序集合，而skiplist则用于表示任何大小的有序集合。    redis&amp;gt; set game &amp;#34;cod&amp;#34; # 设置一个字符串okredis&amp;gt; object refcount game # 只有一个引用(integer) 1redis&amp;gt; object idletime game # 等待一阵。。。然后查看空转时间(integer) 90redis&amp;gt; get game # 提取game， 让它处于活跃(active)状态&amp;#34;cod&amp;#34;redis&amp;gt; object idletime game # 不再处于空转(integer) 0redis&amp;gt; object encoding game # 字符串的编码方式&amp;#34;raw&amp;#34;redis&amp;gt; set phone 15820123123 # 大的数字也被编码为字符串okredis&amp;gt; object encoding phone&amp;#34;raw&amp;#34;redis&amp;gt; set age 20 # 短数字被编码为intokredis&amp;gt; object encoding age&amp;#34;int&amp;#34; persist persist mykey 移除给定 key 的有效时间 pexpire pexpire mykey 1000以毫秒为单位设置 key 的有效时间 (Available since 2.6.0) pexpireat pexpireat mykey 1000以毫秒为单位设置 key 的有效时间戳(timestamp)(Available since 2.6.0) pttl pttl mykey 以毫秒为单位返回key的剩余有效时间(Available since 2.6.0) randomkey randomkey 从当前数据库中随机返回(已使用的)一个key rename rename mykey mykey1 将key改名 renamenx rename mykey newkey当且仅当 newkey 不存在时,将 key 改名为 newkey restore restore mykey反序列化给定的序列化值，并将它和给定的 key 关联 scan `` 增量迭代 Available since 2.8.0() sort sor mylist返回或保存给定列表、集合、有序集合 key 中经过排序的元素,默认会返回该列表值的递增(从小到大)排序结果 ttl ttl mykey以秒为单位，返回给定 key 的剩余有效时间 type type mykey 返回 key 所储存的值的类型 wait wait mykey 堵塞等待写操作传输到指定数量的从节点(Available since 3.0.0)  strings 就是个字符串
 append append mykey &#39;hello&#39; 将值追加到指定key的值末尾，如果key不存在，则相当于增加操作。 bitcount bitcount mykey 计算给定字符串中，被设置为 1 的Bit位的数量。redis的setbit修改的是bit位置,而bitcount检查的是byte位置，两者相差有8的倍数 bitop 对一个或多个保存二进制位的字符串 key 进行位元操作  BITOP AND destkey srckey1 srckey2 srckey3 &amp;hellip; srckeyN bittop and newkey key1 key2 BITOP OR destkey srckey1 srckey2 srckey3 &amp;hellip; srckeyN bittop or newkey key1 key2 BITOP XOR destkey srckey1 srckey2 srckey3 &amp;hellip; srckeyN bittop xor newkey key1 key2 BITOP NOT destkey srckey bittop not newkey key1    decr decr mykey 将 key 中储存的数字值减一。Key不存在，则将值置0，key类型不正确返回一个错误。 decrby decrby key 2 将key所储存的值减去指定数量,可以为负数 get get mykey 返回key所关联的字符串值，如果Key储存的值不是字符串类型，返回一个错误。 getbit getbit mykey 对key所储存的字符串值，获取指定偏移量上的位, getrange getrange mykey 0 -1 返回key中字符串值的子字符串，字符串的截取范围由start和end两个偏移量决定 getset getset mykey 2 将给定key的值设为value,并返回key的旧值.非字符串报错.和decr配合使用,主要是返回旧值,如果键不存在,那么返回nil incr incr mykey  原子递增,可以把字符串值解释成一个数字递增，因为有原子性所有多个客户端操作不会出现竞争的问题 incrby incr mykey 2将key所储存的值加上指定增量 incrbyfloat incrbyfloat mykey 2.5为key中所储存的值加上指定的浮点数增量 mget mget a b c返回所有(一个或多个)给定key的值 mset mset a 1 b 2 c 3 同时设置一个或多个key-value对 msetnx 同时设置一个或多个key-value对，若一个key已被占用，则全部的执行取消。 psetex 以毫秒为单位设置 key 的有效时间 set set mykey hello将字符串值value关联到key ,不能超过512MB setbit setbit mykey 1 1 两种状态0和1 ,每个字符有8bit对key所储存的字符串值，设置或清除指定偏移量上的位(bit) setex setex cache_user_id 60(时间秒) 10086(值) 将值value关联到 key,并设置超时时间 相当于set key value ;expire key seconds 两条命令,但这个操作是原子性的 setnx setnx mykey 1「SET if Not eXists」,当key未被使用时，设置为指定值,返回值1设置 了0 未设置 http://huoding.com/2015/09/14/463 setrange setrange mykey 1 &amp;quot;me&amp;quot; 用value参数覆写(overwrite)给定key所储存的字符串值，从偏移量 offset 开始 strlen strlen mykey返回key所储存的字符串值的长度  list 基于Linked Lists实现,头尾部添加新元素的速度快，而在索引访问数据方面牺牲了部分性能。
 blpop blpop mylist它是 lpop 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 blpop 命令阻塞，直到等待超时或发现可弹出元素为止 brpop brpop mylist与blpop同义，弹出位置不同 brpoplpush brpoplpush source destination 当列表 source 为空时， brpoplpush 命令将阻塞连接，直到等待超时 lindex lindex mylist 0返回列表 key 中，下标为 index 的元素 linsert linsert mylist before 2 0 将0插入到2之前, 将值 value 插入到列表 key 当中 llen llen mylist 返回列表 key 的长度 lpop lpop mylist移除并返回列表 key 的头元素 lpush lpush mylist 1 2将一个或多个值 value 插入到列表 key 的表头 lpushx lpushx mylist 1将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表 lrange lrange mylist 0 -1返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定 lrem lrem mylist 2(count值) hello(value值) 从头部查找移除两个hello, 根据参数 count 的值，移除列表中与参数 value 相等的元素 count 的值可以是以下几种：  count &amp;gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。 count &amp;lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。 count = 0 : 移除表中所有与 value 相等的值   lset lset mylist 1(下标) 2(值) 将列表 key 下标为 index 的元素的值设置为 value ltrim ltrim mylist 0 2对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除 rpop rpop mylist移除并返回列表 key 的尾元素 rpoplpush rpoplpush source destination 命令 rpoplpush 在一个原子时间内，执行两个动作：1、将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。2、将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。 rpush rpush mylist A B将一个或多个值 value 插入到列表 key 的表尾 rpushx rpushx mylist 1将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表  hashes 哈希表,表示对象
 hdel hdel user username删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。 hexists  hexists user name查看哈希表 key 中，给定域 field 是否存在 hget hget user username 返回哈希表 key 中给定域 field 的值 **hgetall **  hgetall user返回哈希表 key 中，所有的域和值 hincrby hincrby user age 25指定加10.为哈希表 key 中的域 field 的值加上指定增量 hincrbyfloat hincrbyfloat user age 1.5 为哈希表 key 中的域 field 加上指定的浮点数增量 hkeys hkeys user 返回哈希表 key 中的所有域 hlen hlen user 返回哈希表 key 中域的数量 hmget hmget user username birthyear no-such-field 返回哈希表 key 中, 以数组方式返回 hmset hmset user username antirez age 25 同时将多个 field-value (域-值)对设置到哈希表 key 中 hset hmset user username antirez 将哈希表 key 中的域 field 的值设为 value hsetnx hsetnx user username me当且仅当域 field 不存在时，将哈希表 key 中的域 field 的值设置为 value hvals hvals user username age返回哈希表 key 中所有域的值 hscan 增量迭代  sets 不重复的集合
 sadd sadd myset 1 2 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略  sadd myset 1 2sadd myset1 1 2 3 4 scard scard myset 返回集合 key 的集合中元素的数量 sdiff 返回一个集合的全部成员，该集合是所有给定集合之间的差集  127.0.0.1:6379&amp;gt; smembers myset1) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34;127.0.0.1:6379&amp;gt; smembers myset11) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34;3) &amp;#34;3&amp;#34;4) &amp;#34;4&amp;#34;127.0.0.1:6379&amp;gt; sdiff myset myset1(empty list or set)127.0.0.1:6379&amp;gt; sdiff myset1 myset1) &amp;#34;3&amp;#34;2) &amp;#34;4&amp;#34; sdiffstore sdiffstore destination key [key ...]这个命令的作用和 sdiff 类似，但它将结果保存到新集合，而不是简单地返回结果集 sinter sinter myset myet1 返回一个集合的全部成员，该集合是所有给定集合的交集  127.0.0.1:6379&amp;gt; sinter myset myset11) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34; sinterstore sinterstore destination key [key ...] 与sinter类似，不过可以指定保存到新集合 sismember sismember myset 1  判断 member 元素是否集合 key 的成员  127.0.0.1:6379&amp;gt; sismember myset 1(integer) 1127.0.0.1:6379&amp;gt; sismember myset 3(integer) 0 smembers smembers myset  返回集合 key 中的所有成员 smove smove source destination member将 member 元素从一个集合移动到另一个集合  127.0.0.1:6379&amp;gt; smembers myset1) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34;127.0.0.1:6379&amp;gt; smembers myset11) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34;3) &amp;#34;3&amp;#34;4) &amp;#34;4&amp;#34;127.0.0.1:6379&amp;gt; smove myset1 myset 3(integer) 1127.0.0.1:6379&amp;gt; smembers myset1) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34;3) &amp;#34;3&amp;#34;127.0.0.1:6379&amp;gt; smembers myset11) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34;3) &amp;#34;4&amp;#34; spop spop myset 移除并返回集合中的一个随机元素 srandmember srandmember myset仅仅返回随机元素，而不对集合进行任何改动，与spop的区别在于不移除 srem srem myset 1 2 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略 sunion sunion myset myset1 返回一个集合的全部成员，该集合是所有给定集合的并集  127.0.0.1:6379&amp;gt; smembers myset1) &amp;#34;3&amp;#34;127.0.0.1:6379&amp;gt; smembers myset11) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34;3) &amp;#34;4&amp;#34;127.0.0.1:6379&amp;gt; sunion myset myset11) &amp;#34;1&amp;#34;2) &amp;#34;2&amp;#34;3) &amp;#34;3&amp;#34;4) &amp;#34;4&amp;#34; sunionstore 与sunion类似，不过可以指定保存到新集合 sscan 增量迭代  sortedset (有序集合)  zadd zadd key score member [[score member] [score member] ...] 将一个或多个 member 元素及其 score 值加入到有序集 key 当中 zcard zcard key 返回有序集 key 的基数 zcount zcount key min max 返回有序集 key 中,score 值在 min 和 max 之间(包括 score 值等于 min 或 max )的成员的数量  127.0.0.1:6379&amp;gt; zadd zset 1 me(integer) 1127.0.0.1:6379&amp;gt; zcount zset 0 1(integer) 1 zincrby zincrby key increment member为有序集 key 的成员 member 的 score 值加上指定增量 zrange ZRANGE key start stop 返回有序集 key 中，指定区间内的成员(小到大排列) zrangebyscore zrangebyscore key min max 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员  redis&amp;gt; zadd salary 2500 jack # 测试数据(integer) 0redis&amp;gt; zadd salary 5000 tom(integer) 0redis&amp;gt; zadd salary 12000 peter(integer) 0redis&amp;gt; zrangebyscore salary -inf &#43;inf # 显示整个有序集1) &amp;#34;jack&amp;#34;2) &amp;#34;tom&amp;#34;3) &amp;#34;peter&amp;#34;redis&amp;gt; zrangebyscore salary -inf &#43;inf withscores # 显示整个有序集及成员的 score 值1) &amp;#34;jack&amp;#34;2) &amp;#34;2500&amp;#34;3) &amp;#34;tom&amp;#34;4) &amp;#34;5000&amp;#34;5) &amp;#34;peter&amp;#34;6) &amp;#34;12000&amp;#34; zrank zrank key member 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列 zrem zrem key member [member ...] 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略 zremrangebyrank zremrangebyrank key start stop移除有序集 key 中，指定排名(rank)区间内的所有成员  redis&amp;gt; zadd salary 2000 jack(integer) 1redis&amp;gt; zadd salary 5000 tom(integer) 1redis&amp;gt; zadd salary 3500 peter(integer) 1redis&amp;gt; zremrangebyrank salary 0 1 # 移除排名 0 至 1 区间内的成员(integer) 2redis&amp;gt; zrange salary 0 -1 withscores # 有序集只剩下一个成员1) &amp;#34;tom&amp;#34;2) &amp;#34;5000&amp;#34; zremrangebyscore 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员 zrevrange 返回有序集 key 中，指定区间内的成员，成员位置按score大到小排列 zrevrangebyscore 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。成员按 score 值递减(从大到小)&#43; 排列 zrevrank 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序 zscore 返回有序集 key 中，成员 member 的 score 值 zunionstore 计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到新集合 zinterstore 计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到新集合 zscan 增量迭代  pub/sub  psubscribe 订阅一个或多个符合给定模式的频道 publish 将信息 message 发送到指定的频道 pubsub pubsub 是一个查看订阅与发布系统状态的内省命令 punsubscribe 指示客户端退订所有给定模式 subscribe 订阅给定的一个或多个频道的信息 unsubscribe 指示客户端退订给定的频道  transaction  discard 取消事务，放弃执行事务块内的所有命令 exec 执行所有事务块内的命令 multi 标记一个事务块的开始 unwatch 取消 watch 命令对所有 key 的监视 watch 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断  scripts 命令 说明
 eval 通过内置的 lua 解释器，可以使用 eval 命令对 lua 脚本进行求值 evalsha 根据给定的 sha1 校验码，对缓存在服务器中的脚本进行求值 script exists 给定一个或多个脚本的 sha1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中 script flush 清除所有 lua 脚本缓存 script kill 停止当前正在运行的 lua &#43; 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。这个命令主要用于终止运行时间过长的脚本 script load 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本  connection  auth 通过设置配置文件中 requirepass 项的值，可以使用密码来保护 redis 服务器 echo 打印一个特定的信息 message ，测试时使用。 ping 使用客户端向 redis 服务器发送一个 ping ，如果服务器运作正常的话，会返回一个pong，通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值 quit 请求服务器关闭与当前客户端的连接 select 切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值  server  bgrewriteaof 执行一个 aof文件 重写操作。重写会创建一个当前 aof 文件的体积优化版本。 bgsave 在后台异步(asynchronously)保存当前数据库的数据到磁盘 client getname 返回 client setname 命令为连接设置的名字 client kill 关闭地址为 ip:port 的客户端 client list 以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据 client setname 为当前连接分配一个名字 config get config get 命令用于取得运行中的 redis 服务器的配置参数 config resetstat 重置 info 命令中的某些统计数据 config rewrite config rewrite 命令对启动 redis 服务器时所指定的 redis.conf 文件进行改写 config set config set 命令可以动态地调整 redis 服务器的配置而无须重启 dbsize 返回当前数据库的 key 的数量 debug object debug object 是一个调试命令，它不应被客户端所使用 debug segfault 执行一个不合法的内存访问从而让 redis 崩溃，仅在开发时用于 bug 模拟 flushall 清空整个 redis 服务器的数据(删除所有数据库的所有 key ) flushdb 清空当前数据库中的所有 key info 返回关于 redis 服务器的各种信息和统计数值 lastsave 返回最近一次 redis 成功将数据保存到磁盘上的时间，以 unix 时间戳格式表示 monitor 实时打印出 redis 服务器接收到的命令，调试用 psync 用于复制功能的内部命令 save save 命令执行一个同步保存操作，将当前 redis 实例的所有数据快照(snapshot)以 rdb 文件的形式保存到硬盘。 一般来说，在生产环境很少执行 save 操作，因为它会阻塞所有客户端，保存数据库的任务通常由 bgsave &#43; 命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时， save 可以作为保存数据的最后手段来使用。 shutdown shutdown 命令执行以下操作： 停止所有客户端如果有至少一个保存点在等待，执行 save 命令 如果 aof 选项被打开，更新 aof 文件 .关闭 redis 服务器(server) slaveof slaveof 命令用于在 redis 运行时动态地修改复制(replication)功能的行为 slowlog slow log 是 redis 用来记录查询执行时间的日志系统 sync 用于复制功能的内部命令 time 返回当前服务器时间  三条通用规则
 当添加元素到一个不存在的复合数据类型如list时，会自动创建这个列表,如lpush元素到一个不存在的列表会自动创建列表 如果删除一个空列表，会自动释放这个key 读写一个空列表总会返回相同的结果,如llen得到空列表长度为0,del空列表返回也是0  高级属性 pipeline 桌面管理器 http://docs.redisdesktop.com/en/latest/install/
## 安装桌面管理项brew cask install rdm##TODO http://fengwan.blog.51cto.com/508652/1746731 http://blog.csdn.net/dc_726/article/details/48552531 http://my.oschina.net/davehe/blog/174662
</content>
    </entry>
    
     <entry>
        <title>服务器的一次调优</title>
        <url>https://farwmarth.com/post/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%B8%80%E6%AC%A1%E8%B0%83%E4%BC%98/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>server</tag>
        </tags>
        <content type="html"> update 2016-5-12 10:32 优化结构update 2016-5-5 16:30 skynet调试历史遗留问题 这一项目的开发又接近尾声了,功能开发完毕,接下来就是运营方面的接入工作,还有就是服务器性能性的调优了. 之前服务器一直存在两个比较严重的问题,一个是加载离线玩家.另外一个则是静态数据未共享,导致的服务器启动内存过高的问题.
开发过程中,因为功能性的开发,不得不去解决这个离线玩家的问题,像好友这样的功能,不可能说离线就不能加好友. 之前一直搁置的原因是一方面是系统成型,改造的成本太高，最重要的原因还是懒 . 其实改造起来方案还是比较简单的.因为采用单模块单库的设计,在离线数据的加载上也极为方便. 玩家数据在playercenter中的结构如下:
local cache_class = class()function cache_class:ctor()self.is_online = false --是否是线 self.do_save_time = 0 --上一次存库时间 self.dirty_mark = {} --脏标cache self.player = player_factory.player_class.new()--放置角色基础数据 self.quest_list_obj = {} -- 放置任务数据 self.friend = friend_factory.player_cls.new()--好友数据 enddirty_mark是用作数据库加载标记使用,如果单模块的库被加载,dirty_mark则设置为true,内存中数据则是最新的.如好友表信息存储在friend表中, 在好友模块中如果在线玩家要加载离线玩家为好友时,只要将离线玩家的friend数据load到内存中即可,这些可以节省内存消耗 . is_online标志则是标记好友是否是正常登录,正常登录数据是完整的,各系统对其数据存取没有限制,如果is_online是false,虽说明其是离线加载数据,数据不完整,在进行业务逻辑时要区别对待.加载的离线数据设定是在内存中无修改则保持最大两小时,两小时过后,或者是玩家再次上线则会先保存离线数据,再切换到正常的登录加载完整数据过程.
静态数据的问题其实是skynet的服务设计造成的,每个服务都是一个独立的lua state. 开多个lua服务时每个服务都要加载相同的静态数据.前期数据表不大时这个问题突显不出现,运营开服的时候在单台物理机上测试开5个服过一会总有一个服会宕掉,花了一个中午没有找到具体原因,log里并没有出现报错信息.思考良久才考虑到之前出现启动内存过高的情况.一查内存占用果不其然,因为配置表在单个服务中展开将近 30M的内存.单个逻辑服启动占用内存将近800M. 战斗场景因为有各种类型,比如pvp等总共开了8个场景服务用于分流.这部分内存占用就400多M 官方的解决方案: https://github.com/cloudwu/skynet/wiki/ShareData 这个残留问题一直没有解决是因为涉及的代码太多了,大概有100个文件左右,之前每张静态表都对应 了一个对应的excel,先把静态表结构化成后端要的结构,比如公式配置表结构化类如下:
local battle_formula_excel = {}local formula_data = {}local function init()require &amp;#34;config/data/TB_formula&amp;#34; -- 公式表 for id, value in pairs(TB_formula) doformula_data[id] = value.contentend-- commonutil.print_table(formula_data) endinit()function battle_formula_excel.get_formula(id)return formula_data[id]endreturn battle_formula_excel然后battle_formula_excel这个lua文件会被各个服务引用,所以单独共享TB_formula这个静态配置表这种方案的代价实在太大,折中的办法就是将结构化后的数据如formula_data,share出来,battle_formula_excel中数据源用一个标志去从不同的地方获取,如果是数据中心服务则调用init方法来初始化这个结构化数据,如果非服务则在服务启动时将数据中心服务的数据注入进去.数据和接口分离开来 数据中心服务如下:
local sharedata = require &amp;#34;sharedata&amp;#34;local skynet = require &amp;#34;skynet&amp;#34;require &amp;#34;skynet.manager&amp;#34;local svrname, svrcount = ...local command = {}local function init_all_data()-- 静态数据配置统一操作入口 require &amp;#34;config/data/TB_formula&amp;#34;local all_excel ={{&amp;#34;battle_formula_excel&amp;#34;, &amp;#34;config/battle_formula_excel&amp;#34;},{&amp;#34;mine_excel&amp;#34;, &amp;#34;config/silvermine_excel&amp;#34;},}local all_excel_data = {}for _,config_obj in ipairs(all_excel) dolocal path_key = config_obj[1]local path =config_obj[2]local excel_obj = require (path)-- print(&amp;#34;--&amp;#34;,path,excel_obj.init_excel_data) if excel_obj.init_excel_data thenlocal result = excel_obj.init_excel_data()assert(result ~=nil,&amp;#34;返回结构化数据为空&amp;#34;..path_key )all_excel_data[path_key] =resultelseprint(&amp;#34;没有init_excel_data方法的excel&amp;#34;,path_key)endendsharedata.new(&amp;#34;all_excel_data&amp;#34;,all_excel_data)endskynet.init(function ( )--数据中心服务标志 exceldatecenter = trueinit_all_data()end)skynet.start(function()-- 接收逻辑调用协议 skynet.dispatch(&amp;#34;lua&amp;#34;, receive_lua)end)改造后的结构化excel如下:
local battle_formula_excel = {}--是否数据中心 local formula_data = {}if not exceldatecenter thenformula_data =all_excel_data.battle_formula_excel.formula_dataendlocal function init()for id, value in pairs(TB_formula) doformula_data[id] = value.contentendend-------------------供数据中心调度的接口 function battle_formula_excel.init_excel_data( )init()return {formula_data = formula_data}endfunction battle_formula_excel.get_formula(id)return formula_data[id]endreturn battle_formula_excel非数据中心服务注入结构化数据:
local sharedata = require &amp;#34;sharedata&amp;#34;local battle_formula_excel = nillocal command = {}local svr_hash_id = nillocal svrname, svrcount = ...skynet.init(function ( )--数据模块 all_excel_data =sharedata.query(&amp;#34;all_excel_data&amp;#34;)--battle_formula_excel battle_formula_excel = require &amp;#34;config/battle_formula_excel&amp;#34;end)skynet.start(function()svrcount = tonumber(svrcount)skynet.dispatch(&amp;#34;lua&amp;#34;, receive_lua)end)改造之前怕做无用功测试了几种方案.先启一个exceldatacenter服务把所有静态数据全部require进去 .再启动一个test去加载共享数据. 可以看到test服务内存不像之前一样重新加载静态数据了,为了保险起见,再开了9个test服务. 单服务没有附加静态数据内存都在几百k左右.然后就是开发漫长的苦力活了. 改造完毕,内存终于降下来了,启动内存为300M 压测调优 压测过程 中性能真是惨不忍睹,关键还是前期的为了急着完成功能,设计上也没有作过多的考虑,编码过程中也没有统一规范,review代码. 压化也是一个循序渐进的过程,出于时间排 期的考虑只能分步走.在短时间内解决压力瓶颈. 如果是消息过载可以统计消耗时间找出热点,内在泄露可以通过快照方式来定位未释放的内存.
开发机为ubuntu,在用机器人压测过程中有连接数的限制,需要更改连接数.
ubuntu too many open files 单个登录用最大文件数cat /proc/sys/fs/file-max输出最大连接数ulimit -Hn输出最大连接数ulimit -sn更改最大连接数sudo sh -c &amp;#34;ulimit -n 102400 &amp;amp;&amp;amp; exec su $LOGNAME&amp;#34;ulimit -n unlimitedskynet 调试台使用 https://github.com/cloudwu/skynet/wiki/DebugConsole 常用的针对所有 lua 服务的指令有：
 clearcache 清除多个lua虚拟机共享的代码 cmem 显示c层hook的内存 debug 针对一个 lua 服务启动内置的单步调试器。http://blog.codingnow.com/2015/02/skynet_debugger.html exit 让一个 lua 服务退出 gc 强制让所有 lua 服务都执行一次垃圾回收，并报告回收后的内存 help 显示帮助 info 让一个 lua 服务汇报自己的内部信息 获取服务内部数据 - info address  local skynet = require &amp;#34;skynet&amp;#34;require &amp;#34;skynet.manager&amp;#34; -- import skynet.register local db = {}local command = {}function command.GET(key)return db[key]endfunction command.SET(key, value)local last = db[key]db[key] = valuereturn lastend-- 新增的代码 -- start skynet.info_func(function() return &amp;#34;hello world!&amp;#34; end)-- 新增的代码 -- end skynet.start(function()skynet.dispatch(&amp;#34;lua&amp;#34;, function(session, address, cmd, ...)local f = command[string.upper(cmd)]if f thenskynet.ret(skynet.pack(f(...)))elseerror(string.format(&amp;#34;Unknown command %s&amp;#34;, tostring(cmd)))endend)skynet.register &amp;#34;SIMPLEDB&amp;#34;end)$ telnet 127.0.0.1 9000Welcome to skynet consolelist:0000000d snlua simpledbOKinfo :0000000dhello world inject 将 script 名字对应的脚本插入到指定服务中运行（通常可用于热更新补丁[ inject address luascript.lua] kill 强制中止一个 lua 服务 list 列出所有服务，以及启动服务的命令参数 log 带log启动一个lua服务 logoff 关闭日志记录一个服务所有的输入消息到文件。需要在 Config 里配置 logpath logon 对一个服务打开日志 mem 让所有 lua 服务汇报自己占用的内存 service 列出所有的唯一 lua 服务 shrtbl Show shared short string table info signal address sig 向服务发送一个信号，sig 默认为 0 。当一个服务陷入死循环时，默认信号会打断正在执行的 lua 字节码，并抛出 error 显示调用栈。这是针对 endless loop 的 log 的有效调试方法。注：这里的信号并非系统信号 snax lanuch a new snax service start 启动一个lua服务 stat 列出所有 lua 服务的消息队列长度，以及被挂起的请求数量 task 显示一个服务中所有被挂起的请求的调用栈。  数据库优化  数据脏标 定时保存数据的弊端带来的工作就是,当数据变脏时要设置 数据为脏,会减少很多写库的io. 数据队列 脏标在一定程度上可以减少很多io,但是同时在线人数过多,操作频繁时数据的写io还是很多.所以存库一般放在独立的线程中.还有一个设想就是根据玩家的等级和vip和数据的保存次数确定权重,在服务器压力过大时先保存重要级的玩家数据.在空闲时段再去保存次要的玩家数据,这样就算异常情况数据丢失损失也不会太大.当然存库时单玩家的数据必须是完整的. 内存数据库 后期考虑把非线性增长的玩家数据用redis来替代,在监测mysql登录玩家上线时加载数据需要2s左右,如果换成redis应该会有很多改观. ,redis当缓存 定时线程写入mysql 直接存json .表结构不改直接存json.必须注意字节长度我们曾经有字节长度不足的问题  服务过载  避免单点服务 逻辑过多的单点服务往往会成为性能热点,导致消息过载,除了watchdog和一些交互不频繁的服务外可以服务多开让线程驱动. skynet.mqlen() 当前服务的消息队列 skynet.task(ret) 当前服务挂起的待处理的call任务  内存泄露  调试台mem查看lua服务占用 cmemory.lua 统计c内存占用 &amp;lt;: https://github.com/cloudwu/skynet/wiki/MemoryHook&amp;gt; snapshot https://github.com/cloudwu/lua-snapshot 从_G查找表  local findedObjMap = nilfunction _G.findObject(obj, findDest)if findDest == nil thenreturn falseendif findedObjMap[findDest] ~= nil thenreturn falseendfindedObjMap[findDest] = truelocal destType = type(findDest)if destType == &amp;#34;table&amp;#34; thenif findDest == _G.CMemoryDebug thenreturn falseendfor key, value in pairs(findDest) doif key == obj or value == obj then_info(&amp;#34;Finded Object&amp;#34;)return trueendif findObject(obj, key) == true then_info(&amp;#34;table key&amp;#34;)return trueendif findObject(obj, value) == true then_info(&amp;#34;key:[&amp;#34;..tostring(key)..&amp;#34;]&amp;#34;)return trueendendelseif destType == &amp;#34;function&amp;#34; thenlocal uvIndex = 1while true dolocal name, value = debug.getupvalue(findDest, uvIndex)if name == nil thenbreakendif findObject(obj, value) == true then_info(&amp;#34;upvalue name:[&amp;#34;..tostring(name)..&amp;#34;]&amp;#34;)return trueenduvIndex = uvIndex &#43; 1endendreturn falseendfunction _G.findObjectInGlobal(obj)findedObjMap = {}setmetatable(findedObjMap, {__mode = &amp;#34;k&amp;#34;})_G.findObject(obj, _G)end减少登录流量  合并协议 像红点提示这种可能分部在各系统中发送,这些协议号重复但功能代码分步在各个系统中的协议可以在模块中预留接口来获取提示结果再打包发送. 减少登录时的推送数据 登录时可只推送玩家的基础角色信息,和一些必要的提示数据,其他数据可以选择延迟初始化的方式,在玩家打开客户端界面再请求数据. 数据分页 这是web中最常见的方式,数据量过大时,分成多页,好友,排行榜这种数据量大的请求可以使用分页来做优化  设计问题 原有核心服务结构  watchdog :维护全护玩家的登录登出 role :创建角色 auth :第三方sdk验证 agent : 玩家服务,中转数据 playercenter : 玩家数据中心 scene : 场景服务(城镇场景根据人流分服,单人副本,其他特殊战斗场景)  watchdog(单个) &amp;mdash;-&amp;gt;role(多个) : 创建角色 watchdog(单个) &amp;mdash;-&amp;gt;auth(多个) : 账号验证,创建账号 watchdog (单个)&amp;mdash;&amp;gt; agent(对应玩家数量) &amp;mdash;&amp;mdash;&amp;gt;playercenter(多个) : 验证成功后,创建agent线程,个人数据加载到 playercenter中. watchdog (单个)&amp;mdash;&amp;gt; agent(对应玩家数量) &amp;mdash;&amp;mdash;&amp;gt;scene(多个) : 登录加载数据后客户端可进入对应的场景服务.
优化登录登出过程 之前的设计因为在服务器做流失统计,把登录过程细化成一个很长的过程.这就导致各服务间的交互过于频繁.
client连接socket,发送auth数据&amp;mdash;-&amp;gt;[watchdog]请求auth&amp;mdash;-&amp;gt;[auth]连接python服务与sdk第三方校验token&amp;mdash;&amp;mdash;&amp;gt;[watchdog]返回auth结果&amp;mdash;-&amp;gt;client登录&amp;mdash;-&amp;gt;[watchdog]检查排队重复登录&amp;mdash;&amp;ndash;&amp;gt;client获取角色列表&amp;mdash;&amp;ndash;&amp;gt;[watchdog]请求role得到角色列表&amp;mdash;&amp;gt;[role]获取角色列表&amp;mdash;-&amp;gt;client如果角色个数不为0请求进入游戏&amp;mdash;&amp;ndash;&amp;gt;[watchdog]创建[agent]&amp;mdash;-&amp;gt;[agent]实始化成功返回[watchdog]&amp;mdash;-&amp;gt;[watchdog]通知[agent]加载数据&amp;mdash;&amp;gt;[agent]通知[playercenter]加载数据&amp;mdash;-&amp;gt;成功后推送数据让客户端进入[scene]
开启[auth]服务的初衷是要异步与后台的python服务交互,其实auth完全没必要通过游戏服务器中转,优化后的过程如下:client通过sdk登录得到token等信息&amp;mdash;&amp;mdash;-&amp;gt;连接python服务校验生成加密串&amp;mdash;-&amp;gt;client连接gameserver发送python的加密串&amp;mdash;&amp;ndash;&amp;gt;gameserver验证串与时间有效性&amp;mdash;-&amp;gt;走之前的登录过程,优化后的[auth]服务可以合并到[role]中,优化后[watchdog] 与[role],[agent]只要交互一次就可以完全登录操作.
优化log,道具流水,货币流水 道具和流水消息过多,导致log服务在一直写库,消息过载.
 减少日志生成条数 打包多条日志,在10条日志数据时候再调度log服务 优化插入速度:事务,索引,批量插入(1000条插入一次),合并insert语句(多条日志一条insert)  优化退出处理 退出数据不立即落地,保存一段时间.
日志大小处理 logrotate copytruncate参考链接:
 http://blog.codingnow.com/2015/01/skynet_netpack.html http://blog.codingnow.com/2013/06/skynet_watchdog.html http://blog.codingnow.com/2013/12/skynet_agent_pool.html http://blog.codingnow.com/2014/10/skynet_overload.html http://blog.codingnow.com/2012/09/the_design_of_skynet.html </content>
    </entry>
    
     <entry>
        <title>Gradle 打包</title>
        <url>https://farwmarth.com/post/gradle/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>gradle</tag>
        </tags>
        <content type="html"> 什么是Gradle？ Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言
安装Gradle Android Studio 默认下载目录,如果下载太慢可以手动从官网下载放到对应目录
 Mac: /Users/&amp;lt;用户名&amp;gt;/.gradle/wrapper/dists** 目录 Win: C:\Documents and Settings&amp;lt;用户名&amp;gt;.gradle\wrapper\dists 目录  项目相关文件 gradle配置文件有模块和工程配置,大概结构如下:
local.properties : sdk目录
sdk.dir=E\:\\tools\\adt-bundle-windows-x86-20140702\\adt-bundle-windows-x86-20140702\\sdkgradle.properties : 变量
systemProp.http.proxyHost=127.0.0.1systemProp.http.proxyPort=16823systemProp.https.proxyHost=127.0.0.1systemProp.https.proxyPort=16823settings.gradle
--包含要编译的moduleinclude &amp;#39;:libs:StickyHeadersRecyclerView&amp;#39;, &amp;#39;:&amp;#39;include &amp;#39;:&amp;#39;build.gradle http://developer.android.com/intl/zh-cn/tools/building/configuring-gradle.html
//添加插件:声明为android程序apply plugin: &amp;#39;com.android.application&amp;#39;//脚本本身依赖的库和配置buildscript {//代码库 repositories {mavenCentral()jcenter()}dependencies {classpath &amp;#39;com.android.tools.build:gradle:1.5.0&amp;#39; //依赖gradle版本 }}//所有工程统一配置allprojects {repositories {maven { url &amp;#34;https://jitpack.io&amp;#34; }}}repositories {mavenCentral()jcenter()maven { url &amp;#34;https://jitpack.io&amp;#34; }}//android部分配置android {//编译sdk版本 compileSdkVersion 23//打包工具版本 buildToolsVersion &amp;#39;23.0.2&amp;#39;//打包选项 packagingOptions {//排除 exclude &amp;#39;proguard-project.txt&amp;#39;exclude &amp;#39;project.properties&amp;#39;}//默认配置 defaultConfig {//包名 applicationId &amp;#34;com.amaze.filemanager&amp;#34;//最低支持sdk版本 minSdkVersion 14//目标sdk版本 targetSdkVersion 23//版本号 versionCode 36//版本字符串 versionName &amp;#34;3.0.2 &amp;#34;}//签名配置 signingConfigs {release{storeFile file(×.keystore)storePassword ×××keyAlias ××××keyPassword ×××}}//编译类型 buildTypes {//正式版 release {signingConfig signingConfigs.release--是否混淆minifyEnabled true--proguard文件proguardFiles getDefaultProguardFile(&amp;#39;proguard-android.txt&amp;#39;), &amp;#39;proguard-rules.pro&amp;#39;}}// Java 的版本配置 compileOptions {sourceCompatibility JavaVersion.VERSION_1_7targetCompatibility JavaVersion.VERSION_1_7}//lint检查 lintOptions {abortOnError false}//源目录设置 sourceSets {main {assets.srcDirs = [&amp;#39;assets&amp;#39;]}// Move the tests to tests/java, tests/res, etc... instrumentTest.setRoot(&amp;#39;tests&amp;#39;)debug.setRoot(&amp;#39;build-types/debug&amp;#39;)release.setRoot(&amp;#39;build-types/release&amp;#39;)}//不同版本打包 productFlavors {fdroid {buildConfigField &amp;#34;boolean&amp;#34;, &amp;#34;IS_VERSION_FDROID&amp;#34;, &amp;#34;true&amp;#34;packageName=&amp;#39;com.example.application1&amp;#39;manifest.srcFile &amp;#39;exampleapk/AndroidManifest1.xml&amp;#39;}play {buildConfigField &amp;#34;boolean&amp;#34;, &amp;#34;IS_VERSION_FDROID&amp;#34;, &amp;#34;false&amp;#34;signingConfig signingConfigs.config}}}//包依赖dependencies {//依赖其他工程 compile project(&amp;#34;:lib&amp;#34;)// 远程包 compile &amp;#39;com.android.support:appcompat-v7:19.0.1&amp;#39;//本地jar包 compile fileTree(dir: &amp;#39;libs&amp;#39;, include: [&amp;#39;*.jar&amp;#39;])}def Properties props = new Properties()def propFile = new File(&amp;#39;signing.properties&amp;#39;)if (propFile.canRead()) {props.load(new FileInputStream(propFile))if (props != null &amp;amp;&amp;amp;props.containsKey(&amp;#39;STORE_FILE&amp;#39;) &amp;amp;&amp;amp;props.containsKey(&amp;#39;STORE_PASSWORD&amp;#39;) &amp;amp;&amp;amp;props.containsKey(&amp;#39;KEY_ALIAS&amp;#39;) &amp;amp;&amp;amp;props.containsKey(&amp;#39;KEY_PASSWORD&amp;#39;)) {android.signingConfigs.release.storeFile = file(props[&amp;#39;STORE_FILE&amp;#39;])android.signingConfigs.release.storePassword = props[&amp;#39;STORE_PASSWORD&amp;#39;]android.signingConfigs.release.keyAlias = props[&amp;#39;KEY_ALIAS&amp;#39;]android.signingConfigs.release.keyPassword = props[&amp;#39;KEY_PASSWORD&amp;#39;]} else {println &amp;#39;signing.properties found but some entries are missing&amp;#39;android.buildTypes.release.signingConfig = null}} else {println &amp;#39;signing.properties not found&amp;#39;android.buildTypes.release.signingConfig = null}tips 国内仓库 修改项目根目录下的build.gradle，将jcenter()或者mavenCentral()替换掉即可：
allprojects {repositories {maven{ url &amp;#39;http://maven.oschina.net/content/groups/public/&amp;#39;}}}全局配置:USER_HOME/.gradle/init.gradle
allprojects{repositories {def REPOSITORY_URL = &amp;#39;http://maven.oschina.net/content/groups/public&amp;#39;all { ArtifactRepository repo -&amp;gt;if(repo instanceof MavenArtifactRepository){def url = repo.url.toString()if (url.startsWith(&amp;#39;https://repo1.maven.org/maven2&amp;#39;) || url.startsWith(&amp;#39;https://jcenter.bintray.com/&amp;#39;)) {project.logger.lifecycle &amp;#34;Repository ${repo.url} replaced by $REPOSITORY_URL.&amp;#34;remove repo}}}maven {url REPOSITORY_URL}}}</content>
    </entry>
    
     <entry>
        <title>mysql 备忘录</title>
        <url>https://farwmarth.com/post/mysql%E5%A4%87%E5%BF%98/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>mysql</tag>
        </tags>
        <content type="html"> 基础  安装 mysql  #serversudo apt-get install mysql-server#server devsudo apt-get install libmysqld-dev#clientsudo apt-get install mysql-client#client devsudo apt-get install libmysqlclient-dev 删除mysql:  sudo apt-get autoremove --purge mysql-server-5.0sudo apt-get remove mysql-serversudo apt-get autoremove mysql-serversudo apt-get remove mysql-common (非常重要)dpkg -l |grep ^rc|awk &amp;#39;{print $2}&amp;#39; |sudo xargs dpkg -P 检测是否安装成功  sudo netstat -tap | grep mysql 开启关闭:  service mysqld startsudo /etc/init.d/mysql startsudo start mysql 加到开机列表:  chkconfig -add mysqld 创建root管理员：  mysqladmin -u root password 12345678 忘记密码：  service mysqld stopmysqld_safe --user=root --skip-grant-tablesmysql -u rootuse mysqlupdate user set password=password(&amp;#34;new_pass&amp;#34;) where user=&amp;#34;root&amp;#34;;flush privileges; 为root添加远程连接的能力：  GRANT ALL PRIVILEGES ON *.* TO root@&amp;#34;%&amp;#34; IDENTIFIED BY &amp;#34;root&amp;#34;;use mysql;update user set Password = password(&amp;#39;12345678&amp;#39;) where User=&amp;#39;root&amp;#39;;#mysql5.7#update user set authentication_string = password(&amp;#39;12345678&amp;#39;) where User=&amp;#39;root&amp;#39;;flush privileges;select host,user,password from user;#select host,user,authentication_string from user;修改 Mysql 配置文件 sudo vi /etc/mysql/my.cnf注释#bind-address = 127.0.0.1重启sudo /etc/init.d/mysql restart mysql pid 找不到  cd /var/runls -l mysqld*#ls: mysqld*: No such file or directory#创建该目录，并将其权限赋给mysql用户mkdir mysqldchown -R mysql:mysql /var/run/mysqld mysql重置  /usr/local/mysql/scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/var/lib/mysql --pid-file=/var/run/mysqld/mysqld.pid --tmpdir=/tmp 字符集utf-8:  [client]default-character-set=utf8 #增加这一行，指定字符集port = 3306socket = /var/run/mysqld/mysqld.sock[mysqld]character-set-server=utf8#增加这一行，指定字符集user = mysqlpid-file = /var/run/mysqld/mysqld.pidshow variables like &amp;#39;%char%&amp;#39; ;#更改前存在的用户字符集不会改变，以后新建的用户字符集都变成了UTF-8重启服务，字符集就成了UTF-8配置 [client]default-character-set=utf8port = 3306socket = /tmp/mysql.sock[mysqld]## 基本配置user = mysqlport = 3306socket = /tmp/mysql.sockcharacter-set-server = utf8replicate-ignore-db = mysqlreplicate-ignore-db = testreplicate-ignore-db = information_schemabasedir = /data/mysqldatadir = /data/mysql/datapid-file = /data/mysql/mysql.pidlog-error = /data/mysql/mysql.error.log#log = /data/mysql/mysql.exec.logback_log = 600#最大连接数max_connections = 8000max_connect_errors = 6000open_files_limit = 10240table_open_cache = 2048external-locking = FALSEmax_allowed_packet = 32Msort_buffer_size = 16Mjoin_buffer_size = 16Mthread_cache_size = 300#thread_concurrency = 24query_cache_size = 512Mquery_cache_limit = 2Mquery_cache_min_res_unit = 2kdefault-storage-engine = MyISAMthread_stack = 192K#transaction_isolation = READ-COMMITTEDtmp_table_size = 512Mskip-name-resolveinteractive_timeout = 86400wait_timeout = 86400## 慢查询(5.5与5.6之间有差异)#5.5版本#long_query_time = 10#log-slow-queries = /data/mysql/slow.query.log#5.6版本long_query_time = 10slow_query_log = 1log_queries_not_using_indexes = 1slow_query_log_file = /data/mysql/slow.query.log## 二进制日志binlog_format = MIXEDexpire_logs_days = 4max_binlog_size = 1Gbinlog_cache_size = 4Mmax_binlog_cache_size = 10Glog-bin = /data/mysql/binlog/binlog## 主从同步server-id = 1#master-host = 192.168.1.2#master-user = username#master-password = password#master-port = 3306#master-connect-retry = 10#slave-skip-errors = 1032,1062,126,1114,1146,1048,1396relay-log-index = /data/mysql/relaylog/relaylogrelay-log-info-file = /data/mysql/relaylog/relaylogrelay-log = /data/mysql/relaylog/relaylog## MYISAM相关选项key_buffer_size = 256Mread_buffer_size = 2Mread_rnd_buffer_size = 64Mmax_heap_table_size = 246Mbulk_insert_buffer_size = 64Mmyisam_sort_buffer_size = 8Mmyisam_max_sort_file_size = 10Gmyisam_repair_threads = 1myisam-recover-options## INNODB相关选项#innodb_additional_mem_pool_size = 16M #(5.6中不再推荐使用)innodb_buffer_pool_size = 512Minnodb_data_file_path = ibdata1:256M:autoextendinnodb_file_io_threads = 4innodb_thread_concurrency = 8innodb_flush_log_at_trx_commit = 2innodb_log_buffer_size = 16Minnodb_log_file_size = 128Minnodb_log_files_in_group = 3innodb_max_dirty_pages_pct = 90innodb_lock_wait_timeout = 120innodb_file_format = Barracudainnodb_strict_mode = 1innodb_file_per_table = 1[mysqldump]quickmax_allowed_packet = 32Msql  #Mysql 查询所有表的行数和大小  SELECT TABLE_NAME,TABLE_ROWS,DATA_LENGTH/1024/1024 &amp;#34;DATA_LENGTH&amp;#34;,CREATE_TIME,TABLE_COLLATION FROMINFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = &amp;#39;hj_game_stat_lyx_s&amp;#39; ORDER BY TABLE_ROWS DESC问题 mysql has gone away   先查看日志是否有错误,是否mysql是否宕掉了 /data/mysql/mysql.error.log
  show status; 或者 show status like &amp;lsquo;%uptime&amp;rsquo;;,看mysql运行时长
     Variable_name Value Desc     Aborted_clients 575 由于客户端没有正确关闭连接导致客户端终止而中断的连接数   Aborted_connects 12 试图连接到MySQL服务器而失败的连接数   Threads_cached 45 线程缓存内的线程的数量   Threads_connected 6 当前打开的连接的数量   Threads_created 51 创建用来处理连接的线程数,如果Threads_created较大,你可能要增加thread_cache_size值。缓存访问率的计算方法Threads_created/Connections   Threads_running 2 激活的（非睡眠状态）线程数   Uptime 1155442 服务器已经运行的时间（以秒为单位）   Uptime_since_flush_status 1155442 最近一次使用FLUSH STATUS 的时间(以秒为单位)     show global variables like &amp;lsquo;%timeout&amp;rsquo;; 查看设置 的超时时间 | Variable_name | Value | Desc | | &amp;mdash; |:&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;:|:&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;:| | connect_timeout | 10 | | delayed_insert_timeout | 300 | | innodb_flush_log_at_timeout | 1 | | innodb_lock_wait_timeout | 7200 | | innodb_rollback_on_timeout | OFF | | interactive_timeout | 3600 | 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端| | lock_wait_timeout | 31536000 | | net_read_timeout | 30 | | net_write_timeout | 60 | | rpl_stop_slave_timeout | 31536000 | | slave_net_timeout | 3600 | | wait_timeout | 3600 | 服务器关闭非交互连接之前等待活动的秒数|  如果是wait_timeout时间过短,可以设置时间
set global wait_timeout=28800;set global interactive_timeout=28800;程序方面可以在出现这个问题后作一样重连数据库再执行sql.
 查看连接数,状态 SHOW PROCESSLIST; SHOW GLOBAL STATUS LIKE &amp;lsquo;aborted_connects&amp;rsquo;; SHOW GLOBAL VARIABLES LIKE &amp;lsquo;max_connections&amp;rsquo;; SHOW GLOBAL STATUS LIKE &amp;lsquo;max_used_connections&amp;rsquo;; show table status ; 显示table状态  MySQL无法重启问题解决 Warning: World-writable config file ‘/etc/my.cnf’ is ignoredls -l /etc/my.cnfchmod 644 /etc/my.cnfWarning: Changing a readonly file sudo vi /etc/exports查看mysql 端口tcp数据 tcpdump -s 1500 -w tcp.out port 3306tailf tcp.out|grep strings设置sql模式 SET GLOBAL sql_mode=&#39;&#39;
mysql_config not found ln -s /usr/local/mysql/bin/mysql_config /usr/local/bin/mysql_config备份 mysqldump -hhostname -uusername -ppassword –databases databasename1 databasename2 databasename3 &amp;gt; multibackupfile.sql</content>
    </entry>
    
     <entry>
        <title>倒戈又如何</title>
        <url>https://farwmarth.com/post/%E5%80%92%E6%88%88%E5%8F%88%E5%A6%82%E4%BD%95/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>startup</tag>
        </tags>
        <content type="html"> 倒戈 七月底的时候，开发了一年的游戏最终还是倒戈了,技术团队以整队收编的方式到了现在这家公司. 掰着脚趾头数一数,失败的项目快凑成一打了. 反观这几年这些项目.只能说成功的游戏都是一个模样,赚得盆满钵满.失败的原因却各不相同.
初期团队组建时核心人员不齐 在做第二款格斗游戏的时候就处于这种状态,刚从上一款格斗游戏的阴影里走出来,服务端全体离职,没有主策划和主美.当时立项的时候其实已经有统一的意见,先确定好主策和主美这两个职位,结果一拖再拖,抱着边开发边招人的心态.我也被赶鸭子上架地开始了游戏服务器开发. 直接把其他工作室的前后端移植过来.基础系统完备.整体思路就是改造游戏,揉合自己的风格.初期开发并未觉得有何不妥,开发中期核心人员不齐问题逐渐凸显.游戏做成一个没有层次的杂交体. 无主策,之前任职的几个经验不足的核心策划显然无法胜利这个工作,只能掌握好片面的计划,全然没有高屋建瓴的气势. 无主美,美术的工作也是疏于管理,然后把UI,动作外包.外包必然增加了沟通的成本,品控和时间周期也无法把控.最终的结果可想而知,游戏做出来,草草上线,运营了大概一个多月就见光死.品质上不去,渠道不肯导量,公司的核心关注点必然不在我们身上.
管理层决策性错误 公司高层决策其实对于下层来说是件很无奈的事情.刚入行游戏业被分到的一个儿童游戏工作室,游戏运营了几个月,终于处于出支平衡的状态.还没有站稳脚根. 项目负责人就贸然地独立成子公司. 之前工作室的模式其实是这样的:项目负责人有一个demo或者是有一个很不错的idea,然后通过熟人联络到大boss,然后大boss以投资的形式来负担这个idea的运营成本,项目负责人各种招兵买马,研发,上线,这个开发成本的账目 就记录在整个工作室上,游戏上线赢利然后来偿还这个成本,除此之外还要和老总分成.单方面猜测是因为管理者觉得游戏稍有起色想谋取更大的私利. 运营阶段刚开始是在4399平台,刚独立就开始扩张,准备新渠道接入,还筹备繁体版本,人手不变的情况下只能压缩每周活动,之前是每周都会添加新玩法和新宠物,正是这些更新点能够吸引住儿童玩家.每周玩法减少之后玩家势必也热情褪去.多渠道发行之后,因为处于敌对状态,分量单渠道的玩家峰值下来,而新上的平台付费率又低,导致了先有点起色的游戏又处于摇摇欲坠的状况. 最后的结果是又被总公司给收编回去,游戏被4399收购. 如果先稳住阵脚也许现在又是另一番结果.当然这可能只是事后诸葛亮的说辞而已.
与市场脱节,错过最佳上线时期 当初立项开始第一款格斗类型游戏时,市面上出现同类型比较火热的只有&amp;laquo;时空猎人&amp;raquo;.按预期开发如果正常上线的话,市场份额还是比较大的.然而因为处在页游选手游的过渡阶段,技术选型错误导致开发半年的游戏推翻重新开发,还有各种不可抗拒因素.上线时格斗市场已然是一片红海。&amp;laquo;格斗江湖&amp;raquo;，&amp;laquo;影之刃&amp;raquo;等等格斗游戏如雨后春笋一般冒了出来。
游戏侧重点失误 这可能是这几年做游戏以来所有项目的通病了。立项初期策划秉行的是:迅速做大而全的项目.等系统完备之后再来精雕细琢.这样的做法是时间成本太高了。忙活大半年虽然囫囵吞枣地把各个系统基础功能完成了。可想而知在细节和交互感上得不到一个很好的成果。然后匆忙地给渠道评级或者放在市场上用户反馈的结果是.游戏过于粗糙,画面不细腻,没有吸引点. 运营提出一个解决方案,如果是从立项开始的话研发关注点应该如下：
 demo版本:核心战斗部分,迅速完成一个相当于美术的素描版本。 前十分钟内容:先关注前十分钟,从loading界面到登录，创建角色，选择角色，新手引导，主场景，关卡界面，最通用的UI界面，第一场战斗的进化版本。着重在前十分钟来打动玩家。不管从美术风格也好，还是让程序用代码实现更加平滑的交互也好，先打磨前期内容。 后期版本:先把前期精雕后的版本做评级或者放市场上看反馈信息.后期再把系统链接起来,做长期培养。  团队契合度,参与度不够 回顾几年的游戏开发过程,最有参与感和成长性的还是刚工作的时候的儿童游戏项目里。虽然也有不少诟病的地方，但那种融洽度应该是经历中最好的。不论是程序，策划，还是美术都处在一种积极沟通的状态。起码每个部门里大多数都能叫出名字.不像现在策划和程序的交集止于工作，一起项目聚餐都有一种各玩手机掩饰尴尬的感觉。 如果说只是氛围问题的话还不是太严重,毕竟:work is work. 在儿童游戏项目里,因为每周都有更新新的玩法和活动.会加入各种小游戏。这种开发有点像短期的单机游戏一样。一个大型游戏里入驻很多轻型的益智游戏。编码开发起来也比较感兴趣。每周更新阶段大家都会参与进来竞赛。就会营造一种这个功能不是一坨没人玩的shit的感觉. 后面自己开发的游中戏除了格斗的核心战斗之外,其他系统再无兴趣。模式千篇一律.再也没有那种加入到玩家阵营里的欲望.
转变 市场变化,技术更新,其实职能一直在转换, 从页游到手游,从儿童游戏到棋牌,格斗,再到回合制.只是这一路的转变比我预想的要漫长好多,而且始终没有逃离技术这个圈子.人总有一种幻觉,如果再努力点,当是另一番模样. 刚开始进入游戏行业时想着:我要抱个大腿,构造一个如何牛b的框架.随着业务和市场的变化,这种片面的想法消逝殆尽.语言和框架归根结底只是一种实现.问题的解决方案才是我们最终想要的.
 Have I got a long way to run? Yeah, I run .
 </content>
    </entry>
    
     <entry>
        <title>一个游戏的生长过程</title>
        <url>https://farwmarth.com/post/%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8F%E7%9A%84%E7%94%9F%E9%95%BF%E8%BF%87%E7%A8%8B/</url>
        <categories>
          <category>life</category>
        </categories>
        <tags>
          <tag>游戏</tag>
        </tags>
        <content type="html">  每次都是挖了一个巨大无比的坑,填了好久都填不完.
 概念  IP : (Intellectual Property),知识产权,在游戏圈可以理解为拥有知识产权的一方,授权游戏开发商使用其主题素材 SP : (Service Provider)渠道商:相当于电影院(电影院线),电影院是直接面向观众的,各电影院线上映电影给观众看,渠道商则是上架游戏应用给用户下载玩. CP : (Content Provider)游戏开发商: 相当于电影制片方,聘请导演、演员、剧组人员进行电影的拍摄和制作,同理,游戏开发商聘请策划,程序,美术,开发团队进行游戏的开发和制作.开发商的核心竞争力,就是产品本身,产品做的越牛逼,开发商就越牛逼. 游戏运营商(发行商) : 相当于电影发行公司,进行电影的发行、销售、经营、推广,其实这个跟牌照也有关,因为在我朝面向群众的文化制品是管制品,不是什么阿猫阿狗拍个电影都能进电影院给观众传递不正确价值观的,于是就有牌照(电影发行经营许可证),制片方制作的电影必须通过有牌照的电影发行公司发行.同理在端游上也有牌照(文网文),端游审查、备案都需要通过拥有牌照的游戏发行商,而手游相对而言没有端游审查严格,手游发行商更多的作用是做市场营销、上线运营、渠道对接的工作,这些职能不是所有游戏开发商或开发团队都具备的.运营(发行)商的核心竞争力,是钱,是推广实力以及渠道关系.榜上有名的那些游戏,除了腾讯系以外. 渠道 : 是直接面对用户的,用户可从渠道下载游戏玩.渠道的核心竞争力(仅针对手游)是用户数量和质量 代理商 : 发行商的一种,属于分包发行商,从总包手中取得某个地区的发行权,并在该区域内制定销售策略并组织销售.  术语  代理 : 类似委托,将手游产品交给某个公司去负责,包括推广、运营等,cp只剩负责产品的更新、修改等,收入两者分成. 发行 : 手游发行负责产品的推广,与各渠道联系 运营 : 负责产品的拉新增、提升留存、促进活跃,网游是这样,单机的运营就是负责产品的对接了 联运 : 区别其他合作方式的地方,联运需要cp接入对方的计费方式,cp的联运可以多个合作方 首发 : 产品在某个平台第一次上线,首发可分为单平台首发(单个平台最早首发)和联合首发(多个平台共同首发) 独代 : 产品只交给某个公司负责,cp不能再找其他限定区域内的其他合作方,独代区域一般分为国内和国外,也可以具体细分  游戏分类   RPG:Role Playing Game角色扮演游戏,注重剧情
  ARPG:Action RPG 动作角色扮演游戏,加入了操作感的剧情游戏(格斗&#43;剧情)(地下城与勇士)
  SLG:Simulation Game模拟/战略游戏(魔法门之英雄无敌)
  MMORPG:(Massive Muti-Player Online RPG 大型多人在线角色扮演游戏,人多强调社交)(魔兽争霸)
  MOBA:(Multiplayer Online Battle Arena Games多人联机在线竞技游戏)(dota2,英雄联盟)
  FPS:(First Person Shooting第一人称射击游戏)(反恐精英)
  FTG:(Fighting Game格斗游戏)(拳皇)
  AVG:Adventure Game冒险游戏
  RAC:Racing 赛车游戏
  SPG:Sports Game 体育类游戏
  RTS:Real Time Strategy即时战略游戏
  STG:Shooting Game射击游戏
  MUG:Music Game 音乐游戏
  PUZ:Puzzle 益智游戏
  TAB:Table 桌面类游戏
  ETC:ETC 其它类游戏
  OPG:Office Perfect Game办公室经典游戏
  游戏公司的构成 游戏公司的构成除了常规的行政,财务这些部分之外,有其特定的构成. 从大的角度来划分的话就是运营团队和研发团队,研发团队负责产出游戏,而运营团队负责营销和推广. 研发团队从大体来分可以分为为三种角色:程序,美术和策划.各职位职责就不再累赘了.运营团队则分为商务和运营,商务主外.与渠道,媒介,广告平台打交道.运营负责游戏的数据的分析,分析市场情况将信息反馈给开发团队进行游戏的改进和后续的开发. 上面这个组织结构根据公司的规模与职能会有一些细微的调整.比如大的游戏公司一般有多款不同类型游戏,所有每个工作室都有自己的研发团队(包括美术,技能,策划).如果工作室的游戏足够成功,就会成立自己的运营团队.规模太太时甚至会独立成子公司.这些都是动态调整的.而公司的公共部门也可能出现公共的研发部来研发基础框架为各工作室服务,比如:渠道对接平台,运营数据分析平台等等.也有大公司是直接三位一体,研发,运营,渠道.比如腾讯. 对于一些小公司来讲,这样的组织结构是一个沉重的负荷.所以会出现职能重叠的现象,比如运营也要负责商务的对外的事务.研发团队中职位也不会细化. 还有一种模式就是公司只负责整个游戏运行的某一部分.这样也就衍生了职能更明确的公司,比如只有研发团队的公司和只管运营代理的发行公司.
游戏产出阶段 成立研发团队  团队成立方式最常见的是招聘的方式,一个公司想拓展游戏业务,拿了一笔钱,招兵买马,拉了一帮人开始做研发. 另外一种方式则是:一帮游戏公司里混迹很久的老员工,因为对现有公司 的不满或者是想出来自己单干,几个意见相投的核心人员一拍即合,拉拢一支基础队伍开始拉投资.我们现在的团队就是基于这种模式.
 团队核心的组建 前期筹划主要是团队核心的组建:项目经理,主策划,主程(客户端,服务端),主美,这些任职的人应当在行业里有多年经验,有过大型项目上线经验的人员,主策划由为重要,因为主策是主导整个项目玩法和走向的最主要的是达成目标达成一致,主策根据自己的团队特长和市场情况初步决定做哪一类型的游戏. 我们的程序团队是整个从前公司剥离出来的,程序核心经历了从页游 到手游的几个项目的转变,工作模式也比较熟悉.而美术则是之前项目里比较看好的美术,策划团队也是之前项目中的附带关系认识的.老胡之前是负责我们程序这一块的工作,也是这次团队的组建的牵头人,组建前期主要是:约谈主美,主策.商议项目类型.确定人数配置.然后和投资人谈筹码和条件.从技术到负责人的转变.个中滋味估计也只有自己亲身体会的人才懂.
拉投资 拉投资其实就是一个双方评估的过程.投资方评估开发团队的技术实力和项目前景,发团队则评估投资方的财力,发展状态. 如果是团队之前制作有相当成功的产品,拉投资应该是相当容易毕竟成绩摆在那里,或者已经有demo版本,投资团队也能做一个初步的评估.如果这部分先天优势就只能通过圈内的人脉介绍了. 投资这额的话.视项目大小而定,一般多人网络游戏投资500万左右,前期人员配置在十来人左右的团队每月花销在20万左右.开发周期大概5个月.后期再建立运营团队,测试导量,广告推广需要砸钱. 谈妥投资之后,老胡回来跟我们谈了谈投资公司的情况,规模大小,发展状态,资金状态.然后就是大家最关心的工资福利待遇.虽然说谈钱伤感情.但是工作这么多年已不再是单纯的能用空头支票来驾驭的小毛孩了,毛爷爷才是硬道理. 立项  项目类型 立项方案一般是投资方或者是主策划有意向.RPG,横版格斗,卡牌,COC策略,休闲,塔防,教育类等等.如果有些前瞻性的项目更好了,游戏从平台变化来看是这些一个过程:端游到页游再到手游,从视觉变化来看就是:2d到3d再到现在国内刚兴起的VR了. 定位 主要是消费人群的年龄段和市场定位,儿童市场偏向教育,生命周期比较长,游戏中可以设立一个知识线为主导,像儿童读物一样渐近型,再加入科普知识,益智小游戏,后期可以推出线下产品,独立电影,吉祥物,公仔,文具,教育app.成立文化公司,做成教育产品线.成人市场的话情况比较复杂,很难用一句话来概括市场上哪一类型的游戏会火,一般做法是刷新玩法,揉合多 种游戏的元素,优化视觉和流畅度,打击感. 而市场定位则是针对不同文化,不同族群的审美.现在的游戏公司普通是主攻国内市场,但也有专门主攻海外市场的,像东南亚印度,越南这些国家. 人员配置 初创的话,策划3人左右,客户端3人,服务器2人,美术3人.测试团队,出demo版本之后就要开始扩招人员来丰富游戏系统了.运营和数据统计后台的人员可以在功能版本完整的时候再招.  产品开发 排定日程计划 立项后就是召集人员开会拟定日程计划. 缓冲阶段 : 这一部分时间是产品开发前各个职位的基础准备工作,程序的技术选型,基础框架搭建,美术的风格确定.策划确定基础玩法.这个时间一般是一周左右,程序所耗费的时间在这一阶段是比较长的,直接用前面的项目框架积累的话时间周期会缩短很多.如果从零开始的话要关注的点比较多了:语言选择,框架选择,服务器客户端通信.基础工具模块.等等。缓冲阶段其实也是比较重要的环.之前项目开发半年遭遇技术选型错误,项目推翻重来,最后让技术重新学习再把游戏重构一遍这种情况.对士气来说是一个很大的打击. demo版本: 一般是游戏中的最核心的玩法.比如战斗中的布阵,战斗动作,攻击回合这一整个流程.demo版本研发团队各职位的侧重点不同.美术在这个阶段并产生是相当比较少的.一个角色,一套动作,然后就是最基础的一个战斗UI. 程序负责demo的编码实现,如果美术产出比较缓慢,客户端那就得从其他游戏中抠出一部分资源来做替代.而策划这时候则是做前置的工作,系统文档撰写,美术的角色,动作文档编写等等.如多少主角,多少场景,多少NPC等等统计. demo版本也是视游戏玩法复杂度和要求的完成度而言的.像我们这种回合加卡牌类型的游戏.简单的demo版本花三周多左右. 其他日程计划:一般是预估月版本计划,开发计划还有一种制定方案是跟开发的系统挂钩.比如一个大型系统pvp,公会完成后会发布一个内部展示的安装包.之后的运营计划视开发计划的完成度来制定.
项目迭代 技术比较成熟有积累的话,基础结构不需要有大的变化.技术前后端的框架选型,底层通信都可以重用,各端的核心负责分配人员工作,策划进行功能检收.demo版出来之后,可以加快迭代,版本一般以周为周期.,或者可以打大系统功能版本.而评估的工作量则要以天或者精确到半天为单位.开发过程中要实时关注市场变化,策划可以吸收一些新颖的玩法到开发计划中来. 策划的工作要一直先于其它几个部门,写全规则文档.
渠道SDK接入  商务确认 技术排期 服务器搭建(服务器参数配置,服务器后台搭建) 运营跟进(建群加双方负责人,渠道号配置,分区KEY配置,后台配置（帐号密码权限,渠道对应服务器选择) 技术接入(客户端,服务器) 测试(测试环境测试结果,正式环境测试结果) 送审(打包负责人,发包负责人) 正式上线，接入完毕(运营跟进后续问题)  运营阶段 测试的过程  测试过程是: 封测&amp;ndash;&amp;gt;内测&amp;ndash;&amp;gt;公测
  封测 : 封闭测试.游戏的核心内容已经实现(战斗引擎、基础模块等), 这个阶段主要是进行技术测试,压力测试.初期游戏制作方只会在游戏团队内部测试,也会邀请游戏媒体和极少量游戏玩家.但随着游戏运营的发展,制作方也会邀请目标用户参与测试(带有培养核心用户的目的),封测也有一测,二测……甚至N测.技术问题越多,测试论数就越多.但“事不过三”是古训,三轮封测还不够的话,这团队只怕要被砍了.封测的规模应根据测试方向进行调整.服务器开放数量: 1-2组为最佳.激活码发放数量由需测试的最高同时在线人数确定 内测 : 除封测用户外,会有更多的人参与进来,主要对游戏内容的测试(数值设计、系统架构、玩法设计),当然技术测试也是兼顾的.测试服务器承载,稳定性.游戏运营模式,前期的市场推广这个阶段通常需要激活码。也会分删档内测和不删档内测(这俩好理解) 公测 : 相对来说,这个时候游戏的技术稳定性和内容丰富性都是很完善的.这个阶段,数值设计.系统架构基本是没法大改了,但会根据玩家的反馈做一些完善和调整。同时根据玩家的建议和反馈,进行后续版本内容的制订。  商务((Business Development)) 主要就是维护和cp 平台 媒体 渠道等负责人的关系.主要工作内容:签订合同,搞定资源,达成合作协议,开拓合作伙伴（包括和cp ,sp 媒体,渠道),通俗讲就是代表游戏厂商去去和渠道要资源,制定并推进手机游戏产品推广和广告投放策略. 渠道接入导量:上线前要接入大量的SDK,要给技术预留一定的时间.渠道的谈洽是投资方商务合作拉拢的资源.都是处于大公司垄断状态. 商务这一块接触的比较少,具体的细节工作不知道是怎么执行的.知乎上有一个诙谐的比喻:商务说白了就是去拉客,在cp面前呈跪舔姿态让自己的游戏多导点量.
运营(Game Operation) 运营工作主要为辅助和策略研究,收集玩家反馈,和策划设定一些游戏活动 测试过程中 产品的辅助工作与各种资源的规划.内测方案和计划的制定. 产品测试版本的用户反馈与调查. 早期的市场预热宣传. 内测用户的组织和核心用户资源培养. 内测辅助资源的配合(网站,客服,运维…). 正式上线 运营是开发方与渠道方的沟通桥梁.负责出包,上架.为渠道方提供运营资料,比如游戏介绍,玩法介绍,宣传图.
项目研发期商务和运营没啥事情,我们的运营女汉子还是比较热心的,每天玩一大把游戏,然后把一些出众点和新奇的互动手段给反馈给策划这边.一旦到测试或者是上线阶段运营女汉子就像炸开了锅一样.催程序接SDK,出包,催美术出宣传图.和cp建立对接讨论组,然后还要录制战斗宣传视频.还要催催网站部做一个微信的html5宣传页面.地位感觉比商务还有low.妹子估计只想大喊一声:各处都是大爷啊.
风险预估表  服务器单服承载,极限峰值(PCU):15000,平均在线人数(ACU):1000人 服务器备用数量,准备时间,服务器达到负荷的80%且持续增长时开备用服务器 备用服务器功能活动的一致性 游戏包兼容机型 礼包使用是否全服 游戏bug收集 应急预警方案,补偿方案 游戏FAQ玩家问题引导 紧急联系人  运维 运维主要工作服务器环境构建(购买云服务器,配置游戏服务器所需运行环境),游戏开关服,游戏日常更新脚本携写
开服流程 开服前一周
 双方（渠道方、我方）协商确定开服（开服时间，新服名称），提出【开服申请】 是否确定开服时间，及新服名称 是否向运维技术人员申请【部署服务器】 是否与联运商（或我方商务）确认【广告投放排期】，积极有效沟通 是否收到运维服务器配置信息,并成功开服配置信息【部署到后台】 是否进行同步表-同步索引操作，并告知运维  开服前3天
 是否生成礼品卡等，并发送给渠道合作方（自由渠道部署到领取页面) 是否公布开服时间点 是否积极有效沟通【开服活动方案】，并经过可行性分析与上级（数值策划）最后确认 开服并限制IP访问，是否通知测试人员或渠道方进行【新服测试】（活动及公告、滚动公告、充值等） 游戏活动文案涉及的【参数】等是否成功部署到后台  开服前一天
 是否通知客服知悉新服事宜，并把活动文档交付 是否检查后台其他设置（正确关联分区，GM工具）  开服当天
 是否在开服当天通知运维人员清档，解除IP限制开服 是否准时开服 是否检查服务器状态  开服后
 开服后1-7天是否跟踪分析数据（导入量，充值，在线，登录活跃用户等） 是否询问客服及渠道关于玩家的反馈 是否感谢技术及各方人员的支持  附属行业  美术,音效外包 平台渠道广告 外挂及辅助工具公司 道具交易平台 游戏资讯,攻略平台  参考:
 商务,运营,市场的职责: https://www.zhihu.com/question/24693164 运营: https://www.zhihu.com/question/22155136 测试: https://www.zhihu.com/question/21498425 投资与创业: https://www.zhihu.com/question/37256626 游戏公司工作是怎样一种体验: https://www.zhihu.com/question/35887157 </content>
    </entry>
    
     <entry>
        <title>kids</title>
        <url>https://farwmarth.com/post/kids/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>kids</tag>
        </tags>
        <content type="html"> 一直以来对于小孩子处于一种敬而远之的状态。即使自己也是从熊孩子进化过来。今天就来说说各种小孩子的故事吧。
我的熊孩子时代 掏鸟蛋,捕鱼,偷板栗,瓜果,这些应该是农村里我们那个时候经常干的事情了,特别是偷别人家瓜果的时候,那种兴奋和紧张感现在想起来还觉得可笑。 怎么说偷这个东西呢，从行为上来讲肯定是不对的,但是作为一个孩子,如果自家又没有这个东西,难免会极度地艳羡. 印象比较深的是有一年夏天，和邻居的小伙伴去偷别人家的西瓜。 放学路过的时候已经踩过点,谁家的瓜地里瓜特别多,个头特大。夏天正午的时候太阳酷热无比，大人们一般在睡午觉，我和小伙伴两个人蹑手蹑脚地走在小山窝的水稻田小路上，走几步四周张望，生怕有个大人突然出现把我们逮个正着。确认视野内没有人之后我们开始行动了，我负责放哨，邻居比我年纪稍长的小伙伴负责摘瓜，偷瓜的过程没有多少考究，他花了两三秒钏选好了一个合适的瓜，考虑到瓜太大太显眼，而且又不好搬运，就挑了一个篮球大小的。摘好递给了我，看着手中的瓜心里正扑通扑通直跳，刚松一口气正准备提着战果离开的离开的时候，发现山窝里有一个人影拿着锄头出现了。我和小伙伴对看了一眼，慌忙地把瓜往水渠里一扔，卯足了劲撒腿就跑，回头看了一眼。只见那个人影也开始加速，骂骂咧咧的声音随即而来，我们被吓坏了，这如果被逮到了送家长晚上又没有好果子吃了，紧迫之下我们俩开始往山上跑，因为穿着短衣短裤跑的速度又快，松枝和杂草很快在脚上画上红色的印子。可是我们顾不了那么多，沿着山脉一直跑，根本不敢停下来。跑累之后，终于没有听见骂声了。坐在山顶上歇息，回想着刚才的事情还是心有悸然。我想，那次应该是长这么大以来跑得最快的一次了。
现在的熊孩子 万幸的是我接触的熊孩子不是太多。 我堂叔的小儿子应该是一个了，从小就是被宠着的那种，有两个姐姐，又加上农村还是有些重男轻女的观念。基本上是有什么事情都会依着他，像小皇帝一样伺候。犯了啥错也不会去罚他，自然是皮得不行，为所欲为，在房间里无端地放鞭炮，在家里资源独占。这些小事情都不说了，有一次我妹怀孕了几个月，坐在院子里乘凉，他突然跑过来把我妹的椅子给抽掉了，我妹一屁股就蹋在了地上。这可把我妈给吓坏了。幸好最后没出啥事，他奶奶也就是口头说了他几句。这可能就是教育不当吧。10来岁了，虽然说小孩子不懂事，但这种孕妇不能大动作动的基本常识还是理应懂的。还好现在长大了，也没那么皮了。 还有一个熊孩子就是城市里的，最近才接触到的，读五六年级的样子，张口就是网络上成人词语。在城市里接触的信息和媒介更多，这也是信息发达的两面性吧，接收的信息迅速，不管是好的还是坏的。和我们那个时代对比，乐趣完全不同。
萌娃 回女朋友过年的时候，她哥的两个小孩子给了我不一样的感受。 做长途汽车的时候小孩不用买票也不好占位置，我和小锅每人抱了一个小女孩子，小欣欣四岁左右，说话的时候老是说一句，然后停顿一下，若有所思的样子，然后又奶声奶气地地说着听不太懂的话。 欣欣和佳佳一路上都很活跃，数数，从一百数到一，互背诗词，然后又是猜谜语，小小孩童争着抢答急于表现的样子甚是可爱。话说累了又开始吃东西,吃薯片,辣条。过了一小时,终于是折腾累了欣欣就趴着我身上睡着了。想着她之前背了一篇短课文:“生活是什么，太阳说，是前进，是热爱”。其实她还不太明白这些刚学的词语是什么意思。 回到家后，欣欣一直嚷着要跟我们睡，刚开始很纳闷，一到床上她就开始问:叔叔，我可以玩你那个画画的手机吗？把我给逗乐了。这是她画的画,天赋异禀. 假期快结束的时候，我们对她说：叔叔要走了，她开始不舍，孩子特别容易产生的那种依赖感。然后她诺诺地问:要不你们多呆几天，再陪我玩玩嘛。下次吧,下次叔叔再陪你玩。
</content>
    </entry>
    
     <entry>
        <title>仓促的战斗模型设计</title>
        <url>https://farwmarth.com/post/%E4%BB%93%E4%BF%83%E7%9A%84%E6%88%98%E6%96%97%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>设计</tag>
        </tags>
        <content type="html"> 设计思路 新游戏开发又接近收尾的工作,记录一下这几个月开发的一些想法. 服务器设计延续了上一个游戏的基础结构. 由于前期demo版本开发周期很短,两周时间要一个战斗版本,所以还是遗留了一些如搅屎棍般的缺陷在里面. 上图就是基于初期战斗的设计思路. 基本思路即了解概念,梳理需求中的疑惑,再来进行代码重构和设计
 概念 概念是指游戏中策划的一些定义,我把它分为两部分,单位 和 战斗规则 单位有英雄,兵种(兵种属性),技能,buff等. 战斗规则概念繁多,有站位,战斗过程,伤害结算,buff结算,被动结算,技能释放等等. 疑惑 疑惑主要是来解答一些需求文档不确定或者产生歧义的地方.也是和策划沟通的记录  设计考量 因为服务器结构之前是服务于格斗游戏,现在转换成回合制游戏,除了一些基础模块外,大部分与游戏特性绑定的模块都得剥离掉. 可通用模块有 聊天,log,账号验证,活动主框架,公会主框架,数据传输模块和一些工具类. 在此基础上 数据配置表和 数据库表需要重新设计,旧功能模块剥离,还有一部分要考虑的是之前的设计问题,比如 静态数据共享,混服等.  编码过程中,我发现耗费时间最多的环节并不是编写新的战斗过程,而是改造原有代码. 战斗的实现在理清战斗流程和概念之后思路也清晰了.然而在改造原有代码的时候感觉是举步维艰. 原有模块如下: 事后想想其实在这过程犯了很多错误.归结一下
 过度设计 在实现战斗的时候总是考虑到以后要怎么扩展,比如可能组队战斗啊,还有就是太兼顾细节,如果一段代码用了两次就总想把他封装成起来.其实考虑这些也是无可厚非的事情,但是扩展,细节 与时间成本本来就是对立的,把握度上可以弹性一些,如果时间条件允许可以去精雕细琢.还有就是,一些需求是可以规避掉的,如果你考虑的扩展在短时间内不会提出来大可不必发花费时间在这上面 快速减法 改造原有代是个费时费脑的活动.要先理清原有代码的逻辑,然后再思考重构的方案.把旧代码再剥离掉.刚开始我的思路是把没用的模块全部剔除掉,改了两天发现系统过于庞大,各模块之间耦合度相当高.于是转换了一下思路.突出最主要模块来改造,因为是快速出战斗版本,所以就把场景模块和登录验证的这两部分保留,把其他模块的接口一律屏蔽掉.然后花着重去重构场景代码部分.果然验证了:Done is better than perfect  设计结构 结构设计并没有采用常见的多进程分隔数据服,登录服,游戏服这种结构 基于skynet的单进程多线程,独立 lua state为服务的模式,把登录,数据中心做成单独的 service,大概结构如下. 其他模块没啥好说的,说下战斗部分. 初期战斗模式比较简单,每方6个站位,速度最快的怪物先出手,所有人出手一次则是一回合,一回合后一方单位死亡后则到一个新的波次,所有波次完成即战斗结束,进行结算. 玩家统帅和副本怪物分成两个表,应策划要求,副本怪物可直接配置战斗属性值,而玩家统帅则通过阶位和强化度来提升战斗中的属性. 技能同组合效果组成,组合效果包含:buff,伤害,加减血,属性值变化,一个技能可以分成多段,例如先附加提升攻击的buff,再进行伤害段计算,再把攻击buff移除.技能和buff和攻击效果通过 TB_find_target_选择目标配置表规则来设定,计算的伤害或者属性由 TB_formula_公式配置表进行配置.
关键性实现 公式配置实现 应策划要求,伤害结算,buff效果结算都要通过当前攻击者,被攻击者的状态来计算,所以把公式放在配置表 TB_formula_公式配置表中配置.策划需要的运算规则比较简单,条件选择,一些简单的数学库就能满足要求.
(factor *(owner.physicalAttack * 0.75&amp;gt;= target.physicalAbsorb and owner.physicalAttack-target.physicalAbsorb or 0.25 *owner.physicalAttack ) * fightRate.r_kill * owner.cur_sodier_count * (1 &#43; owner.physicalRaiseHurt) * (1 - target.physicalReduceHurt) *fightRate.luckRate &#43; attachDamage )/10服务器环境基于lua5.3,5.3的实现如下: 主要是用 load加载字符串解析成代码, _ENV构造一个封闭的环境，load 和javascript中 eval类似
-- @Author: wujiyu -- @Date: 2015-11-26 14:14:18 -- @Last Modified by: wujiyu -- @Last Modified time: 2015-12-11 19:53:20 -- 表复制 local tableutil = require &amp;#34;public/util/tableutil&amp;#34;local _e = {}_e.print=print_e.pairs=pairs_e.ipairs=ipairsfor k,v in pairs(math) do_e[k] = vendlocal _formula_maps = {}local formulautil = {}function formulautil.formula( ctx,params )local _data =tableutil.clone(_e)local f = _formula_maps[ctx]if not f thenf = assert(load(&amp;#34;local _ENV=...; return &amp;#34;..ctx))_formula_maps[ctx]=fendtableutil.fill_data(_data,params)-- print(&amp;#34;!!!!!!公式参数&amp;#34;,ctx) -- tableutil.print_table(params) return f(_data)end-- local result = formulautil.formula(&amp;#34;owner.hp&amp;gt;owner.mp and max(5, floor(owner.hp * 2)) or owner.mp&amp;#34;, {owner={hp=10,mp=30}}) -- print(result) return formulautil后来改成手动战斗后,整个战斗过程移植到了客户端,而客户端的lua版本为5.1.稍微改动了一下,用 loadstring替换 load,setfenv替换 _ENV.
-- @Author: wujiyu -- @Date: 2015-11-26 14:14:18 -- @Last Modified by: wujiyu -- @Last Modified time: 2015-12-11 19:53:20 -- 表复制 local tableutil = require &amp;#34;tableutil&amp;#34;local _e = {}_e.print=print_e.pairs=pairs_e.ipairs=ipairsfor k,v in pairs(math) do_e[k] = vendlocal _formula_maps = {}local formulautil = {}function formulautil.formula( ctx,params )local _data =tableutil.clone(_e)local f = _formula_maps[ctx]if not f thenf = assert(loadstring(&amp;#34; return &amp;#34;..ctx))_formula_maps[ctx]=fendtableutil.fill_data(_data,params)setfenv(f,_data)-- print(&amp;#34;!!!!!!公式参数&amp;#34;,ctx) -- tableutil.print_table(params) return f(_data)endlocal result = formulautil.formula(&amp;#34;owner.hp&amp;gt;owner.mp and max(5, floor(owner.hp * 2)) or owner.mp&amp;#34;, {owner={hp=10,mp=30}})print(result)return formulautil</content>
    </entry>
    
     <entry>
        <title>谁点谁怀孕之代码解析</title>
        <url>https://farwmarth.com/post/%E8%B0%81%E7%82%B9%E8%B0%81%E6%80%80%E5%AD%95%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>教你瞎折腾</tag>
        </tags>
        <content type="html"> 最近又发现有新的崩溃代码了,打开页面,内存就会被榨干.回想之前也有过特殊字符使iphone白屏的情况.收集一下玩玩.
iPhone调到1970年变砖 触发bug条件与表现 满足以下条件，『时间回归』bug被触发：
 系统版本：iOS 8.0 ~ iOS 9.3 beta 3 硬件设备：搭载64位处理器的设备（即处理器为A7~A9X的设备） 进入『设置』-『通用』-『时间与日期』，关闭『自动设置』，并将时间修改为1970年1月1日，分秒任意. 修改时间后，需要重启设备。  Bug触发表现：iOS设备启动时，卡在苹果Logo，无法继续启动。 解决方案 针对所有64位处理器的iOS设备 拆机并拆出电池，放置10分钟后重新安装。 电量充足的情况下，等待数小时，当Unix时间戳的数值大于等于0，系统时间生效，可正常开机。
http://www.cnbeta.com/articles/474579.htm
history.pushstate() &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt;var total = &amp;#34;&amp;#34;;for (var i = 0; i &amp;lt; 1000000; i&#43;&#43;) {total = total &#43; i.toString();history.pushState(0, 0, total);}&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;history.pushstate()是HTML5引入的API，pushState将指定的URL添加到浏览器历史里,存储当前历史记录点。 当 i&amp;lt;100000 的时候会循环的将 total记录到浏览器历史里,测试地址http://www.0xroot.cn/demo.html
android qq 发表说说
{uin:54432,nick崩死你空间,who:1}其中“54432”可以随便改，“崩死你”内容也可随便改iphone 字符  字符包含英文、阿拉伯文和中文 https://www.zhihu.com/question/21568134  Powerلُلُصّبُلُلصّبُررً ॣ ॣh ॣ ॣ 冗控件显示bug,在 iOS 6 或者OS X 10.8中 WebCore,CoreText的显示多种语言时崩溃
Chrome 如果你使用Chrome 45或更老的版本，可以试试在地址栏输入以下字符
http://a/%%30%30</content>
    </entry>
    
     <entry>
        <title>markdown简明语法</title>
        <url>https://farwmarth.com/post/markdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>markdown</tag>
        </tags>
        <content type="html"> 简明语法 基本符号  *,-,&#43; 3个符号效果都一样，这3个符号被称为 Markdown符号 空白行表示另起一个段落 `是表示inline代码，tab是用来标记 代码段，分别对应html的code，pre标签  标题  标题 ##生成h1-h6  换行  单一段落&amp;lt;p&amp;gt;用一个空白行 连续两个空格会变成一个&amp;lt;br&amp;gt; 连续三个Markdown符号---或***  强调  斜体 *斜体* 斜体 粗体 **粗体** 粗体   引用  引用 在段落的每行或者只在第一行使用符号&amp;gt;,还可使用多个嵌套引用&amp;gt;&amp;gt; 代码区块 两个单引号 块代码: ```python 代码```  列表  使用*,&#43;,-加上一个空格来表示 可以支持嵌套 有序列表用(数字&#43;英文点&#43;空格)来表示如(1. ) 列表内容很长，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的  链接  行内式: [锚文本](url &amp;quot;可选的title&amp;quot;) 参考式: 引用先定义 [ref_name]:url，然后在需要写入url的地方， 这样使用[锚文本][ref_name]，通常的ref_name一般用数字表示，这样显得专业 简写url：用尖括号包裹url,这样生成的url锚文本就是url本身,&amp;lt;htttp://www.baidu.com&amp;gt;  图片  行内式和链接的区别是多一个!号 直接使用&amp;lt;img&amp;gt;标签，这样可以指定图片的大小尺寸  表格 | Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |   Tables Are Cool     col 3 is right-aligned $1600   col 2 is centered $12   zebra stripes are neat $1    表格中换行用html标签br
疑难杂症  首行缩进: &amp;amp;#160; &amp;amp;#160; &amp;amp;#160; &amp;amp;#160;或者&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp; 字体颜色: 用html标签&amp;lt;font color=red&amp;gt;我是红色&amp;lt;/font&amp;gt; 替换html标签正则:
过滤所有以&amp;lt;开头以&amp;gt;结尾的标签: &amp;lt;([^&amp;gt;]*)&amp;gt; 
找出IMG标签: &amp;lt;\\s*img\\s&#43;([^&amp;gt;]*)\\s*&amp;gt; 
找出IMG标签的SRC属性: src=\&amp;quot;([^\&amp;quot;]&#43;)\ 
常用转义  &amp;amp;quot; (&amp;#34;)&amp;amp;amp; (&amp;amp;)&amp;amp;lt; (&amp;lt;)&amp;amp;gt; (&amp;gt;)&amp;amp;nbsp; ( ) 一个好看的样式  </content>
    </entry>
    
     <entry>
        <title>Kindle不完全指南</title>
        <url>https://farwmarth.com/post/kindle%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>kindle</tag>
        </tags>
        <content type="html"> 资料整理来自(http://kindlefere.com)
1. 推送 1. 邮件推送 1. 基础知识 1 美亚kindle管理:https://www.amazon.com/mn/dcw/myx.html/ref=kinw_myk_redirect#/home/settings/payment2 中亚kindle管理:https://www.amazon.cn/mn/dcw/myx.html/ref=kinw_myk_redirect#/home/settings/payment2. 页面设置   为 Kindle 设备绑定亚马逊账号 点击 Kindle 屏幕右上角的三条横杆菜单图标，在弹出的菜单中点选设置，选取自己的Wifi热点将Kindle连接上WiFi,然后点击“注册”项填入第一步注册（或已有）的亚马逊帐号
  获取接收推送的邮箱地址   添加推送邮箱地址到已认可邮箱列表 需要在【设置】页面底部找到“已认可的发件人电子邮箱列表”这一项，点击“添加认可的电子邮箱”把第一步申请的邮箱地址（或已有邮箱地址）添加进去。   3. 常规邮件推送  收件人类似“***@kindle.cn”的目标邮箱地址,主题和内容可随意填写或者干脆不填写（若想把发送的诸如 TXT,PDF文档自动转化为Kindle专有格式可以在电子邮件的主题栏中填写”convert”）。 然后添加要推送的文档或电子书到附件，点击发送。 稍等片刻，你的 Kindle 就可以收到推送的内容了（如果你推送的内容不被支持会收到一份“你发送至Kindle的邮件未附任何文件附件”的提示回信）。  注意一定要使用邮箱的普通附件，不要使用诸如163 云附件、QQ 中的超大附件、Gmail 中的 Google Drive 附件之类的非普通附件。还需要注意亚马逊云端对文档大小的限制是 50MB，邮箱附件大小不要超过这个数值4. Calibre 设置推送 163 邮箱：主机名 smtp.163.com 端口 465 或 587（加密类型：SSL）126 邮箱：主机名 smtp.126.com 端口 465 或 587（加密类型：SSL）yeah 邮箱：主机名 smtp.yeah.net 端口 465 或 587（加密类型：SSL）新浪邮箱：主机名 smtp.sina.com 端口 端口 465 或 587（加密类型：SSL）Gmail 邮箱：主机名 smtp.gmail.com 端口 587（加密类型：TLS）Hotmail/Live/Outlook邮箱：主机名 smtp-mail.outlook.com 端口 587（加密类型：TLS）QQ 邮箱：主机名 smtp.qq.com 端口 465（加密类型：SSL）右键一键推送图书 回到主界面书库，选择一个或多个电子书，右键点击所选电子书，在弹出的菜单里将鼠标指针悬浮到“连接/共享”，在弹出的子菜单中点击“发送右键至***@kindle.cn”（***@kindle.cn 就是第2步填写的那个邮箱），就可以直接把这些电子书发送到你亚马逊账户中的【我的内容】中了。
5. 闪电邮推送 如果感觉每次都要打开浏览器进入邮箱发送附件比较麻烦，可以通过邮箱桌面客户端“网易闪电邮”的右键发送功能简化推送步骤。此方法仅适用于 Windows 系统。 请先把发送邮件的邮箱添加到亚马逊已认可列表。然后进入“网易闪电邮”下载页面，下载安装后打开。可以关闭烦人的向导，填入你的邮箱和密码（不只是 163 邮箱，其他的如 QQ邮箱、新浪邮箱等主流邮箱都可以的哦）并选择“客户端模式”。 点击菜单栏的“邮箱 -&amp;gt; 邮箱设置”，点击设置窗口左侧的“发信设置”，然后勾选左侧窗口中的“默认抄送给”，把“@kindle.cn”结尾的接收邮箱，点击【保存并关闭】。 现在用鼠标右键点击需要推送的文件，在弹出的右键菜单中点击“通过网易闪电邮发送”，文件将自动被添加到附件中，直接点击左上角的【发送】按钮就可以直接推送到亚马逊云端了。 6. 微信推送  在亚马逊 Kindle 服务号中回复“绑定 &#43; Kindle 电子邮件地址”（不带引号哦！）Kindle 电子邮件地址是和您的 Kindle 设备关联的唯一邮箱，这个邮箱可以帮助您推送各种个人文档。比如您的 Kindle 电子邮件地址为：123456789@kindle.cn，那就回复“绑定 &#43; 123456789@kindle.cn ”使您的 Kindle 和微信服务号绑定，这样就可以推送文章了。 添加白名单,在【已认可的发件人电子邮箱列表 】下方，请选择【添加认可的电子邮箱】。输入 kindle@eub-inc.com， 推送内容到Kindle （1）推送微信公众号的图文消息 点开消息，然后点右上角，最后选“亚马逊Kindle服务号” （2）推送微信对话 长按任意消息，选择“更多”，勾选所有您要保存的消息。再点右下角的【…】，选择“亚马逊Kindle服务号”。请求成功后稍等片刻，文章便推送至您的Kindle设备，记得保持Kindle一直处于联网状态。您还可以在微信菜单中的【Send to Kindle】中查看推送记录 （3）推送普通网页内容 除了以上两种方式，还可以通过“扫一扫”功能推送普通网页哦。首先打开二维码生成器（http://cli.im/url），把需要推送的网址贴上去生成一个二维码，然后使用微信的“扫一扫”扫描生成的二维码，然后点右上角，最后选“亚马逊Kindle服务号”即可  公众号  亚马逊Kindle服务号 kindle1000 readfreeme  7. 网盘推送  ifttt gmail dropbox 必要条件  ifttt帐号、dropbox帐号、gmail帐号、kindle推送邮箱、个人电脑一台跳转到ifttt登录后激活dropbox和gmail的通道. 设置subfolder name(Dropbox中网盘新建一个文件夹),to address(自己的设置邮件地址)，ok https://getbookdrop.com/start wappwolf googledrive 网盘推送同上,美亚账号,中亚的要付费  8. 插件及网站方式  fivefilters 一键发送到kindle Send to Kindle for Google Chrome 这个然并卵,官方出品和电脑端一样只能是美亚账号  9. rss 推送网站  http://www.mybanshu.com/portal.php  2. wifi推送 1.Calibre wifi   打开 Calibre，点击界面上方的图标按钮“连接/共享”，在弹出的菜单中点击“启动连接服务”。   记录共享 IP 和端口   使用 Kindle 体验版网络浏览器访问下载 Kindle浏览器中输入http://192.168.1.100:8080（这里请输入你自己的IP）   3. usb推送 1. usb数据线 2. otg  如何使用安卓手机的 OTG 功能管理 Kindle 文件？  1 一部 Kindle 设备, 一条 Kindle 数据线, 一部支持 OTG 功能的 Android（安卓）手机（平板也可）, 安装文件管理 APP（推荐“ES文件管理器”）, 一条 OTG 线2 将 OTG 线与 Kindle 数据线相连接；3 把 Kindle 数据线插到 Kindle 上（注意！Kindle 数据线不要插到手机上）；4 将 OTG 线插到手机上（注意！OTG 线不要插到 Kindle 上）。5 点击“菜单（左上角的三道杠）”，展开“本地”标签；6 找到类似“USB1002”的盘符，点击该盘符；7 会提示“允许应用‘ES文件浏览器’该USB设备吗？”的提示框，继续点击【确定】按钮；8 可以看到一个名为“Kindle”的文件夹，这就是 Kindle 磁盘；9 把手机中的电子书文件拷贝到里面的“documents”文件夹中；10 传输完毕后断开 USB 连接，打开 Kindle 就能看到拷贝进去的电子书了。2. 资源   苏菇莨
  胖次搜索
 </content>
    </entry>
    
     <entry>
        <title>wordpress迁移到hexo</title>
        <url>https://farwmarth.com/post/wordpress%E8%BF%81%E7%A7%BB%E5%88%B0hexo/</url>
        <categories>
          <category>life</category>
        </categories>
        <tags>
          <tag>hexo</tag>
        </tags>
        <content type="html"> 引用  (官方帮助)  依赖 #安装hexonpm install hexo -g#安装hexo命令行模块npm install hexo-cli -g#创建blog目录hexo init blogcd blog#初始化npm install#安装server插件npm install hexo-server --save#git插件npm install hexo-deployer-git --save#feednpm install hexo-generator-feed@1.0.2 --save#sitemapnpm install hexo-generator-sitemap@1.0.1 --savehexo init后目录结构 .├── db.json #json格式的静态常量数据库├── _config.yml #网站配置├── package.json #插件依赖├── scaffolds #文章模板├── scripts #脚本文件夹├── source #资源文件夹| ├── _drafts #草稿| └── _posts #要发布的源文章└── themes #主题下载blog中的图片 写了一个py脚本搞定 https://gist.github.com/wujiyu115/707691f95713c69fde01 把blog文中的图片下载下来放到source目录中,以wp-content目录为根目录,域名不变的前提下文章中的链接都需要再更新
常用命令 hexo new [layout] &amp;lt;title&amp;gt; --hexo n #建立新文章，默认在_posts下，layout=&amp;#34;draft&amp;#34;时发布的是草稿hexo publish &amp;lt;filename&amp;gt; --hexo p #将_drafts下的文件放到_posts下，也就是发布草稿hexo generate --hexo g #生成静态文件hexo clean --hexo c #清理缓存hexo server --hexo s #启动服务器hexo deploy --hexo d #部署到远程部署步骤  如果是直接写完整篇文章,部署的步骤。  #创建文章hexo new post &amp;lt;filename&amp;gt;#生成文章hexo generate#发布hexo deploy 如果有草稿的话可以这样  #创建草稿hexo new draft &amp;#34;new draft&amp;#34;#编辑好草稿好后发布草稿hexo publish &amp;lt;filename&amp;gt;#预览草稿hexo server --drafts#发布hexo deploy_config.xml ###部署类型设置git
#hexo 3.0 部署类型不再是github，_config.yml 中修改,同时部署到github和gitcafe deploy:- type: gitrepo: https://github.com/wujiyu115/wujiyu115.github.com.git,master- type: gitrepo: https://gitcafe.com/wujiyu115/farwmarth.git,gitcafe-pages安装主题 #定位到根目录git clone https://github.com/iissnan/hexo-theme-next themes/next#更改根目录_config.ymltheme: nextlanguage: zh-Hansnext主题  https://github.com/iissnan/hexo-theme-next/wiki http://theme-next.iissnan.com/  hexo源文章和主题管理  github建立主仓库管理文章叫hexo fork一下next主题新仓库叫next 然后在hexo仓库中themes中添加submodule这样主题和源文章分开管理.hexo仓库只托管源文章.  管理主题  自己的next仓库持有两个远程别名,自有的fork的origin,另外一个是官方next主题别名为upstream. 自己对主题的修改推送到fork的origin仓库中 要更新官方的新版本时,从upstream中pull下来进行合并。  git submodule add https://github.com/wujiyu115/hexo-theme-next.git themes/nextcd themes/nextgit remote add upstream https://github.com/iissnan/hexo-theme-next.githexo仓库更新子项目 git clone https://github.com/wujiyu115/hexo.git hexocd hexogit submodule update --recursive --init删除submodule git submodule deinit &amp;lt;path_to_submodule-name&amp;gt;git rm --cached &amp;lt;path_to_submodule&amp;gt;rm -rf .git/modules/&amp;lt;path_to_submodule&amp;gt;域名绑定 github https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider/
 ping wujiyu115.github.io记录下IP地址 CNAME 在仓库根目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如:test.com),不需要添加http/www等前缀 添加 DNS Service记录 清理浏览器缓存 chrome://net-internals#dns 点击 clear host cache  gitcafe https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9#wiki
 将用于 Pages 服务站点的自定义域名使用 CNAME 记录指向 gitcafe.io。  技巧 新建一个不依赖模板的HTML页面 如果你是不想hexo g时被模板改变你的html的话，可在在文件头加layout: false
例如新建一个404页面
layout: falsetitle: &amp;quot;404&amp;quot;date: 2015-02-05 20:03:48---&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;404 Page Not Found&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; coding上单项目部署公钥 #测试密钥是否部署成功ssh -i /data/publish/xxx_rsa -T git@git.coding.net问题 出现 Cannot GET / npm install hexo-server --save 注意冒号后面都要添加一个半角空格 之后才是设置参数  hexo中source目录的js被渲染 hexo会把hexo/source下的文件全部渲染,放在source目录的js也会被渲染出错,解决办法就是将js文件放到主题的source目录中,如themes/next/source中解决hexo神烦的DTraceProviderBindings MODULE_NOT_FOUND npm install hexo --no-optionalnpm uninstall hexonpm install hexo --no-optionalnpm uninstall hexo-cli -gnpm install hexo-cli -g提交出现fatal:multiple stage entries for merged file的问题. 在hexo主目录中执行如下操作解决。
rm .git/indexgit add -Agit commit</content>
    </entry>
    
     <entry>
        <title>给skynet加上curl模块</title>
        <url>https://farwmarth.com/post/%E7%BB%99skynet%E5%8A%A0%E4%B8%8Acurl%E6%A8%A1%E5%9D%97/</url>
        <categories>
          <category>c&#43;&#43;</category>
        </categories>
        <tags>
          <tag>luacurl</tag>
        </tags>
        <content type="html">  现在项目里用的是早期的skynet版本,一直不支持http的get,post. 充值与后台交互方式都是采用socket的方式。大部分需求都尽量避开这一块，最近策划又提了个需求,关服开服状态要反应到客户端。这个项目服务器列表是直接是一个静态文件放在web容器中.思路很简单,用jsp写个服务来修改服务器状态(这里应该做安全检验),各服务器开关服，或者服务器崩溃时将状态上报到web服务上. 关键就在这个skynet的http上.尝试用skynet的socket来模拟http请求,一直处于阻塞状态。没有去细究. 然后从github找了个luacurl库 : https://github.com/Lua-cURL/Lua-cURLv3 , 然后把依赖库http://curl.haxx.se/download.html 也down下来.
编译curl ./configure --prefix=/usr/local/curlmakemake install编译lua-curlv3 &amp;gt; 这步有点蛋疼,刚开始是lua路径不对,默认写是的5.1的目录，skynet我们用的是lua 5.2.而且安装的路径也不一样，修改之后，一直卡在找不到curl/curl.h这个头文件上。最后修改makefile把头文件路径加上去解决了这个问题,修改的部分makefile代码:
include .configT=lcurlUNAME ?= $(shell uname)DESTDIR ?= /PKG_CONFIG ?= pkg-configINSTALL ?= installRM ?= rmLUA_IMPL ?= luaCC ?= $(MAC_ENV) gccLUA_VERSION = $(shell lua -v| awk &amp;#39;{ print substr($$2,1,3) }&amp;#39;)# ifeq ($(LUA_VERSION),)# LUA_CMOD ?= /usr/lib/lua/5.1# LUA_LMOD ?= /usr/share/lua/5.1# LIBDIR ?= /usr/lib# LUA_INC ?= /usr/include# CURL_LIBS = -L/usr/local/lib -lcurl# else# LUA_CMOD ?= $(shell $(PKG_CONFIG) --variable INSTALL_CMOD $(LUA_IMPL))# LUA_LMOD ?= $(shell $(PKG_CONFIG) --variable INSTALL_LMOD $(LUA_IMPL))# LIBDIR ?= $(shell $(PKG_CONFIG) --variable libdir $(LUA_IMPL))# LUA_INC ?= $(shell $(PKG_CONFIG) --variable includedir $(LUA_IMPL))# LUA_LIBS = $(shell $(PKG_CONFIG) --libs $(LUA_IMPL))# CURL_LIBS = $(shell $(PKG_CONFIG) --libs libcurl)# endifLUA_CMOD ?= /usr/local/lib/lua/$(LUA_VERSION)LUA_LMOD ?= /usr/local/share/lua/$(LUA_VERSION)LIBDIR ?= /usr/libLUA_INC ?= /usr/local/include/CURL_INC ?= /usr/local/curl/include/CURL_LIBS = -L/usr/local/curl/lib -lcurlifeq ($(UNAME), Linux)OS_FLAGS ?= -sharedLIBS = -lrt -ldl $(CURL_LIBS)endififeq ($(UNAME), Darwin)OS_FLAGS ?= -bundle -undefined dynamic_lookupMAC_ENV ?= env MACOSX_DEPLOYMENT_TARGET=&amp;#39;10.3&amp;#39;LIBS = -ldl $(CURL_LIBS)endififneq ($(DEBUG),)DBG = -ggdbendififeq ($(DEV),)WARN = -Wall -Wno-unused-valueelseWARN = -Wall -W -Waggregate-return -Wcast-align -Wmissing-prototypes -Wnested-externs -Wshadow -Wwrite-strings -pedanticendifINCLUDES = -I$(LUA_INC) -I$(CURL_INC)DEFINES =COMMONFLAGS = -O2 -g -pipe -fPIC $(OS_FLAGS) $(DBG)LF = $(LIBS) $(LDFLAGS)CF = $(INCLUDES) $(DEFINES) $(COMMONFLAGS) $(WARN) -DPTHREADS $(CFLAGS)SCR = src/lua/*.lua src/lua/cURL/*.lua src/lua/cURL/impl/*.luaSRCS = src/*.cBIN = $(T).soall: $(BIN)$(BIN): $(SRCS)$(CC) $(CF) -o $@ $^ $(LF)# @echo $(LUA_CMOD) install: all$(INSTALL) -d $(DESTDIR)$(LUA_CMOD) $(DESTDIR)$(LUA_LMOD)/cURL/impl$(INSTALL) $(BIN) $(DESTDIR)$(LUA_CMOD)$(INSTALL) src/lua/cURL.lua $(DESTDIR)$(LUA_LMOD)$(INSTALL) src/lua/cURL/safe.lua $(DESTDIR)$(LUA_LMOD)/cURL$(INSTALL) src/lua/cURL/utils.lua $(DESTDIR)$(LUA_LMOD)/cURL$(INSTALL) src/lua/cURL/impl/cURL.lua $(DESTDIR)$(LUA_LMOD)/cURL/implclean:$(RM) -f $(BIN)编译好后在目录生成lcurl.so文件。基本上就ok了。 local curl = require &amp;#34;lcurl&amp;#34;curl.easy():setopt_url(url):setopt_writefunction(io.stderr) -- use io.stderr:write():perform():close()这样require就可以加载这个动态链接库跑过来了
默认是同步的,异步访问:
local cURL = require(&amp;#34;cURL&amp;#34;)-- setup easy and urlc1 = cURL.easy{url = &amp;#34;http://www.lua.org/&amp;#34;}c2 = cURL.easy{url = &amp;#34;http://luajit.org/&amp;#34;}m = cURL.multi():add_handle(c1):add_handle(c2)print(&amp;#34;-------------------------&amp;#34;)for data, type, easy in m:iperform() doif type == &amp;#34;data&amp;#34; and c1 == easy then print(data) endif type == &amp;#34;data&amp;#34; and c2 == easy then print(data) endend</content>
    </entry>
    
     <entry>
        <title>翻翻旧货</title>
        <url>https://farwmarth.com/post/%E7%BF%BB%E7%BF%BB%E6%97%A7%E8%B4%A7/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>python</tag><tag>自动注册</tag>
        </tags>
        <content type="html"> 这两个月代码产出量比以往都要高，可能是兴趣所致,总喜欢折腾一些工作外的想法.
二月份的时候断断续续花了一周的时间写了fei.py这个自动化注册的东西。也当是python的一次练手.
说来也巧,写这个东西起因是因为在博客上看到&amp;quot;轻松筹&amp;quot;发起了刷脸送parallels desktop 正版激活码的活动.其实就是在&amp;quot;轻松筹&amp;quot;上发起一个活动,让好友来支持,这样就可以得到一套正版的激活码.但是注册这个网站不是一般的邮箱注册,而是手机号注册.神奇的网路上一搜索，果然有专门提供一次性注册得到验证码的服务,筛选了一下就用了飞Q(http://sms.xudan123.com/api.html)这个服务,代码分为三个部分,注册,创建支持项目,确认支持.期间也遇到不少问题,调用&amp;quot;轻松筹&amp;quot;短信接口太频繁被封ip,然后就写了个代理筛选的模块.需要BeautifulSoup模块的支持.

代码奉上: https://gist.github.com/wujiyu115/0fa517285ed3788ddd6a
三月份玩了下instagram,发现了不少好的图片,苦于instagram没有保存的功能,又不满Instadownloader这个应该的功能单一性，然后就自己动手写了一个下载图片视频的app.用法很简单,启动app后会监测剪贴板,在原应用复制链接时符合规则的图片或者是视频就会自动下载了.没有复制链接的就点击分享按钮,分享应用选择我的app就可以了.目前支持的应用:

仓库: https://bitbucket.org/wujiyu115/easy_photo/
</content>
    </entry>
    
     <entry>
        <title>萌芽</title>
        <url>https://farwmarth.com/post/%E8%90%8C%E8%8A%BD/</url>
        <categories>
          <category>一个人的喃喃自语</category>
        </categories>
        <tags>
          <tag>一个人的喃喃自语</tag>
        </tags>
        <content type="html"> 再开始写点东西  话说我为什么又开始写点东西了? 一是心血来潮,二是发现大半年都在一种半漂浮的状态,没有一些真正的思考.
 整理了下旧时写的一些博文,用四个字来形容是:其差无比,要么是篇幅太短,要么结构缭乱,要么是一些现在看来一文不值的转载,万物大概都遵循了这个法则:随着时间的推演,总会产生一些变化.当时的心境和现在也是大相径庭.
 我记得第一篇博文应该是在刚参加工作的时候,字里行间尽是刚工作的困惑与新奇感.思绪也像脱缰的野马,完全没有逻辑,而且写完后从来不会再审阅,就像twitter上有人发过一句话一样:写过后的文章就像拉过的屎,不忍回头再看.现在倒是养成了一点小习惯,不管文章写得多烂,还是会自己再去读一读,改改错别字和措辞,估且算是一种进步吧.
 要说不足的地方就是拖延症,每次开了个头,不知道几天后才能把剩下的写完.原因也有几种,灵感匮乏,经常是有一点小思绪却不知道怎么成文.要么是写着写着被其他事耽搁了,再捡起来写找不到当时的氛围.所以草稿箱里胎死腹中的不计其数.不仅仅是博文.还有很多想完成的点子也是如此.估计大部分人都如《Before Sunset》里所说的:&amp;ldquo;There&amp;rsquo;s so many things I want to do,and I end up doing not much.&amp;quot;,坚持和保持热情是一件很困难的事情.
 失败但有意义的一次项目  最近朋友找到我做一个视频会议的交互app,抱着跃跃一试的心态答应了,花了二天时间做demo,收定金然后开始漫长的编码过程,因为朋友没用过git,所以代码仓库用了淘宝的svn.其实这个领域并不熟悉,边学边做,从github上扒源码改造.做了两周牺牲了两个双休,主体功能大体是出来了,交货的过程并不顺利,达不到客户的指标,而且我们两个人的情绪上也是有点些波动,被客户的要求折腾地想死,上班的时间也在撸这个. 周一的时候特意请假在家准备把这个烫手的山芋整完,朋友打电话过来说:这个活还是推掉算了,影响正常工作不说还焦头烂额的.我也不再过多说什么,两三周紧崩的弦突然松弛下来有点找不到北的感觉.事后想想这无疾而终的事情顿觉遗憾.有时候付出了不一定能得到想要的结果,这一圈下来也是长了点教训,工作量和需求没有评估好,而且对这种外单来说,牺牲个人时间是无法避免的,要说收获吧也不是没有.做交互其实单独做成一套业务,一些以视觉导向的行业有大把的这种需求,教育行业,广告,地产.这个业务可以成为一个长期的发展方向.再者就是做东西要追求细腻度,之前做东西大多是功能为导向,功能完全微调就交差了.就算了自己兴趣之内做的东西也是过于粗糙,很少去考虑观感.
 说说拍照  怎么说呢,算了发展一下兴趣爱好吧,60D买了近一年了,偶尔去拍拍东西,大多数是给女朋友拍,都是边玩边拍的状态.一年了摄影水平并没有太多长进,大抵就是因为是兴趣,不会花太多精力去脑补这个领域的知识.今年对摄影产生了不一样的期许,受一些网上的素材启发又有了一些新的想法想去完成.比如延时摄影,减光境拍风光片,夜影等等.其实摄影和写作相差无几, 都是表达情绪的一种方式,只是一个是视觉系,一个是思维系.
 摄影群里经常有两种纷争,一是器材,二是后期,好的器材确实能帮一个摄影师拍出更出色的照片,更好的细节,更丰富的色彩.但是好的照片跟好器材并不成正比.就像好文章与华丽辞藻一样,立意准确,片面整洁,色彩得当,我觉得这就是一张好的照片.至于后期,一些大拿说后期是对原片的一种侮辱,是对自己的提炼不自信的表现.我倒觉得并非如此,可能是还没到那个境界,我觉得后期也分两种,一种是裁剪和修饰,让视角和色彩更符合拍摄者的原意.一种是二次创作,让原有的作品有不一样的表现.比如加上镜像,局部色彩高亮. 不管大拿怎么想,反正我现在是挺乐意折腾后期的.
 今天写得比较顺利,一气呵成了.推荐个白噪音网站: http://www.rainymood.com/
</content>
    </entry>
    
     <entry>
        <title>这一年看的电影</title>
        <url>https://farwmarth.com/post/%E8%BF%99%E4%B8%80%E5%B9%B4%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/</url>
        <categories>
          <category>movie</category>
        </categories>
        <tags>
          <tag>movie</tag>
        </tags>
        <content type="html">  少年时代(boyhood) 此片时长166分钟,看的时候自备干粮。整个故事讲的是一个男孩从6岁到18岁的成长过程,父母在6岁的时候就离婚，母亲独自抚养姐弟俩，只有每年夏天的时候会和父亲有段时间相处。母亲为了他们更好的生活，一边读求学一边照顾他们。后来嫁了一个酒鬼老师,一个社区警察,最后都以离婚告终.整个故事并没有太多波澜,平淡地描述了成长叛逆的过程,年少时对外部世界的懵懂,对自我认知的探索,对未知旅程的激动而紧张。
 电影对我触动的几点.
 15岁生日时家人精心准备的礼物,第一张披头士专辑,第一把猎枪,第一件西装,第一次进教堂.傍晚一家人在木屋前轻声吟唱父亲创作的歌曲.
 梅森学会摄影后觉得自己很特别,所以就呆在暗室里逃避功课，老师对他说了一番话，你交上的摄影作品很不错,看待事物的方式也很特别,但是这个世界天赋异禀的人很多，单靠天赋你只能在咖啡馆里喝一杯咖啡.一个不自律没有决心，没有职业道德的情况下做出成就的我还没见过,然后老师给梅森抛出了两个经典的问题: what are you want to be? what are you want to do ? 梅森说:我想要拍照,想要搞艺术,老师又问:谁都可以拍照搞艺术,但是凭什么你能能更出众呢?
 高中毕业后,漂亮女友劈腿,父亲在酒吧安慰他:女人永远都不会满足,总在寻找更好的男人,不要在一棵树人吊死,专注于让自己更优秀,然后欲女们才会蠢蠢欲动任你挑选了,生活中我们都是在即兴表演,要用心去感受,当你越长越大时候外壳会变得越来越坚硬,这种触觉会越来越不灵敏.
 在饭店吃饭时碰到以前的在他家工作过的水管工,母亲之前建议小伙子去读社区学校,然后他真的去了而且拿到了学位,换了一份不错的工作.母亲有点唏嘘,有时候一些建议真的能改变一个人的轨迹.
 毕业后要离开家,梅森讲着新舍友的事情,母亲终于爆发了:我想起了我的一个个人生的里程碑,结婚,生子,离婚.以为你有阅读障碍,教你骑自行车,然后再次离婚,终于获得了学位找到了心仪的工作,送你姐上大学,再送你上大学,下个里程碑就是我的葬礼,我以为人生会有更多. 看完电影又看了一下幕后,导演是Richard Linklater,这部电影耗时12年,片中的梅森的姐姐就是导演的女儿,每次拍戏都是利用主角Ellar Coltrane假期时间来完成.主角口述一下这一年发生了什么,然后导演将他改造写成剧本.这是一部相当纪实的电影,包括片中母亲的离异,再结婚也是根据主角的亲身经历改编的。
  少年斯派维的奇异旅行(L&amp;rsquo;extravagant voyage du jeune et prodigieux T.S. Spivet) 这个剧本是少年冒险的题材，斯派维从小出生在一个奇怪的家庭组织里,妈妈是个生物科学家,爸爸是狂热的的牛仔,小斯派维酷爱科学和图解.斯派维本来有一个异卵双胞胎弟弟雷顿,比起斯派维,父亲更喜欢弟弟雷顿,因为弟弟更有牛仔的天赋,喜欢练枪打土狼,但是弟弟在一场意外里死掉了,然后这就成了全家人的心病,没人再提起过它,这也成为斯派维不受待见的原因之一.
 一年前,在一场关于永动机的观影课堂上,教授说,基本热学理论认为所有的机械最终都会处于静止状态，有学生提问,永远机在现有的科学基础上交给空想家和诗人比较合适,教授反驳,那些突破想象超越科学极限的人不也叫诗人吗？正是这样开放的科学态度让斯派维备受鼓舞,课堂结束后小斯派维握紧小手郑重其事地对教授说:我是来自蒙大拿州的斯派维,我接受制造永动机的挑战.虽然教授只是拍拍他的头微微一笑,但斯派维却把这个当作了一项事业.
 第二前八月份的时候,斯派维接到了一个电话,自己的磁力轮设计稿获取了斯宾塞贝尔德奖,他假装父亲是个哑巴,然后自己和史密森学院的副干事通话,因为没人会相信是一个10岁的小屁孩设计了磁力轮.
 斯派维犹豫再三最终决定一个人去纽约去接受这个奖项,对于一个10岁的少年来说这是一个艰难的决定,打包行李,给家人写一封离别信,用小拖车拖着自己笨重的行李箱上路了,机智的斯派维把火车的信号灯涂成了红色蹭上了货运列车,旅途的风景让斯派维很兴奋,有成林的树木,清澈的河流,一望无际的沙漠,风格各异的建筑,血色一样的天空,但是现实的问题也随即而来,食物吃完了在货运列车上的生存成了问题.幸运的是他遇到了一个流浪汉,流浪给他一些硬币去买热狗,吃完热狗后看着窗外的夜色,斯派维思绪万千,我不是一个无忧无虑的漂泊者,我只是一个离家出走的10岁小孩.
 虽然旅途不易,经历了警察的追捕,身体受伤,但斯派维还是搭上怪叔叔的大货车到达史密森学院,但是斯派维却被学院的副干事包装经历,成了舆论上的小茶点,出入各种show,而没人在意这个小少年真正想要说的,斯派维在演讲上最后还是讲起了弟弟雷顿意外死亡的故事,母亲在场外默默地听着独自流泪,因为弟弟的死亡母亲一度扎在寻找不存在的昆虫这项研究来掩盖伤痛,而忽视了现实中还存在的家庭.
 斯派维最终被父母接回了家,他妈妈又怀了一个小baby,父亲还是一个纯粹的牛仔,但是家庭气氛却和睦起来，母亲不再沉迷在她的昆虫世界里,片尾的时候斯派维的永动机设计被用来摇婴儿床.
 忠犬八公的故事(Hachi: A Dog&amp;rsquo;s Tale)
 夏日之王 (The Kings of Summer )
 天堂真的存在 (Heaven is for Real )
 独立游戏大电影 (Indie Game: The Movie)
 银河护卫队(Guardians of the Galaxy)
 苹果核战记(阿尔法 Appleseed Alpha)
 夺命地铁 (Метро)
 消失的爱人 (Gone Girl)
</content>
    </entry>
    
     <entry>
        <title>游戏数值修改器</title>
        <url>https://farwmarth.com/post/%E6%B8%B8%E6%88%8F%E6%95%B0%E5%80%BC%E4%BF%AE%E6%94%B9%E5%99%A8/</url>
        <categories>
          <category>教你瞎折腾</category>
        </categories>
        <tags>
          <tag>数值修改</tag>
        </tags>
        <content type="html"> Windows:  金山游侠: 变速齿轮: flash修改大师 :http://www.cordyblog.cn/  Android:  手机游侠 游戏金手指 八门神器(GameKiller): 烧饼修改器: 葫芦侠修改器:  IOS:  八门神器(GamePlayer): 烧饼修改器:  数值修改器用法大同小异,先打开游戏查看原数值如1200,用修改器搜索该数值1200,返回游戏消费,使数值改变,如花费后数值为1100,再到修改器搜索1100,这样循环就可以定位到数值的内存地址了,然后直接用修改器修改该内存地址的值就可以了.注意的是修改值别超过了游戏中的上限.
</content>
    </entry>
    
     <entry>
        <title>广告拦截指南</title>
        <url>https://farwmarth.com/post/%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA%E6%8C%87%E5%8D%97/</url>
        <categories>
          <category>教你瞎折腾</category>
        </categories>
        <tags>
          <tag>广告</tag>
        </tags>
        <content type="html"> 一 windows : 1. chrome插件:  广告终结者 (好像是抄袭的adblock ) 视频广告终结者 adblock adblock plus 小猪广告杀手 小黄瓜视频广告拦截 Adguard 广告拦截器  ADfree.Player.Online   2. 客户端:  adsafe admon 阿呆喵 广告助手 广告屏蔽大师 路由优化大师 广告拜拜 奇式网盾 天行广告防火墙 菠萝净化大师 vablocker  二 android:  adblockplus adsafe 天行广告防火墙  三 ios :  flex2 (越狱插件)  四 pac: http://ad.farwmarth.com/ad.js</content>
    </entry>
    
     <entry>
        <title>翻墙有术</title>
        <url>https://farwmarth.com/post/%E7%BF%BB%E5%A2%99%E6%9C%89%E6%9C%AF/</url>
        <categories>
          <category>教你瞎折腾</category>
        </categories>
        <tags>
          <tag>翻墙</tag>
        </tags>
        <content type="html"> 在天朝,难免要翻翻墙，看看墙外的世界.
网盘里上传了墙外需要的一些应用instagram,facebook,twitter,youtube,google&#43;还有一些翻墙道具,国外的不用翻墙的商店,现在大都是android应用 .
百度,115,360,乐视网盘,金山快盘都有敏感字限制,有些应用上传不了,所以找了个无限制的网盘:https://jianguoyun.com/p/DZwoJSEQ8MfmBRiUpgo
翻墙术 Chrome插件:
  时空隧道: http://www.suidao.in/  Windows
  HostTool : https://hosts.huhamhire.com/  自由门 :http://dongtaiwang.com/loc/download.php  无界浏览: http://wujieliulan.com/ (https://s3.amazonaws.com/xiazai/u.zip)  天行浏览器  GreenVpn : http://www.greenjsq.info/  Android:
  ShadowSocks : https://play.google.com/store/apps/details?id=com.github.shadowsocks  教程就不帖了:上张手机的图对应填写就可以了

 翻墙路由器(Fqrouter2):https://play.google.com/store/apps/details?id=fq.router2 赛风(Psiphon) : https://play.google.com/store/apps/details?id=com.psiphon3 Zero VPN : https://play.google.com/store/apps/details?id=net.tntapp.app.zerovpn SpeedVPN : https://play.google.com/store/apps/details?id=us.gospeed.speedvpn Hola: https://play.google.com/store/apps/details?id=org.hola Hosts同步 : https://play.google.com/store/apps/details?id=net.wszf.client.synchost SmartHosts: https://play.google.com/store/apps/details?id=mobi.smarthosts 自由门: http://dongtaiwang.com/loc/download.php 无界一点通:https://s3.amazonaws.com/xiazai/um.apk  Google Play 一 电脑下载google play android应用  hosttool工具使https://play.google.com/store可以访问 搜索要下载的应用:如instagram,url为https://play.google.com/store/apps/details?id=com.instagram.android ,id后面为应用的包名 打开http://apps.evozi.com/apk-downloader/网站,将包名或者googleplay上完整的网址输入到搜索框，点击Generate Download Link 按钮，生成链接后点击click here to download xxx now 下载即可. 另外一种方式比较麻烦，需要输入gooogle的账户和设备id.详情:http://www.appinn.com/apk-downloader/  如果两种方式都觉得麻烦，可以从国外的android应用市场上下载下来,但不能保证应用是最新版本，推荐几个网站:
 http://www.1mobile.com/  [http://www.hiapphere.org/ , ](http://www.hiapphere.org/ , http://www.bestappsmarket.com/ &amp;ldquo;http://www.hiapphere.org/&amp;quot;) http://www.bestappsmarket.com/  Instagram  电脑看instagram,无需翻墙 http://pinsta.me/ 连接你的instagram账号就可以看到你的instagram关注的人了，当然图片也可以下载了 android下载instagram图片  下载android应用Instadownloader : http://www.eagleget.com/apps/apk-file/8783/,注意在googleplay上的这个应用已经下架了。也可以在豌豆荚上下载. 在instagram打开一张图片,拖动到右下角有个…的按钮，点击复制共享链接.  打开Instadownloader,粘贴复制的链接，下载.   </content>
    </entry>
    
     <entry>
        <title>ubuntu 终端终结者</title>
        <url>https://farwmarth.com/post/-ubuntu-%E7%BB%88%E7%AB%AF%E7%BB%88%E7%BB%93%E8%80%85/</url>
        <categories>
          <category>ubuntu</category>
        </categories>
        <tags>
          <tag>终端</tag>
        </tags>
        <content type="html"> 在linux中经常要在多个终端界面间切换，于是就找了下终端管理的方法。
一 screen命令 screen命令是ubuntu自带的.查看screen是否安装可以用如下命令:
[root@tivf06 ~]# rpm -qa|grep screenxscreensaver-4.18-5.rhel4.11**screen-4.0.2-5**查看screen用法可以用:man screen screen命令可以新建一个会话，在会话中又可以建立多个窗口，多个窗口中用快捷键切换. 下面是screen的基础用法
 screen : 新建会话 screen –S [会话名] :给会话取名字，这个名字在 screen –x 恢复会话时可用. screen –ls : 列出所有的会话列表 screen –r [会话id] : 以id恢复会话,会话id在 -ls中可以查看到 screen –x [会话名或索引值]:以名字和索引恢复会话. screen –d [会话名] :中断会话.中断会话还可以这样:在会话中按ctrl&#43;a,d可以中断会话，用screen –r 或-x来恢复  在会话模式下的基础操作.
 ctrl&#43;a,c : 开启一个新的窗口 ctrl&#43;a,n :切换到下一个窗口 ctrl&#43;a,p: 切换到前一个窗口 ctrl&#43;a,0..9:数字键切换窗口 ctrl&#43;a,space :顺序循环切换窗口 ctrl&#43;a,ctrl&#43;a:在最近使用的两个窗口中切换 ctrl&#43;a,[:回滚,可滑动模式 &#43; ctrl&#43;a,A :可窗口改名 ctrl&#43;a,w: 显示所有窗口 &#43; ctrl&#43;a,k:关闭当前窗口，如果只有一个窗口会中止当前会话  screen除了管理多终端外，还有一个功能就是ssh退出后能保持程序继续运行。替代nohup命令.
二 Terminator terminator不是基于会话模式的，它只是终端的增强版本，将多个终端平铺在一个界面中。可以自由地增加终端窗口.安装很简单，直接:sudo apt-get install terminator就可以了。
 Ctrl&#43;Shift&#43;O: 上下开新窗口 Ctrl&#43;Shift&#43;E： 左右开新窗口  Ctrl&#43;Shift&#43;Right,Left,Up,Down:扩展窗口 Ctrl&#43;Shift&#43;S：隐藏滚动条 Ctrl&#43;Shift&#43;F：查找 Ctrl&#43;Shift&#43;P or Ctrl&#43;Shift&#43;N: 按序号切换窗口 Alt&#43;Right,Left,Up,Down: 按方向 切换窗口 Ctrl&#43;Shift&#43;C :复制选中文字 Ctrl&#43;Shift&#43;V:粘贴 Ctrl&#43;Shift&#43;W:关闭当前窗口 Ctrl&#43;Shift&#43;Q:退出 Ctrl&#43;Shift&#43;X 最大化当前窗口 Ctrl&#43;Shift&#43;T :新建标签页  设置启动后切换到默认路径 </content>
    </entry>
    
     <entry>
        <title>游戏SDK接入的一些总结</title>
        <url>https://farwmarth.com/post/%E6%B8%B8%E6%88%8Fsdk%E6%8E%A5%E5%85%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
        <categories>
          <category>cocos2d-x</category>
        </categories>
        <tags>
          <tag>SDK</tag>
        </tags>
        <content type="html"> update: 2016-04-23 ysdk 概念 首先来澄清两个概念:
 CP:Content Provider,中文翻译为内容提供商。通常指制作厂商 游戏sdk: SDK是手游渠道提供的、集成了用户登录、充值通道、社区功能、社交分享功能、数据后台统计功能的一个功能模块  游戏SDK作为游戏制作方来说是一个很蛋疼的过程，因为接入的流程过于冗长,首先商务要出去抱渠道大腿,叫大爷多导点量,洽谈完毕后给一个可游戏的游戏版本给渠道方去测评分级,如果评分级别太低的话,你的游戏就over了,评级如果是A及A以上的话渠道就会乐呵呵地给你的产品分配资源.分配标识key,文档,sdk,接着就是商务通知运营建立讨论组，把双方的技术运营拉进来开始接入,接入完成后让运营在渠道后台上传包，渠道QA测试完成如果没问题就给予上线，如果不符合标准就是返工改bug然后继续上传审核的过程。
SDK接入另一个开销成本就是接入的渠道数量众多，SDK的繁杂程度和文档完美度也参数不齐，有的渠道一天就可以接完调试。有的渠道有花上两三天。所以在刚开始要接大量渠道时也去找过第三方的接入服务.
 anysdk(http://www.anysdk.com/): 触控旗下的SDK接入服务 棱镜(http://www.ljsdk.com/):一家从发行转型做第三方SDK接入的平台 云接入(http://www.allsdk.com/) :斯凯投资的云接入 易接入(http://www.1sdk.cn/) :雪鲤鱼科技  这几家第三方的服务共同特点是统一了各渠道的服务接口，但是cp的游戏数据都会记录在第三方服务商的数据库中。这点对于游戏厂商来说是很第敏感的一点，还有一点就是如果采用第三方接入就会依赖于他们的服务，如果第三方接入服务崩溃的话会导致游戏厂商的游戏不能正常运行。这是很大的安全隐患。
我们游戏总共接入了18个渠道，android上14个，ios上4个。各个渠道通用的接入功能是登录和充值。还有几个渠道需要接入游戏数据提交功能(登录时候将游戏角色,等级，余额，所在区，所在服数据提交到渠道接口).
一般流程 登录流程 
支付流程 
sdk接入主要工作分为两部分
 在游戏客户端的sdk接入代码
游戏客户端启动基本过程为:显示logo画面--&amp;gt;初始化SDK----&amp;gt;检测游戏更新---&amp;gt;显示SDK登录界面----&amp;gt;选服. 应用服务器的校验过程  ysdk 常见问题 接入sdk容易出现的问题:
 svn默认不上传so文件，银联支付需要so打包时候导致无法正常银联支付. android上登录或者注册过程中按退出键关闭了页面未重新打开 打开sdk页面时游戏黑屏 游戏退出时没有调用注销接口 未接入退出游戏，个人中心，浮标 角标和logo不符合规则或者带有外链 充值后没有立即到账 </content>
    </entry>
    
     <entry>
        <title>代码加密,渠道打包过程</title>
        <url>https://farwmarth.com/post/%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/</url>
        <categories>
          <category>cocos2d-x</category>
        </categories>
        <tags>
          <tag>cocos2d-x</tag>
        </tags>
        <content type="html"> 前段时间就计划着把项目里用到的一些通用的东西整理出来，正好最近项目不是太忙，就整理一下。
lua代码加密  我们的项目是基于cocos2dx 2.2.2 用lua开发,支持luajit,所以lua代码加密就把quick-cocos2dx的代码加密直接迁移过来(实际上就是用luajit把lua源码编译成预字节码)
调用compile_script.sh 参数说明:
-i 在加密的lua源码目录 -o 加密后的压缩包 -x 排除的lua文件用逗号隔开.
c&#43;&#43;端的解析流程和quick大同小异:解析zip压缩包,用pakcage.preload通过lua_loadbuffer来不原。唯一有点不一样的地方是.多级目录时luajit会以点号分隔,但是我们的项目做了一段时间才做加密，所以在不不改变require的引用 语法前提下，稍微修改了一下还原步骤,将’.’还原成’/&amp;rsquo;
渠道打包 需要跨平台我选择了python作为脚本。打包流程基本流程为:
 加密lua代码 android平台编译so,或者从svn获取最新的so Android平台拷贝资源到assets,iOS平台拷贝到编译目录 android平台上调用ant更改版本号编译项目,ios上用PlistBuddy更改版本号,用xctool命令行编译项目  项目目录结构
每个渠道一个目录,Classes目录为公共c&#43;&#43;代码,各平台共用.proj.android.base目录为android的基础类库依赖libcocos2dx的java工程,基础类库给各android渠道项目共用,proj.ios.common为oc公共代码给iOS各渠道项目共用。
android平台的编译和打包解析
** 基础类库mk配置**
为了共用代码将so编译放在基础类库proj.android.base中.mk配置如下
LOCAL_PATH := $(call my-dir)include$(CLEAR_VARS)LOCAL_MODULE := cocos2dlua_sharedLOCAL_MODULE_FILENAME := libcocos2dlua# 配置自己的源文件目录和源文件后缀名MY_FILES_PATH := $(LOCAL_PATH) \ $(LOCAL_PATH)/../../Classes \ MY_FILES_SUFFIX := %.cpp %.c# 递归遍历目录下的所有的文件rwildcard=$(wildcard $1$2)$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2))# 获取相应的源文件MY_ALL_FILES := $(foreach src_path,$(MY_FILES_PATH), $(call rwildcard,$(src_path),*.*) ) MY_ALL_FILES := $(MY_ALL_FILES:$(MY_CPP_PATH)/./%=$(MY_CPP_PATH)%)MY_SRC_LIST := $(filter $(MY_FILES_SUFFIX),$(MY_ALL_FILES)) MY_SRC_LIST := $(MY_SRC_LIST:$(LOCAL_PATH)/%=%)# 去除字串的重复单词define uniq =$(eval seen :=)$(foreach _,$1,$(if $(filter $_,${seen}),,$(eval seen &#43;= $_)))${seen}endef# 递归遍历获取所有目录MY_ALL_DIRS := $(dir $(foreach src_path,$(MY_FILES_PATH), $(call rwildcard,$(src_path),*/) ) )MY_ALL_DIRS := $(call uniq,$(MY_ALL_DIRS))# 赋值给NDK编译系统LOCAL_SRC_FILES := $(MY_SRC_LIST)LOCAL_C_INCLUDES := $(MY_ALL_DIRS)#$(warning $(LOCAL_SRC_FILES))LOCAL_STATIC_LIBRARIES := curl_static_prebuiltLOCAL_WHOLE_STATIC_LIBRARIES := cocos2dx_staticLOCAL_WHOLE_STATIC_LIBRARIES &#43;= cocosdenshion_staticLOCAL_WHOLE_STATIC_LIBRARIES &#43;= cocos_lua_staticLOCAL_WHOLE_STATIC_LIBRARIES &#43;= box2d_staticLOCAL_WHOLE_STATIC_LIBRARIES &#43;= chipmunk_staticLOCAL_WHOLE_STATIC_LIBRARIES &#43;= cocos_extension_staticinclude$(BUILD_SHARED_LIBRARY)$(call import-module,cocos2dx)$(call import-module,CocosDenshion/android)$(call import-module,scripting/lua/proj.android)$(call import-module,cocos2dx/platform/third_party/android/prebuilt/libcurl)$(call import-module,extensions)$(call import-module,external/Box2D)$(call import-module,external/chipmunk)上面的配置会遍历项目jni目录和项目上级的classes目录达到自动添加cpp和.h的目的,这样不要频繁去理发mk文件了。
** android项目的编译过程**
  首先.aidl(Android Interface Description Language)文件需要通过aidl工具转换成编译器能处理的Java接口文件 同时资源文件将被aapt (Asset Packaging Tool)处理为最终的resources.arsc，并生成R.java文件以使源码可以方便地访问到这些资源 Java的编译器将R.java, Java源码以及上述生成的接口文件统一编译成.class文件 不过.class并不是Android系统所能识别的格式，因而还要利用dex工具转化为Dalvik字节码。这其中还会加入所有需要的第三方库等文件 接下来系统将上面生成的dex，资源包，以及其它资源通过apkbuilder生成初始的apk文件包。这时还没有签名和优化 签名可以用Jarsigner，也可以用其它类似的工具。如果是在Debug模式下，所签名所用的keystore就是系统默认自带的，否则开发者需要提供自己的私钥以完成签名过程 最后一步，将上述签名后的apk通过zipalign进行优化，以提高加载和运行速度。大概原理是通过对其中包含的相关数据进行边界对齐，来加快读取和处理。这也同时解释了其名称&amp;quot;zip&amp;quot;&#43;&amp;quot;align”的由来   好在android sdk tools中已经将ant编译脚本写好了，只要直接调用就可以了。
 项目中build.xml内容,这里只定义了一个target，在编译完成后在手机上自动运行一个app，此build.xml在能用的python脚本里会调用
&amp;lt;?xmlversion=&amp;#34;1.0&amp;#34;encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&amp;lt;projectname=&amp;#34;sanguo&amp;#34;default=&amp;#34;sanguoBuildAll&amp;#34;&amp;gt;&amp;lt;propertyfile=&amp;#34;ant.properties&amp;#34;/&amp;gt;&amp;lt;loadpropertiessrcFile=&amp;#34;project.properties&amp;#34;/&amp;gt;&amp;lt;targetname=&amp;#34;apkBuildBefore&amp;#34;&amp;gt;&amp;lt;echomessage=&amp;#34;apk build before ....&amp;#34;/&amp;gt;&amp;lt;/target&amp;gt;&amp;lt;targetname=&amp;#34;runApp&amp;#34;&amp;gt;&amp;lt;execexecutable=&amp;#34;adb&amp;#34; &amp;gt;&amp;lt;argline=&amp;#34;shell am start -n com.sanguo.game.uc/com.sanguo.game.uc.sanguo&amp;#34;/&amp;gt;&amp;lt;/exec&amp;gt;&amp;lt;/target&amp;gt;&amp;lt;propertyname=&amp;#34;common.buildxml&amp;#34;location=&amp;#34;../tools/build/build_common_android.xml&amp;#34;/&amp;gt;&amp;lt;!--导入共用build--&amp;gt;&amp;lt;importfile=&amp;#34;${common.buildxml}&amp;#34;/&amp;gt;&amp;lt;/project&amp;gt;tools目录中公用的build_common_android.xml内容,些ant主要任务是替换版本号(用到了xmltask库),编译android项目并运行.
&amp;lt;?xmlversion=&amp;#34;1.0&amp;#34;encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&amp;lt;projectname=&amp;#34;commonBuild&amp;#34;&amp;gt;&amp;lt;taskdefname=&amp;#34;xmltask&amp;#34;classname=&amp;#34;com.oopsconsultancy.xmltask.ant.XmlTask&amp;#34;/&amp;gt;&amp;lt;propertyenvironment=&amp;#34;env&amp;#34;/&amp;gt;&amp;lt;!--&amp;lt;property name=&amp;#34;project.versionname&amp;#34; value=&amp;#34;1&amp;#34; /&amp;gt;&amp;lt;property name=&amp;#34;project.versioncode&amp;#34; value=&amp;#34;1&amp;#34; /&amp;gt;--&amp;gt;&amp;lt;propertyname=&amp;#34;manifest.file&amp;#34;location=&amp;#34;${basedir}/AndroidManifest.xml&amp;#34;/&amp;gt;&amp;lt;echomessage=&amp;#34;build project path is : ${basedir}&amp;#34;/&amp;gt;&amp;lt;echomessage=&amp;#34;AndroidManifest.xml path is : ${manifest.file}&amp;#34;/&amp;gt;&amp;lt;conditionproperty=&amp;#34;sdk.dir&amp;#34;value=&amp;#34;${env.ANDROID_HOME}&amp;#34;&amp;gt;&amp;lt;issetproperty=&amp;#34;env.ANDROID_HOME&amp;#34;/&amp;gt;&amp;lt;/condition&amp;gt;&amp;lt;failmessage=&amp;#34;sdk.dir missing, please config ANDROID_HOME environment variable.&amp;#34;unless=&amp;#34;sdk.dir&amp;#34; /&amp;gt;&amp;lt;!--完整编译--&amp;gt;&amp;lt;targetname=&amp;#34;sanguoBuildAll&amp;#34;depends=&amp;#34;sanguoBuildNotInstall,intallSanguo&amp;#34;description=&amp;#34;install sanguo application&amp;#34;/&amp;gt;&amp;lt;!--完整编译但是不安装--&amp;gt;&amp;lt;targetname=&amp;#34;sanguoBuildNotInstall&amp;#34;depends=&amp;#34;replace_manifest,apkBuildBefore,clean,release&amp;#34;description=&amp;#34;install sanguo application&amp;#34;/&amp;gt;&amp;lt;!--安装并运行--&amp;gt;&amp;lt;targetname=&amp;#34;intallSanguo&amp;#34;depends=&amp;#34;installr,runApp&amp;#34;description=&amp;#34;install sanguo application&amp;#34;/&amp;gt;&amp;lt;!--替换版本--&amp;gt;&amp;lt;targetname=&amp;#34;replace_manifest_check&amp;#34;&amp;gt;&amp;lt;conditionproperty=&amp;#34;has.version&amp;#34;&amp;gt;&amp;lt;issetproperty=&amp;#34;project.versionname&amp;#34;/&amp;gt;&amp;lt;/condition&amp;gt;&amp;lt;/target&amp;gt;&amp;lt;targetname=&amp;#34;replace_manifest&amp;#34;if=&amp;#34;has.version&amp;#34;depends=&amp;#34;replace_manifest_check&amp;#34;&amp;gt;&amp;lt;xmltasksource=&amp;#34;${manifest.file}&amp;#34;dest=&amp;#34;${manifest.file}&amp;#34;encoding=&amp;#34;utf-8&amp;#34;&amp;gt;&amp;lt;attrpath=&amp;#34;//manifest&amp;#34;attr=&amp;#34;android:versionName&amp;#34;value=&amp;#34;${project.versionname}&amp;#34;/&amp;gt;&amp;lt;attrpath=&amp;#34;//manifest&amp;#34;attr=&amp;#34;android:versionCode&amp;#34;value=&amp;#34;${project.versioncode}&amp;#34;/&amp;gt;&amp;lt;/xmltask&amp;gt;&amp;lt;echomessage=&amp;#34;new version is: ${project.versionname} , ${project.versioncode}&amp;#34;/&amp;gt;&amp;lt;echomessage=&amp;#34;replace_manifest version code success ....&amp;#34;/&amp;gt;&amp;lt;/target&amp;gt;&amp;lt;importfile=&amp;#34;${sdk.dir}/tools/ant/build.xml&amp;#34;/&amp;gt;&amp;lt;/project&amp;gt;IOS项目的编译过程
xcode打包过程
  编译源文件（Compile Sources）连接二进制文件和库（Link Binary With Libraries）
这个阶段编译所有的源文件；默认情况下，项目中添加任何一个源文件，也将添加到编译列表中。
Compile Sources 构建阶段分为两步：预处理（Preprocessing）和编译（Compiling）。
预处理（Preprocessing）
的目标是为每一个实现文件（.m）创建中间文件（intermediate file）。中间文件仍然类似实现文件的Objective-C代码，但是中间文件会变得非常大。
在创建中间文件时，预处理器负责处理实现文件（.m）中所有的预处理指令（preprocessor directives）。预处理指令是所有以 # 开头的语句，如 #import。#import 语句将替换为实际引用文件的内容。
例如，一个实现文件 .m 引用了.h 头文件；为 .m 创建的中间文件将包含 .h和 .m文件。还不止这些，并且 .h 头文件引用了其他 2 个文件 UIKit.h和CoreLocation.h，还有可能这 2 个文件引用了其他的头文件 .h，这些头文件将全部包含在该实现文件.m 创建的中间文件中（intermediate file）。
编译（Compiling）
一旦预编译（Preprocessor）完成之后，接着编译生成的中间文件（intermediate files），编译中间文件 – Objective-C 代码，生成机器码（machine code）。机器码存放在对象文件（object file）中，一个中间文件对应一个对象文件。
编译阶段，也就是将Objective代码文件转为机器码，将检测多数编译错误。当编译器不理解我们编写的代码时，将报错。我们称之为编译错误或语法错误。
连接（Linking）
编译生成的对象文件（object file）包含了实现文件（implementation file）的机器码。在一个实现文件中，可以调用其他实现文件的方法。此时，并不会将其他实现文件的代码复制到本实现文件中，而是连接其他实现文件。连接二进制文件和库（Link Binary With Libraries）就是负责此项任务，我们简称连接阶段（linking phase）。
  复制绑定资源（Copy Bundle Resources）
在源文件编译和连接库之后，创建一个可执行文件，并放置在应用程序的绑定中，其实就是一个文件夹。
其中资源文件将和可执行文件一起添加到绑定（bundle）中。这些资源文件是数据文件，应用程序在运行时需要使用，如XIB 文件和图像文件、声音文件等等。
默认情况下，添加到项目中的文件，如不是源代码文件，将添加到这个构建阶段（Build Phase）。
如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化(如果build settings中的PNG优化是打开的)
  运行指定脚本 如果在build phases 下指定了run Script,在这里会运行脚本。 我在项目中的脚本内容如下
  _TARGET_BUILD_CONTENTS_PATH=$TARGET_BUILD_DIR/$CONTENTS_FOLDER_PATHecho Target Path: $_TARGET_BUILD_CONTENTS_PATHBUILD_PATH=${PWD}/../tools/build/build_native.pypython $BUILD_PATH -c 2 -w 0 -o $_TARGET_BUILD_CONTENTS_PATH 打包签名 调用command tools打包签名  脚本打包
脚本打包一般采用xcodebuild和xcrun.
这里在github中有一个用它打包的shell库,包括了打包上传邮件通知，功能比较完整(https://github.com/webfrogs/xcode_shell)
xcodebuild这种打包方式缺点是编译过程中输出太不人性化，难以查看，所以我找了facebook开源的的一个打包的库xctool.
打包脚本build_ipa_all.sh如下
#!/bin/bash#--------------------------------------------# 功能：编译xcode项目并打ipa包# 使用说明：# 编译workspace#build_ipa_all proj.ios#sanguo:proj.ios.pp#sanguopp:proj.ios_91#sangup91 140902# 作者：farwmarth# E-mail:[wujiyu115@gmail.com](mailto:wujiyu115@gmail.com)# 创建日期：2014-09-23 15:17:19#--------------------------------------------#build前清除之前的目录clean_app_build_dic=true#是否只通过*.app来生成ipaonly_packge_ipa=false##############配置工程目录和scheme名称,scheme名称要和xcodeproj一致,用空格隔开##############要打包的项目project_config=$1#新版本new_version_code=$2#去空格new_version_code=$(echo $new_version_code)if [[ ! $new_version_code =~ ^[0-9]&#43;$ ]] || [ ${#new_version_code} -ne 6 ] ; thenecho new_version_code is not number or the length is not sixexit2fi################################str_dic=&amp;#34;&amp;#34;str_scheme=&amp;#34;&amp;#34;for item in $(echo $project_config | tr &amp;#34;:&amp;#34; &amp;#34;\n&amp;#34;)docount=1for config in $(echo $item | tr &amp;#34;#&amp;#34; &amp;#34;\n&amp;#34;)do# echo $countif [ $count = 1 ];thenstr_dic=$str_dic&amp;#34; &amp;#34;$configfiif [ $count = 2 ] ;thenstr_scheme=$str_scheme&amp;#34; &amp;#34;$configfilet &amp;#34;count&#43;&#43;&amp;#34;donedoneecho $str_dicecho $str_schemedicArray=($str_dic)schemeArray=($str_scheme)# exit 0#############安装brew 和xctool#############if which brew 2&amp;amp;gt;/dev/null; thenecho &amp;#34;brew exists!&amp;#34;elseecho &amp;#34;nope, no brew installed, begin install&amp;#34;curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1fiif which xctool&amp;amp;gt;/dev/null; thenecho &amp;#34;xctool exists!&amp;#34;elseecho &amp;#34;nope, no xctool installed, begin install&amp;#34;sudo brew updatesudo brew install xctoolfi# xctool -scheme sanguopp -reporter plain:log.txt archive -archivePath ./xctoolBuild#############批量打包应用#############dic_count=${#dicArray[@]}scheme_count=${#schemeArray[@]}if [ dic_count!=0 ] &amp;amp;amp;&amp;amp;amp; [ $dic_count != $scheme_count ] ; thenecho &amp;#34;dic count not equesl scheme count!&amp;#34;exit2fibuild_path=$(pwd)ios_build_path=$build_path/releaseIpasios_ipa_build_path=$build_path/releaseIpas/ipabuildif [ $clean_app_build_dic ] &amp;amp;amp;&amp;amp;amp; [ -d $ios_build_path ]; thenrm -rf $ios_build_pathfiif [ ! -d $ios_ipa_build_path ] ; thenmkdir -p $ios_ipa_build_pathfifunction replace_info_list(){app_infoplist_path=$1schemeName=$2#取版本号bundleShortVersion=$(/usr/libexec/PlistBuddy -c &amp;#34;print CFBundleShortVersionString&amp;#34; ${app_infoplist_path})#取build值bundleVersion=$(/usr/libexec/PlistBuddy -c &amp;#34;print CFBundleVersion&amp;#34; ${app_infoplist_path})hasPoint=falsetemp_version_code=$new_version_codeif [[ $bundleShortVersion =~ &amp;#34;.&amp;#34; ]];thenhasPoint=trueelsehasPoint=falsefiif [ &amp;#34;$hasPoint&amp;#34; == true ]; thentemp_version_code=$(echo $temp_version_code|awk &amp;#39;BEGIN{FS=&amp;#34;&amp;#34;}{print $1$2&amp;#34;.&amp;#34;$3$4&amp;#34;.&amp;#34;$5$6}&amp;#39;)fiecho $schemeName old CFBundleShortVersionString,CFBundleVersion is: $bundleShortVersion , $bundleVersionecho $schemeName ipa new_version_code is: $temp_version_code/usr/libexec/Plistbuddy -c &amp;#34;Set CFBundleVersion $temp_version_code&amp;#34;&amp;#34;${app_infoplist_path}&amp;#34;/usr/libexec/Plistbuddy -c &amp;#34;Set CFBundleShortVersionString $temp_version_code&amp;#34;&amp;#34;${app_infoplist_path}&amp;#34;}function build_release(){schemeName=$2project_path=$1/$scheme&amp;#34;.xcodeproj&amp;#34;#app文件中Info.plist文件路径app_infoplist_path=$1/Info.plist#ipa名称ipa_name=$schemeName&amp;#34;_&amp;#34;$(date &#43;&amp;#34;%Y%m%d&amp;#34;)#scheme路径target_ios_build_path=$ios_build_path/$schemeName#生成.app的路径target_ios_app_path=$target_ios_build_path&amp;#34;.xcarchive/Products/Applications/*.app&amp;#34;#发布的ipa路径ipa_publish_path=$ios_ipa_build_path/${ipa_name}.ipareplace_info_list $app_infoplist_path $schemeNameif [ &amp;#34;$only_packge_ipa&amp;#34; == false ] ; thenecho xctool build begin...xctool -project $project_path -scheme $schemeName cleanxctool -project $project_path -scheme $schemeName archive -archivePath $target_ios_build_pathfiif [ -d $target_ios_app_path ] ; thenxcrun -sdk iphoneos PackageApplication -v $target_ios_app_path -o $ipa_publish_pathfi}for (( i=0;i&amp;amp;lt;$dic_count;i=i&#43;1))dodic=${dicArray[$i]}scheme=${schemeArray[$i]}p_path=../../$dicif [ -d $p_path ] ; thenbuild_release $p_path $schemeelseecho &amp;#34;this project is not exists :&amp;#34;$p_pathfidone脚本使用方法 build_ipa_all proj.ios#sanguo:proj.ios.pp#sanguopp:proj.ios_91#sangup91 140902 第一个参数:工程目录名#要编译的scheme名:工程目录名#要编译的scheme名 第二个参数:新版本名 如果没有xctool，脚本会自动安装,然后调用PlistBuddy替换版本号，然后调用xctool打包。 编译所有ios项目的脚本build_ipa_all.sh:
#!/bin/bashnewVersion=140902allproj=&amp;#39;proj.ios#sanguo:proj.ios.pp#sanguopp:proj.ios_91#sanguo91:proj.ios_xy#sanguoXY&amp;#39;python build_native.py -c 2 -w 0. ./build_common_ipa.sh $allproj $newVersion  最后来看下android和iOS公用的python脚本build_native.py: # -*- coding: utf-8 -*- #!/usr/bin/python # build_native.py # Build native codes #-------------------------------------------- # 功能：加密处理资源 # 使用说明： # &amp;#39;-c&amp;#39;, &amp;#39;--compiler_platform&amp;#39;, dest=&amp;#39;compiler_platform&amp;#39;, help=&amp;#39;编译android用1,编译ipa用2&amp;#39;) # &amp;#39;-p&amp;#39;, &amp;#39;--projects_path&amp;#39;, dest=&amp;#39;projects_path&amp;#39;, help=&amp;#39;项目目录名,如proj.android,编译ipa单个项目时可不指定,为空值时不调用xctool脚本打包&amp;#39;) # &amp;#39;-w&amp;#39;, &amp;#39;--with_lua_code&amp;#39;, dest=&amp;#39;with_lua_code&amp;#39;, help=&amp;#39;1为带源lua源码,0为加密lua代码&amp;#39;) # &amp;#39;-t&amp;#39;, &amp;#39;--ant_target&amp;#39;, dest=&amp;#39;ant_target&amp;#39;, help=&amp;#39;编译android时 为&amp;#34;None&amp;#34;值:不调用build.xml,为空值时调用默认的target,有值时调用对应的ant target&amp;#39;) # &amp;#39;-s&amp;#39;, &amp;#39;--compiler_cplus&amp;#39;, dest=&amp;#39;compiler_cplus&amp;#39;, help=&amp;#39;调用ndk编译c&#43;&#43;代码，编译ipa时无用&amp;#39;) # &amp;#39;-v&amp;#39;, &amp;#39;--version_code&amp;#39;, dest=&amp;#39;version_code&amp;#39;, help=&amp;#39;新的版本号&amp;#39;) # &amp;#39;-o&amp;#39;, &amp;#39;--output_path&amp;#39;, dest=&amp;#39;output_path&amp;#39;, help=&amp;#39;资源加密后输出目录,可选&amp;#39;) # 作者：farwmarth # E-mail:[wujiyu115@gmail.com](mailto:wujiyu115@gmail.com) # 创建日期：2014-09-23 15:17:19 #-------------------------------------------- import sysimport os, os.path, stat, shutilimport shutilimport platformfrom optparse import OptionParserPLATFORM_ANDROID = &amp;#34;1&amp;#34;PLATFORM_IOS = &amp;#34;2&amp;#34;SO_PATH=&amp;#34;/libs/armeabi/libcocos2dlua.so&amp;#34;ANDROID_PROJ_BASE=&amp;#34;proj.android.base&amp;#34;PROJ_SO_BASE=ANDROID_PROJ_BASE&#43;SO_PATHCURR_DIR = os.path.dirname(os.path.realpath(__file__))releaseApksFile = os.path.abspath(CURR_DIR&#43;&amp;#34;/releaseApks/&amp;#34;)ANT_PATH=os.path.abspath(os.path.join(CURR_DIR)&#43;&amp;#34;/../ant/bin/ant&amp;#34;)with_lua_code = False # 是否运行lua源码 compiler_cplus = False # android上是否编译c&#43;&#43;代码 compiler_platform = 1 # 编译的平台 android还是ios projects_path =None # 项目要目录  ant_target = None# android ant 目标 version_code = None # 新版本号 output_path = None #资源处理好后输出目录 # 检查ndk环境变量 def check_ndk_environment():&amp;#39;&amp;#39;&amp;#39; Checking the environment NDK_ROOT, which will be used for building&amp;#39;&amp;#39;&amp;#39;try:NDK_ROOT = os.environ[&amp;#39;NDK_ROOT&amp;#39;]except Exception:print&amp;#34;NDK_ROOT not defined. Please define NDK_ROOT in your environment&amp;#34;sys.exit(1)return NDK_ROOT#检查环境变量 def check_environment_variables():if compiler_platform==PLATFORM_ANDROID :svnResult = NoneantResult = Noneif(isWin32()):svnResult = check_cmd_path(&amp;#34;TortoiseProc.exe&amp;#34;)antResult = check_cmd_path(&amp;#34;ant&amp;#34;)else:svnResult = check_cmd_path(&amp;#34;svn&amp;#34;)antResult = check_cmd_path(&amp;#34;ant&amp;#34;)# print svnResult if not svnResult :sys.exit(1)#检查路径里面是否包含某可执行文件 def check_cmd_path(executePath):result = 0dirs = Noneif(isWin32()):dirs = os.environ[&amp;#39;PATH&amp;#39;].split(&amp;#39;;&amp;#39;)else:dirs = os.environ[&amp;#39;PATH&amp;#39;].split(&amp;#39;:&amp;#39;)for cmdpath in dirs :if os.path.isdir(cmdpath) and executePath in os.listdir(cmdpath):result = 1if not result:print&amp;#34;please check environment variables &amp;#34; &#43; executePathreturn result# ndk编译链 def select_toolchain_version():&amp;#39;&amp;#39;&amp;#39;ndk-r8e -&amp;amp;gt; use gcc4.7ndk-r9 -&amp;amp;gt; use gcc4.8&amp;#39;&amp;#39;&amp;#39;ndk_root = check_ndk_environment()if os.path.isdir(os.path.join(ndk_root, &amp;#34;toolchains/arm-linux-androideabi-4.8&amp;#34;)):os.environ[&amp;#39;NDK_TOOLCHAIN_VERSION&amp;#39;] = &amp;#39;4.8&amp;#39;print&amp;#34;The Selected NDK toolchain version was 4.8 !&amp;#34;elif os.path.isdir(os.path.join(ndk_root, &amp;#34;toolchains/arm-linux-androideabi-4.7&amp;#34;)):os.environ[&amp;#39;NDK_TOOLCHAIN_VERSION&amp;#39;] = &amp;#39;4.7&amp;#39;print&amp;#34;The Selected NDK toolchain version was 4.7 !&amp;#34;else:print&amp;#34;Couldn&amp;#39;t find the gcc toolchain.&amp;#34;exit(1)# ndk编译c&#43;&#43; def do_build(cocos_root, ndk_root, app_android_root):ndk_path = os.path.join(ndk_root, &amp;#34;ndk-build&amp;#34;)# windows should use &amp;#34;;&amp;#34; to seperate module paths platform = sys.platformif platform == &amp;#39;win32&amp;#39;:ndk_module_path = &amp;#39;NDK_MODULE_PATH=%s;%s/cocos2dx/platform/third_party/android/prebuilt&amp;#39; % (cocos_root, cocos_root)else:ndk_module_path = &amp;#39;NDK_MODULE_PATH=%s:%s/cocos2dx/platform/third_party/android/prebuilt&amp;#39; % (cocos_root, cocos_root)command = &amp;#39;%s-C %s%s&amp;#39; % (ndk_path, app_android_root, ndk_module_path)os.system(command)# 赋权操作 def subFileChmod(_sPath, _stat):itemsInDir = os.listdir(_sPath);for item in itemsInDir:sItemPath = os.path.join(_sPath, item);os.chmod(sItemPath, _stat);if os.path.isdir(sItemPath):subFileChmod(sItemPath, _stat);# 拷贝文件 def copy_files(src, dst):for item in os.listdir(src):path = os.path.join(src, item)# Android can not package the file that ends with &amp;#34;.gz&amp;#34; if with_lua_code == False:if not item.startswith(&amp;#39;UserDefault.xml&amp;#39;) and not item.startswith(&amp;#39;.&amp;#39;) and not item.endswith(&amp;#39;.gz&amp;#39;) and not item.endswith(&amp;#39;.dll&amp;#39;) and not item.endswith(&amp;#39;.exe&amp;#39;) and not item.startswith(&amp;#39;start.bat&amp;#39;) and os.path.isfile(path):shutil.copy(path, dst)if os.path.isdir(path) and not item.startswith(&amp;#39;.svn&amp;#39;) and not item.startswith(&amp;#39;script&amp;#39;) and item != &amp;#39;cache&amp;#39; and item != &amp;#39;editor&amp;#39; and item != &amp;#39;.settings&amp;#39; and item != &amp;#39;_gsdata_&amp;#39; :new_dst = os.path.join(dst, item)if os.path.exists(new_dst):shutil.rmtree(new_dst)os.mkdir(new_dst)copy_files(path, new_dst)else :if not item.startswith(&amp;#39;UserDefault.xml&amp;#39;) and not item.startswith(&amp;#39;.&amp;#39;) and not item.endswith(&amp;#39;.gz&amp;#39;) and not item.endswith(&amp;#39;.dll&amp;#39;) and not item.endswith(&amp;#39;.exe&amp;#39;) and not item.startswith(&amp;#39;start.bat&amp;#39;) and item != &amp;#39;js&amp;#39; and os.path.isfile(path):shutil.copy(path, dst)if os.path.isdir(path) and not item.startswith(&amp;#39;.svn&amp;#39;) and item != &amp;#39;cache&amp;#39; and item != &amp;#39;editor&amp;#39; and item != &amp;#39;.settings&amp;#39; and item != &amp;#39;_gsdata_&amp;#39; :new_dst = os.path.join(dst, item)if os.path.exists(new_dst):shutil.rmtree(new_dst)os.mkdir(new_dst)copy_files(path, new_dst)# 拷贝资源 def copy_resources(resources_dir,assets_dir,remove_assets):if remove_assets:if os.path.isdir(assets_dir):print &amp;#34;delete &amp;#34;&#43;assets_dirshutil.rmtree(assets_dir)os.mkdir(assets_dir)if os.path.isdir(resources_dir):copy_files(resources_dir, assets_dir)def copy_android_res(app_android_root):assets_dir = os.path.join(app_android_root, &amp;#34;assets&amp;#34;)resources_dir = os.path.join(app_android_root, &amp;#34;../Resources&amp;#34;)if os.path.isdir(resources_dir) and os.path.isdir(assets_dir):copy_resources(resources_dir,assets_dir,True)def copy_ipa_res(app_output_path,resources_dir):if app_output_path!=None and resources_dir!=None and os.path.isdir(app_output_path) and os.path.isdir(resources_dir):copy_resources(resources_dir,app_output_path,False)pass# 加密lua代码 def dumplua(current_dir):if with_lua_code == False:command = Noneif(isWin32()):command =os.path.abspath(current_dir&#43;&amp;#34;/../dump/dump.bat&amp;#34;)command = &amp;#34;call &amp;#34;&#43;commandelse:command =os.path.abspath(current_dir&#43;&amp;#34;/../dump/dump.sh&amp;#34;)if command :# print command os.system(command)# 是否是windows平台 def isWin32():sysstr = platform.system()return sysstr == &amp;#34;Windows&amp;#34;#更新so文件 def updateSo(update,app_android_root):print&amp;#34;update so file&amp;#34;# print update command =NonePROJ_SO_BASE_ABS = os.path.abspath(app_android_root&#43;&amp;#34;/../&amp;#34;&#43;PROJ_SO_BASE)# print PROJ_SO_BASE_ABS if update ==True :if(isWin32()):command=&amp;#34;TortoiseProc.exe /command:update /path:&amp;#34;&#43;PROJ_SO_BASE_ABS&#43;&amp;#34; /closeonend:1&amp;#34;else:command=&amp;#34;svn update &amp;#34;&#43;PROJ_SO_BASE_ABSos.system(command)print&amp;#34;update so file success&amp;#34;passdef outputApk(app_android_root,project_path):if ant_target != &amp;#34;None&amp;#34;:print&amp;#34;.................outputApk&amp;#34;command= ANT_PATH&#43;&amp;#34; -buildfile &amp;#34; &#43; app_android_root&#43;&amp;#34;/build.xml &amp;#34;if ant_target:if ant_target ==&amp;#34;sanguoBuildNotInstall&amp;#34;:command =command &#43; &amp;#34; -q &amp;#34;command = command&#43;ant_targetif version_code:command = command&#43;&amp;#34; -Dproject.versionname=&amp;#34;&#43;version_code&#43;&amp;#34; -Dproject.versioncode=&amp;#34;&#43;version_codeprint commandif command :os.system(command)if ant_target ==&amp;#34;sanguoBuildNotInstall&amp;#34;:releaseApk = os.path.abspath(app_android_root&#43;&amp;#34;/bin/sanguo-release.apk&amp;#34;)if os.path.exists(releaseApk):destPath=releaseApksFile&#43;&amp;#34;/&amp;#34;&#43;project_path&#43;&amp;#34;.apk&amp;#34;# print destPath shutil.copy(releaseApk,destPath)print &amp;#34;copy &amp;#34;&#43;project_path&#43;&amp;#34; apk success&amp;#34;passdef outputIpa(app_projects_path):if app_projects_path != None:command = &amp;#34;. ./build_common_ipa.sh &amp;#34;&#43;app_projects_pathos.system(command)# 处理 def build() :# check_environment_variables check_environment_variables()# set Path current_dir = os.path.dirname(os.path.realpath(__file__))cocos_root = os.path.join(current_dir, &amp;#34;../../../..&amp;#34;)# dumpLua dumplua(current_dir)if compiler_platform==PLATFORM_ANDROID :#如果在函数内修改全局变量则视他为一个局部变量 projects_path_local = projects_path.split(&amp;#34;:&amp;#34;)projectLen=len(projects_path_local)ANDROID_PROJ_BASE_ABS=os.path.abspath(os.path.join(current_dir, &amp;#34;../../&amp;#34;) &#43;ANDROID_PROJ_BASE)if compiler_cplus == True :# print ANDROID_PROJ_BASE_ABS ndk_root = check_ndk_environment()select_toolchain_version()do_build(cocos_root, ndk_root, ANDROID_PROJ_BASE_ABS)print&amp;#34;compiler cplus plus code success&amp;#34;else:updateSo(True,ANDROID_PROJ_BASE_ABS)#先删除apks目录 if os.path.exists(releaseApksFile):shutil.rmtree(releaseApksFile)os.mkdir(releaseApksFile)#遍历生成 for project_path in projects_path_local:app_android_root = os.path.join(current_dir, &amp;#34;../../&amp;#34;) &#43; project_pathapp_android_root=os.path.abspath(app_android_root)print &amp;#34;deal project........ &amp;#34;&#43;project_path# copy files print&amp;#34;begin copy resources&amp;#34;copy_android_res(app_android_root)print&amp;#34;copy resources success&amp;#34;outputApk(app_android_root,project_path)else:resources_dir =os.path.join(current_dir, &amp;#34;../../Resources&amp;#34;)copy_ipa_res(output_path,resources_dir)# outputIpa(projects_path) # -------------- main -------------- if __name__ == &amp;#39;__main__&amp;#39;:parser = OptionParser()parser.add_option(&amp;#39;-c&amp;#39;, &amp;#39;--compiler_platform&amp;#39;, dest=&amp;#39;compiler_platform&amp;#39;, help=&amp;#39;compiler_platform: android 1,ios 2&amp;#39;)parser.add_option(&amp;#39;-p&amp;#39;, &amp;#39;--projects_path&amp;#39;, dest=&amp;#39;projects_path&amp;#39;, help=&amp;#39;directory of project option of ios&amp;#39;)parser.add_option(&amp;#39;-w&amp;#39;, &amp;#39;--with_lua_code&amp;#39;, dest=&amp;#39;with_lua_code&amp;#39;, help=&amp;#39;run game with lua code&amp;#39;)parser.add_option(&amp;#39;-t&amp;#39;, &amp;#39;--ant_target&amp;#39;, dest=&amp;#39;ant_target&amp;#39;, help=&amp;#39;config build target ,android is ant target,ios is build setting &amp;#39;)parser.add_option(&amp;#39;-s&amp;#39;, &amp;#39;--compiler_cplus&amp;#39;, dest=&amp;#39;compiler_cplus&amp;#39;, help=&amp;#39;compiler cplus code for android,option of ios&amp;#39;)parser.add_option(&amp;#39;-v&amp;#39;, &amp;#39;--version_code&amp;#39;, dest=&amp;#39;version_code&amp;#39;, help=&amp;#39;new version code&amp;#39;)parser.add_option(&amp;#39;-o&amp;#39;, &amp;#39;--output_path&amp;#39;, dest=&amp;#39;output_path&amp;#39;, help=&amp;#39;Resources out put path&amp;#39;)opts, args = parser.parse_args()compiler_platform = opts.compiler_platformprojects_path = opts.projects_pathwith_lua_code = opts.with_lua_codecompiler_cplus = opts.compiler_cplusant_target = opts.ant_targetversion_code= opts.version_codeoutput_path= opts.output_pathif compiler_platform ==None or with_lua_code ==None :print&amp;#34;some params not defined&amp;#34;sys.exit(1)if compiler_platform ==PLATFORM_ANDROID :if compiler_cplus ==None or projects_path ==None :print&amp;#34;android build compiler_cplus and projects_path is must&amp;#34;sys.exit(1)print&amp;#34;compiler_platform is :&amp;#34;&#43;compiler_platformif compiler_cplus:print &amp;#34;projects_path is :&amp;#34;&#43;projects_pathprint&amp;#34;with_lua_code is :&amp;#34;&#43;with_lua_codeif compiler_cplus:print &amp;#34;compiler_cplus is :&amp;#34;&#43;compiler_cpluscompiler_cplus= int(compiler_cplus)if ant_target:print &amp;#34;ant_target is :&amp;#34;&#43;ant_targetif version_code:print &amp;#34;version_code is :&amp;#34;&#43;version_code#int to boolean with_lua_code= int(with_lua_code)build()这个python脚本用了OptionParser库来构建参数，参数说明在注释里有就不再复述了。脚本流程:
 检查环境变量 NDK_ROOT ,win上的TortoiseProc.exe,ant我也放到tools目录了。 加密lua代码 android平台复制资源调用各项目的build.xml编译打包 ,iOS只做资源拷贝，编译在外层的shell脚本中。  build_ipa_all.sh:编译所有ipa build_anroid_all.sh:编译所有anroid项目 渠道批量打包后,apk在releaseApks目录中,ipa中releaseIpas目录中
所有脚本附上: http://pan.baidu.com/s/1o6ODJNc
</content>
    </entry>
    
     <entry>
        <title>一套键鼠的忧愁</title>
        <url>https://farwmarth.com/post/%E4%B8%80%E5%A5%97%E9%94%AE%E9%BC%A0%E7%9A%84%E5%BF%A7%E6%84%81/</url>
        <categories>
          <category>tools</category>
        </categories>
        <tags>
          <tag>tools</tag>
        </tags>
        <content type="html"> 最近终于从虚拟机的囧境里走了出来，申请了一台macMini在win和mac之间切换开发.两台主机键鼠频繁切换真是件蛋疼的事情，不过还好有局域网键鼠控制工具。
跨平台的键盘控制工具里找到了两个好用点的:
synery : 配置比shareMouse复杂些,连接要选择作为服务器端还是客户端，免费版不支持文件拖曳。优势在于免费
作为服务器时要先在configure server中配置要连接的客户端的位置，用pc名字作为唯一标记key.服务器启动后在客户端填写服务器的ip,点击start后就可以连接成功了。
ShareMouse:傻瓜化，启动即可使用，拖曳调整位置，免费版隔几分钟就会弹出注册的信息，支持文字图片的复制粘贴，以及文件拖曳。 现在我的使用情况是:平常使用synery,在需要文件拖曳的时候再启ShareMouse,两者不冲突。
解决了键鼠的问题，还有一个困扰的问题就是mac的键盘映射了,使用win的键盘的话，win徽键相当于mac中的command键。mac中的复制粘贴正好是command&#43;c,v，这样一来用win键盘在mac系统中按键非常别扭。幸好mac自带修饰键映射，将command和ctrl键调整一下。 在mac下按键终于舒服起来了。但这样又带了一个问题，因为将我是使用MacMini的键鼠,键盘映射导致在win下面的按键也被替换了。悲剧，又得在win下找按键映射的工具，找了很多都是写注册表需要重启电脑的。后来终于找到叫“移花接木”的映射软件，软列表不需要重启或注销。问题终于搞定，在win和mac下按键都一致了。</content>
    </entry>
    
     <entry>
        <title>小工具之AppInfo</title>
        <url>https://farwmarth.com/post/%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%B9%8Bappinfo/</url>
        <categories>
          <category>ant</category>
        </categories>
        <tags>
          <tag>ant</tag>
        </tags>
        <content type="html"> 因为经常打包需要查看apk或者是ipa中的版本信息,包名信息就写了这么个小工具，要跨平台就选择了java来写.
功能非常简单,拖放apk到界面就会把AndroidManifest.xml内容解析出来,拖放ipa到界面会把Info.plist解析出来
原理也很简单,apk的xml用axmlprinter2这个库.ipa的用sunlab,代码高亮使用了: rsyntaxtextarea
写完之后又稍微扩展了一下:增加了命令行的支持，增加了查看zip内任意文件内容的功能。
参数说明:
 zipFile: 源zip文件,(apk和ipa也是zip) findFile:要查找的文件(如:PayLoad/sanguo.app/Info.plist) regexp:查找是否启用正则(True or False) showUI:是弹出界面还是输出到命令行(True or False)  源码奉上:AppInfo,out目录中为已打包好的jar,要修改代码可以用ant自己再构建
</content>
    </entry>
    
     <entry>
        <title>libgdx字体渲染选择方案</title>
        <url>https://farwmarth.com/post/libgdx%E5%AD%97%E4%BD%93%E6%B8%B2%E6%9F%93%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88/</url>
        <categories>
          <category>libgdx</category><category>programm</category>
        </categories>
        <tags>
          <tag>libgdx</tag>
        </tags>
        <content type="html"> 最近在优化一下游戏中内的字体渲染方案。 找了下资料发现渲染方案就两种。一种是使用ttf，动态去生成纹理渲染.第二种是采用位图字体.两种方案各有利弊.第一种方案性能损耗比较大,在libgdx的FreeTypeFontGenerator中会每次都重新生成纹理。如果界面上Label数量增多,
fps自然会下降。好处是因为实时生成不会因为字体放大而模糊。第二种方案好处是性能均衡.但是字体比例放大时会出现模糊现象.
策划要求使用android自带的ttf文件.实现过程很简单:
FileHandle fileHandler=null;switch (Gdx.app.getType()) {case Android:fileHandler = Gdx.files.absolute(&amp;#34;/system/fonts/DroidSansFallback.ttf&amp;#34;);break;case Desktop:fileHandler = Gdx.files.absolute(&amp;#34;C:/Windows/Fonts/font.ttf&amp;#34;);// fileHandler = Gdx.files.internal(&amp;#34;data/potato.ttf&amp;#34;); break;}FreeTypeFontGenerator generator = new FreeTypeFontGenerator(fileHandler);我在桌面版中调用的是winodws自带字体库.在Android中加载系统字体库。然FreeTypeFontGenerator来生成BitmapFont.坑爹的是FreeTypeFontGenerator生成字体库时不能重复文字,
而且如果生成的字体库太大时，动态生成完全是个悲剧。pc测试生成4000常用字需要4s左右,在android中动态生成4000字体67s.
在android上还是通过jni生成的.这种性能完全无法接受. 所以这种方案貌似行不通。 不过有个优化设想还没实践:可以修改api来实现生成字体时可将接受重复文字。将单个文字纹理缓存这样相当于有到什么文字时才增加纹理的体积。游戏运行过程中运行也不会达到4000个汉字.
纹理体积比第二种方案会减少很多.当然这只是设想.
第一种方案行不能。只能折中使用第二种方案了。将4000汉字打包成图片纹理在800k左右.
至于放大模糊的问题没有什么好的解决方案。可以在打包输出纹理的时候将字号设置为22号左右。然后使用DistanceField效果.
如果需要描边效果的话也是个蛋疼的问题.libgdx还没有支持描边的特性,只能用Hiero重新打包一个加描边特效的fnt.不过也可以依照Hiero使用java.awt.Stroke 对象动态去描边.打包的纹理还可以使用pngGauntlet来减小20%左右的体积.
</content>
    </entry>
    
     <entry>
        <title>虚拟货币二三事</title>
        <url>https://farwmarth.com/post/%E8%99%9A%E6%8B%9F%E8%B4%A7%E5%B8%81%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
        <categories>
          <category>life</category>
        </categories>
        <tags>
          <tag>life</tag>
        </tags>
        <content type="html"> 比特币 最近比特币炒得比较火,最开始听说这种虚拟货币是从国外的极客网站上看到的,流传于极客之间的玩物.十一月初的时候还是对人民币汇率还是1000元的样子。不到一个月，等到媒体大肆报道的时候已经翻了六七倍。出于好奇和装b的心理于是查了下维基百科.原理如下 ：
 新的比特币是由对等网络P2P的节点，在完成一个特定数学问题计算之后生产出的。这些数学计算需要相当的运算能力才能完成，并能够通过生成有效运算工作的证明来检验。在比特币网络中运算难度可以自动调节，在最初的四年里会有10,500,000比特币被制造出来，这个数值每四年减半，所以在第四到第八年中会有5,250,000比特币被制造，在第8到第12年中会生产2,625,000比特币，以此类推。因此最终比特币的数额会无限趋近于21,000,000比特币。
技术上讲，目前的数据结构下，一个比特币可以被分区到8位小数，所以0.00000001BTC是目前的最小单位。如果将来有需要的话，再考虑更小的分区单位。即使比特币的允许精度从目前的8位小数扩展，最终流通中的比特币将总是略低于2100万（假定其他参数不变）。
系统运行内建的机制会在平均大约每10分钟确认一个区块（block）。[96]参与制造新比特币的人数变动，新比特币制造的难度也随之变动，这是将整个分布式网络作为一个整体来分析，分析的依据是之前2016个区块的制作时间。因此制造的难度与一定时间内全网投入制作工作的平均运算能力相关。单一个体“发现”新区块的可能性是创建在他的计算能力与全网计算能力的综合比较之上的。
区块的总数乘以每个区块的比特币值就是现存的比特币总数。每个区块的币值在最初的210,000个区块中是50BTC，之后210,000区块是每区块25BTC，然后是12.5BTC、6.25BTC，以此类推。最后一个产出比特币的区块将是编号为6,929,999的区块，这大约会在公元2140年前后发生。届时流通中比特币的总数将恒定维持在20999999.9769 BTC。生产的奖励会从0.00000001 BTC变为0，然后将不再有新的比特币被生产出来。 比特币地址大约33位，相当于银行卡,比特币私钥则相当于密码.它们会成对出现.而交易相当于我们平时的转账,可以把比特币从一个地址转移到另一个地址.因为地址是非实名的,这给洗黑钱提供了相当强力的温床。 比特币就像一个名不见经传的小人物一夜之间就被推到了历史的浪潮.有人一夜暴富，有人在暗叹错失良机.
 另一种虚拟货币 XRP :由ripple实验室开发的另一种虚拟货币。知道这种货币的过程更是有趣,某一天在gamil的邮箱里发现了两封垃圾邮件.大意是收购5月1号之前注册的github账号.然后会通过支付宝支付你30块人民币.出于手贱我又查了查google.原来是ripple的活动,回赠5月1号之前注册github用户免费赠送xrp.如果关注了他们的github账号则是4040xrp.没有就会折半.注册个账号玩了玩。发现和比特币类似.前几天无聊在rippleChina逛逛。把这赠送的2020xrp以0.2元一个卖了.结果第二天就涨了…
</content>
    </entry>
    
     <entry>
        <title>曲线救国之罗技蓝牙键盘</title>
        <url>https://farwmarth.com/post/%E6%9B%B2%E7%BA%BF%E6%95%91%E5%9B%BD%E4%B9%8B%E7%BD%97%E6%8A%80%E8%93%9D%E7%89%99%E9%94%AE%E7%9B%98/</url>
        <categories>
          <category>瞎折腾</category>
        </categories>
        <tags>
          <tag>life</tag><tag>蓝牙键盘</tag>
        </tags>
        <content type="html"> 双十一的时候手一抖秒了个罗技的蓝牙键盘，买来配ipad来写写博客.官网上报价499,秒杀价99。昨天到货后迫不及待地把玩一番，心想着坑爹的ipad输入终于有个好伴侣了。下班回家把ipad蓝牙打开，死活搜索不到这个键盘设备。朕以为哪里设置有问题，各种百度各种google无果，好吧，既然ipad连接不上,那就试下笔记本吧，尼玛,dell笔记本也是各种连不上，蓝牙驱动重装n遍还是无果啊。
然后把键盘翻过来一看，android专用啊，你妹的android专用啊。印象里蓝牙不是都通用嘛，怎么还各系统不兼容。官网上查了一下罗技y-r0021分了两款产品,for android和for ipad.我买的这个就只能连接我的mx了。键盘重量挺沉的，敲击感也不错。只是对着这手机小屏幕敲起来各种不爽。
还是想将键盘连上ipad或者笔记本，搜索了一下蓝牙适配的配件，全都是电脑的适配器。不知道对我这个y-r0021有效没，待测试。突然又想到其实可以将手机屏幕投影到ipad上面，这样屏幕看起来就大了，看起来就不用那么费劲了。找了n款屏幕共享的软件，android和ios共用的终于被我找到了:mirrorop . 在android上装上send端，ipad上装上recevie端。然后蓝牙键盘再连上android手机。效果如下.
终于是达到了目的，效果却是不甚理想。输入有点延时，毕竟是投影。瞎折腾.
</content>
    </entry>
    
     <entry>
        <title>回归</title>
        <url>https://farwmarth.com/post/%E5%9B%9E%E5%BD%92/</url>
        <categories>
          <category>一个人的喃喃自语</category>
        </categories>
        <tags>
          <tag>life</tag>
        </tags>
        <content type="html"> 休了个好长一个假 加上国庆的话,休息了二十来天的样子,又开始了忙碌的日子.这二十来天不上班的日子节奏放慢不少,国庆回了趟女朋友家,呼吸了一星期的新鲜空气.10号辞职后就开始不急不忙地找工作.辞职之前盘算着去厦门玩一个礼拜,真的辞了后又懒成一陀了,加上小锅又要上班,一个人出游似乎有点寂寞,于是一个周的时间又宅在家里.算下来应该是第三次找工作了,本以为是比较轻松的事情.投了简历一星期才一面试电话,还不是所做的行业.这倒让我挺吃惊了的.后面一周的时间面了几个不太相关的职位.活倒是轻松不少,双休不加班,工资也比现在的要好.但是总感觉做app以后不知道怎么发展,不继续做游戏感觉浪费了这两年的技能.
这五个月 这五个月真的是忙得天晕地岸,每天加班到11点以后,不断的新功能,待解决的问题,新的游戏. 每天都不想爬起来,这也是坚定辞职的原因之一.国庆后终于是结束了这五个月的疲惫状态.养了十几天后和还在团队里的人聚了聚,有个哥们说好两三周不见就面色红润,两眼放光啊.虽没这么夸张,不过精神状态恢复倒是真的. 说说辞职原因吧,首要原因肯定是加班.长期加班到深夜直接导致的是第二天上午没有战斗力.整个团队都处于疲态.有天和负责人去谈话他的理论居然是:工作效率=工作时长.这一点真不敢苟同,不知道他是如何得出这一结论了,就个经验而言,我大部分的代码都是每天只花四五个小时真正在写.到了晚上九点之后战斗力就急剧下降. 除了加班之外就是就是感觉团队管理上不合理,客户端一直是两三个人要兼顾三个游戏的所有东西,功能暂且不说,平台接入各种杂七杂八的事情.而且策划是想到一个功能或者是发现一个bug就跑过来.完全没办法集中精力.某天心血来潮,这个游戏风格不大好,改改版吧…这让我们情何以堪.而且这斗地主完全没有竞争力,比同类型的毫无亮点. 辞职说了一个月后终于是批了.虽说经过这悲催的五个月对负责人完全无感,但有一点还是挺欣赏的. 他有个习惯是有问题就立马去解决,资源调动很快,有时候程序上遇到什么问题,一通电话,就会有别的团队的人过来指导一下.对于我这样的拖延症还是值得学习的.
面试与被面试 在这个新团队里倒是有几次面试别人的机会,因为项目负责人不是搞技术的,所以有时候要自己招人用.这种角色转变倒是让我重新认识了一下面试这个问题.因为自己学android时间也不长所有招的时候侧重点可能不一样.除了问下基本知识结构和所做项目外,还有两点我也比较看重,第一是是否在学习新的语言.问这点是因为这两年自身切身经历各种语言的变迁,从java到as再到android 到c&#43;&#43;.所以这种更新知识结构的能力感觉很重要.其实一般只要工作经历长一点.一两门语言的接触是不可避免的.市场的变化也带动了技术革新.学习新语言也成常态.第二点是是否知道github.github是个很好的代码库管理平台,很多优秀的引擎代码也在上面托管,比如:libgdx,cocos2d-x等等.大多数库都是开源的,当然也有私有库管理.除了可以参阅很好优秀的代码外,github上的开源氛围也很好,你可以直接和国外的开发者交流和讨论.更重要的一点是这种英文氛围对你的英文阅读能力有很大的帮助.英文资料的阅读能力如此重要是.因为大部分最新,诠释最全面最新的技术资料大多数是英文文档,如果你排斥英文文档,新技术学习往往会滞后一个周期.需要别人翻译好才能去学习.
站在面试的角度来讲,从这两年的面试来看,大部分面试官更注重经验之谈,面试不同工作年限的人方式自然也不一样. 没有工作经验的人笔试是免不了.一般有了两年工作经验这一步就可以省略,更多地是谈做的项目,在项目中的职责,对整个项目的掌控程度.这也是最近面试我才意识到的一点.对一个项目核心点和全局掌握会给你加分.
回归 二十几号的时候和之前的工作室的人聚了聚.感慨不少,对投入了一年精力的儿童游戏的失利的可惜.对现在状态的无奈.对上级管理的抱怨.如果不是因为主策的坑钱策略和上错了运营平台,这个儿童游戏本的长足发展和收入不至于此.不说和腾讯,百田去争个高下.在这市场分一杯羹不是难事.儿童市场像是一坛要慢慢酿的酒.电影,动画片,主题公园.而我们死在了起跑线上. 之前的组长叫我回去,现在做的手机rpg缺人手.看了下他们已完成的部分.犹豫了两天还是回归了.第一是没有做过这种类型的游戏想尝试一下.第二是觉得这游戏做出来流水应该不错.I am back,再战斗一场.
</content>
    </entry>
    
     <entry>
        <title>windows常用bat命令</title>
        <url>https://farwmarth.com/post/%E5%B8%B8%E7%94%A8bat%E5%91%BD%E4%BB%A4/</url>
        <categories>
          <category>bat</category>
        </categories>
        <tags>
          <tag>bat</tag>
        </tags>
        <content type="html"> 完整脚本 pandoc rst to markdown set mddir=mdfor /f &amp;#34;tokens=*&amp;#34; %%i in (&amp;#39;dir/s/b *.rst&amp;#39;) do pandoc -s -t rst --toc %%i -o %mddir%/%%~ni.md快速删除大量文件 del /f/s/q dirname&amp;gt; nulrmdir /s/q dirnamewindows查看某个端口号被占用并结束此进程 单条命令: FOR /F &amp;#34;tokens=5 delims= &amp;#34; %P IN (&amp;#39;netstat -a -n -o ^|findstr :4000.*LISTENING&amp;#39;) DO TaskKill.exe /PID %P /T /F分步过程  netstat -ano |findstr 4000 : //查看3306端口是否存在 tasklist |findstr 3036(PID号): //查看pid为3036的是什么程序在用 taskkill /T /F /PID 3036 : 杀死pid为3036的所有进程包括子进程(/T参数)  右键添加打开MS-DOS.bat @echo offreg add &amp;#34;HKCR\*\shell\ms-dos&amp;#34; /ve /d ms-dos /freg add &amp;#34;HKCR\*\shell\ms-dos\command&amp;#34; /ve /d &amp;#34;cmd.exe /k cd %%1&amp;#34; /freg add &amp;#34;HKCR\Folder\shell\ms-dos&amp;#34; /ve /d ms-dos /freg add &amp;#34;HKCR\Folder\shell\ms-dos\command&amp;#34; /ve /d &amp;#34;cmd.exe /k cd %%1&amp;#34; /f批量改名 ren *.xml *.txt批量命令带过程 @echo offset num = 0For /r . %%i in (*.RAR) do (set /a num &#43;= 1echo %%icall echo 第 %%num%% 个文件处理成功ren %%i *.mp4)echo 共%num%个文件被处理成功pause&amp;gt;nul清理SVN目录中.SVN @echo On@Rem 删除SVN版本控制目录@PROMPT [Com]@for /r . %%a in (.) do @if exist &amp;#34;%%a\.svn&amp;#34; rd /s /q &amp;#34;%%a\.svn&amp;#34;@Rem for /r . %%a in (.) do @if exist &amp;#34;%%a\.svn&amp;#34; @echo &amp;#34;%%a\.svn&amp;#34;@echo Mission Completed.@pause显示自己的IP @echo offfor /f &amp;#34;tokens=15&amp;#34; %%i in (&amp;#39;ipconfig ^| find /i &amp;#34;ip address&amp;#34;&amp;#39;) do set ip=%%iecho %ip%pause删除 svn 注册表 Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\DeleteSVN]@=&amp;#34;Delete SVN Folders&amp;#34;[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\DeleteSVN\command]@=&amp;#34;cmd.exe /c \&amp;#34;TITLE Removing SVN Folders in %1 &amp;amp;amp;&amp;amp;amp; COLOR 9A &amp;amp;amp;&amp;amp;amp; FOR /r \&amp;#34;%1\&amp;#34; %%f IN (.svn) DO RD /s /q \&amp;#34;%%f\&amp;#34; \&amp;#34;&amp;#34;bat写法备忘 删除自身 del %0查找字符串位置 Setlocal ENABLEDELAYEDEXPANSIONset str1=This is a test stringset ch1=tset str=%str1%:nextif not &amp;#34;%str%&amp;#34;==&amp;#34;&amp;#34; (set /a num&#43;=1if &amp;#34;!str:~0,1!&amp;#34;==&amp;#34;%ch1%&amp;#34; goto lastset &amp;#34;str=%str:~1%&amp;#34;goto next)set /a num=0:lastecho %num%bat 批处理－取年、月、日、时、分、秒、毫秒 取年份：echo %date:~0,4%取月份：echo %date:~5,2%取日期：echo %date:~8,2%取星期：echo %date:~10,6%取小时：echo %time:~0,2%取分钟：echo %time:~3,2%取秒： echo %time:~6,2%取毫秒：echo %time:~9,2%余数运算符% 在批处理程序中必须写成%%
去除字符串前面的零 set /a m=%m:*0=%</content>
    </entry>
    
     <entry>
        <title>养了几天喵</title>
        <url>https://farwmarth.com/post/%E5%85%BB%E4%BA%86%E5%87%A0%E5%A4%A9%E5%96%B5/</url>
        <categories>
          <category>一个人的喃喃自语</category>
        </categories>
        <tags>
          <tag>life</tag>
        </tags>
        <content type="html"> 以前家里养猫完全是放养状态.猫到处乱跑,饿了就回来吃饭,猫碗里要么是饭,要么是鱼骨头.一样长得肥肥壮壮还会抓老鼠.除了发情期很少听到猫叫,有些黑色的野猫更是神龙见首不见尾,很少能看清它的真容,经常是傍晚的时候一对眼就不见了.农村里的家猫基本作用是抓老鼠.养得也没那么骄贵.所以形态也和宠物猫有所不同,长得紧凑而彪悍.
昨天小锅跟我说她们公司门卫那里有3只小猫,想要抱回家. 下班回去的时候就看到一只2个月大小的小猫咪,蜷缩在客厅的长椅的角落里不出来.像是到了一个完全陌生的环境里的人,又没了小伙伴的陪伴那种落寞感让人看着心疼.
查了下幼猫喂养指南.各种麻烦,住要舒适的猫窝,吃要上好的猫粮还得不让它拉肚子,厕所要专门配置猫砂.还要定期打疫苗,清洁除虫.这还是猫的基本生活准则,更多的是要感情培育.要经常跟它玩,放在腿上抚摸它.这完全是带小孩的节奏啊.吃完饭后给它做了个简易的窝,在纸盒子里铺了件旧衣服.把猫粮和水盛好.猫咪死活不买账.嚎了一整晚,第二天很早就被吵醒,起来一直打瞌睡.趁着上班前的间隙用猫项圈陪它玩了一会.它也不再怕我,在我脚边蹭来蹭去的.
其实猫咪还是挺可爱的,熟络之后会跑来粘你.但有点让我受不了的是:半夜嚎叫.刚开始我以为嚎完第一个晚上就万事大吉了.事实并非如此.我上班的时候它一听到锁门的声音就开始哇哇大叫,似乎知道我要出门没时间陪它了一样.嚎得那叫一个惨绝人寰.第二个晚上我把它关在卧室外之后叫得更厉害了.声音也是一声长一声短,凌晨4点我只好爬起来把卧室门打开,它就一个人在椅子下面玩,还是不停地闹腾,真想一气之下把它丢外面去.
可能是这只小猫太小的缘故,特别爱活动,成天上窜下跳的,一个塑料袋都可以让它兴奋好一会儿.有时间看着它自己玩尾巴又觉得它特乖.上班和睡觉的时候特意把门窗全部关了.怕吵到邻居,也怕它从四楼一纵而下.猫天生对高度没有什么敏感度.晚上睡觉的时候它老是想往我床上跳,有时候鬼鬼祟祟地从床脚的一侧爬上来.家里灰尘太多,一两天它就把白毛染成了半灰的毛.如果不脏的会,我倒挺乐意让它睡在我床上.大部分时候它都很活跃.不过小猫咪也有安静的时候,玩累了就趴在电脑桌底下卷成一团.休息十来分钟又伸伸懒腰开始叫唤.真是个熊孩子.
养猫之前请教了一下爱猫人士,被说教了一番.养猫之前要做好心理准备,不要一时心血来潮就养个玩玩.因为养猫是猫咪一辈子的事情,少则7.8年,多则10年.刚开始觉得不就是养只猫吗?没啥大不了的.现在想想这些话,确实在理.养猫就像自己的小孩一样.是个有生命的个体.猫咪穷其一生陪你度过难过或者无聊的时光,某些时候连亲人都无可比拟.
和猫咪呆的这几天.让我突然理解那些流浪宠物关爱团体,绝非出于矫情.这次养猫的确是心血来潮了.我们没有足够的时间和精力去培育它.在豆瓣上发了个帖,希望给它找个有个有爱心的主.如果找不到合适的.就继续养着吧. 喵喵喵.
</content>
    </entry>
    
     <entry>
        <title>清静了几天</title>
        <url>https://farwmarth.com/post/%E6%B8%85%E9%9D%99%E4%BA%86%E5%87%A0%E5%A4%A9/</url>
        <categories>
          <category>一个人的喃喃自语</category>
        </categories>
        <tags>
          <tag>life</tag>
        </tags>
        <content type="html"> 见家长 国庆难得长假，和女朋友回家见了见家长，不懂人情事故，没准备什么礼物，临时买的烟酒，买了些骨质增生的药给他爸，见面尴尬自不用说，特别是吃饭的时候，因为是语言不通，大部分时候都听他们在讲，和女朋友和她她妈打电话多了，大部分意思还是可以揣摩出来.一个劲地叫我吃菜，只能点头客气。
“审查” 自是不可避免，毕竟是要将一个养了二十年的姑娘交到一个黄毛小子手里，晚饭后叔叔便开始问一些家庭情况，兄弟姐妹，车程。一一对答，心里没底。不知道叔叔阿姨对我印象如何.叔叔阿姨都是很朴实的人，拿家里最好的来招待我。
她家三兄妹，属她最小，在家里也是最活跃的一个。她哥则在饭桌上一个劲地叫我喝酒。有天中午到她奶奶家还真喝醉了，白酒没怎么喝过，不胜酒力。这让我想起了有年过年在外公家把白酒当白开水喝的经历。醉酒的状态如同瘫痪，四肢不听使唤而意识清醒。刚开始会头昏脑胀，肚内如火烧。而后四肢麻木，夹菜都有困难。后来干脆就瘫倒床上等酒醒。昏睡到傍晚才醒。
六根清静 在山里最大的感受是空气清新，阳光和煦。完全不用忌讳PM2.5的问题.她家门前有大片的竹林，风一吹便是滚滚的绿浪。到的那天下午我俩还跑来刚收割不久的稻田里去挖泥鳅，以前还没干过这事有种新奇感，在家里的时候只摸过鱼，泥鳅大多都是大人用电击法捕捉。果真是挖到了几条，感觉又回到了童年那段时光.
放假这段时间把不刷微博和空间，手机也没整天捏在手上了，晚上9点多就睡觉，早上7点钟就伸伸懒腰起床。秋天的太阳不刺眼，吃完饭后就搬个凳子到院子里晒太阳。翻了下节前准备好的几本书。猫猫狗狗在脚边窜窜去甚是好玩。
这几天看的两本书 以前看电子书多是txt,质量没法保证，而且很多书源找不到。最近看的两本书是多看上买的，价格不贵，三两块钱，而且阅读体验是txt所不能企及的。字体更加适合阅读，可以图文混排,还可以做书签和标注。
第一本看的是孟非的自传&amp;laquo;随遇而安&amp;raquo; 从童年到成年的成长经历。这本书整体感觉文字比较朴实平淡，可以当作是一个故事来看。早年在重庆，之后到南京，从印刷工到摄影,编辑再干到主持人.书中最让我印象最深刻的部分倒不是他早年在印刷厂的艰苦岁月，而是拍&amp;laquo;西域风情&amp;raquo;的纪录片时在新疆那异域里的奇特旅程。也许是因为男人都有这样一个探险的梦想。如果没来见丈母娘，估计我也在穿越山川的路上。
另一本更多是倾向于技术&amp;laquo;MacTalk.人生元编程&amp;raquo;.大部分篇幅介绍了苹果文化和发家史。以及mac的使用技巧。如果新手入门mac倒是本不错的教材。比较感兴趣的是关于程序员和编程的一些感悟这一章节。谈到了程序员的性格.程序员这个职业多个有一点会影响个人性格，平时交际有时会犯怵。这点在我这两年平时工作同事身上有所体现。可能是因为长期埋头写代码缺少社会活动的原因。书里也谈到了程序员个人提高 。如英语与编程能力的提高。其实没有什么窍门，持之以恒，方见成效。除此之外还应该发展下工作之外的兴趣。谁说程序员只能埋头做屌丝。程序员只是一种职业而已。我们同样可以做个十足的文艺青年。
</content>
    </entry>
    
     <entry>
        <title>几多良友</title>
        <url>https://farwmarth.com/post/%E5%87%A0%E5%A4%9A%E8%89%AF%E5%8F%8B/</url>
        <categories>
          <category>一个人的喃喃自语</category>
        </categories>
        <tags>
          <tag>儿时记忆</tag><tag>良友</tag>
        </tags>
        <content type="html">  仔细一想，我的大部分现在的好朋友都来自中学时期。当然每个时期身边都会有一些走得比较近的人，但说实话有些也无法称之为真正的朋友。中学时代交的朋友如此独特，也许是那个时候所处大环境一样,正在形成自己的观感，很多想法也不谋而同。
 我有一个从幼儿园就认识的朋友。同班了5年.学习成绩上会比赛，一起玩，放假的时候会去他家那边的小溪流里抓螃蟹，他喜欢画画，有时候会画一些卡通人物送给我。把他听过的故事讲给我听，那些什么薛仁贵的故事我现在还记得。那个时候娱乐的东西很少，下课时间又很漫长,通常是两个小时，经常会爬到学校上围墙择一种叫”竹节虫”的玩意,然后收拾到书包里，放学的时候丢到家里的火堆里燃得噼里啪啦响，像放鞭炮一样，就是这样的无聊的活动我们也乐此不疲。还有一件事情印象比较深刻的是上二三年级的时候,他用一种红色的剪纸剪了只特别好看的纸老虎,那个年纪自然是见到新奇的东西就要抢的时候。我们那时候课桌是那种很长的两人共用的那种，然后他就在各个课桌上窜来窜去的,我在过道里不停地追,一不小心就碰到他的脚跟,结果可想而知,鼻血暗涌。然后我就被罚站抄课文。
 后来隔开了两年,两个人在不同的学校,联系也渐少.努力去回忆这两年也是印象模糊,好像没什么深交的朋友。初中的时候两人又回到了一个学校，但不是同班，见面也比较少，偶尔中餐的时候打下招呼。放暑假的时候会约三五好友一起去他家聚聚。现在算算猛然一惊。他应该是和我在一个学校时间最长的了。五年的小学时间，初中三年，高中三年。十一年的时间却是君子之交淡如水的感觉。此后天南地北,相聚不易.
 中秋时节有一个朋友打电话给我,对于我这种基本上一年到头电话没动静的人来说着实有些意外,叙了叙旧,说到最后都不知道该怎么结束这场谈话.并不是心里厌恶,只是许久不见,又在不同的环境里生活了这么多年,共同语言所剩无几.只剩回忆.初二那会玩得特好.放假经常去我家.在卧室里用复读机听华仔和任贤齐.有时候俩人会神神道道地拿着可擦写的磁带录着.听一遍自己那五音不全的嗓音再擦掉.
 每当夏末蛙声遍地的时候,我俩就会有一个特别的消遣的方式:钓蛙.钓蛙和钓鱼同样需要极强的耐力.钓具倒是可以做得极其简陋,三五米长的小竹竿. 用鱼线即可,在末端拴上单节手指大小的棉絮就可以开钓了，如果要钓比较聪明的石蛙，那得先钓一些常见的土蛙做诱饵.我们一般就在门前的沟渠或者稻田里钓,装蛙的器具也非专业蛙篓，一肥料袋套上一个大铁圈。大约钓上七八只大的就可以吃一顿了，农田里长的青蛙和现在店里那些圈养的肉感完全不一样.炒上辣椒可以轻松干掉几碗饭.即使在烈日当空我们也钓得不亦乐乎.我运气和技术都算不上好,他每回都能钓得多一些。
 后来联系渐少也是因为不在一个学校，他高中读了一年好像就出外务工了。有时候过年的过年的时候会聚一聚.电话号码虽然通讯录里还存着,但却从未拔过号。我到现在也在为自己这种性格懊恼，从来不去主动联系别人，哪怕是我妈。都是每周固定打一通电话。其实倒也不是害怕与人交流，只是拿起电话都不知道从哪讲起。不知道莫名的一通电话是不是太唐突。
 现在仅存的两个没有隔阂的朋友也是那时认识的。一个复读后还在上大学。一个被我忽悠走上了和我相同的路。即使很久不联系，聚在一起也不会觉得尴尬，有啥事情说出口都会鼎力相助那种。我觉得这样才是真正意义上的朋友吧。
 工作以后就有了一个新的称呼:同事，一起共事，下班之后从来不过问的那种，自是谈不上交情。偶尔集体活动也是吃个饭,唱个k.唱k基本上是一堆人在那傻坐着，几个麦霸在那里自娱自乐。如果是碰上户外活动更是令人无语。前段时间公司组织去个植物园搞烧烤，一大帮人干坐在那里，等着别人生拾柴生火，生怕弄脏了双手。到最后组织活动都没多少人响应。倒不是说人的品德有多低下。只是感觉外面的大环境里人更自私。遇事多数明哲保身.  换了几家公司,氛围最好的应该是上一家,呆了一年.一起看着自己付出了心血的游戏开始收费，形势有所好转，最后因为一些因素又土崩瓦解.情绪复杂。最终留在那里的只剩三个人。有时候在q群里互道近况。之前的项目苟延残喘.又开了新的项目,苦逼着.而调度到新公司的我们突然觉得留下的甚好.我记得走的时候和boss说的时候,boss语重心长地跟我讲:你还年轻,脚踏实地地干几年.到我这个年纪混得不会很差。boss的大多数话都没听讲去，有一句话倒一直记得:人失败了没什么，再爬起来，大不了重新再来。
 最终还是没有和哪位前辈和领导成为很好的朋友,可能是太年轻,也可能是太自负.只能说这种东西可遇而不可.
</content>
    </entry>
    
     <entry>
        <title>关于正版软件</title>
        <url>https://farwmarth.com/post/%E5%85%B3%E4%BA%8E%E6%AD%A3%E7%89%88%E8%BD%AF%E4%BB%B6/</url>
        <categories>
          <category>一个人的喃喃自语</category>
        </categories>
        <tags>
          <tag>一个人的喃喃自语</tag>
        </tags>
        <content type="html">  很少有人说去买一个正版的操作系统,或者付费去买一个只有十几个字符串的license.我们的概念里很少去正视软件这种劳动果实。有这种想法和基调的人大概有两种:一是大多数人没有去自己费尽心血去开发一个软件。不知道为了几行核心代码会多熬多少个通宵。二是因为囊中羞涩，有时一个正版软件得花几百美元甚至更多。我也是此等苦逼之人。
 虽然经常用盗版软件，但是同样作为软件行业的一员，深知软件作者的辛苦。有时候写代码得熬到凌晨两三点。基本作息是2点睡觉。所以有时候软件不贵的情况下还是会去支持正版。
 我记得第一个买的正版软件是一个叫&amp;lt;&amp;lt;简繁大师&amp;gt;&amp;gt;的简体繁体互相转换的这么一个软件，之所以要买这个软件是因为公司的一个游戏要译成台湾版本。本来这个工作在项目前期就开始的，因为图项目速度，根本没有去考虑这一点，到这个时候项目已经相当庞大了，各种诟病，如果要手工一句句去翻译的会至少得花那么二十来天，而且容易出错。这个软件在同类我找过的软件中应该是最好的了，支持批量处理，速度很快，还可以转换整个目录，最大亮点的是自主研发的一个语义转换的引擎，通俗地讲就是不只是把简体转换成繁体，还会依旧台湾的口语习惯做一个纠正。最后买的是一个简体中文版的，售价是68.花了几天时候就把之前的工作给搞定了。这个正版工具让我用起来比其他盗版的东西更加踏实，心安体得一些，而且提高的工作效率真不是这68块所能企及的。
 还有一次有趣的经历是免费用的正版软件。做游戏开发大概都听到过一个叫TexturePacker的材质打包工具.这个工具是用来将小图拼接成一张大的材质的。售价是258人民币，我等屌丝对于这个价钱还是觉得略贵。不过这个老外作者提供了一个非常人道的途径可获取这个license.条件很简单:有一个成立的半年的博客。并且最近发了三篇文章。还有一些啥条件具体忘记了，给他发email后第二天就拿到了这个license.回了邮件里大致的让我写篇博文帮他介绍一下这个工具，如果用这个工具做出了什么好游戏可以放到他的网站上去展示。虽然最后我没拿这个好软件去做出什么好作品。但老外这种开拓的软件精神让我为之敬佩。放到国内几乎没有这样的开发者。(也许是接触的少)。所以说盗版软件猖獗，我觉得软件开发者在营销策略上也有一定的问题。如果也像这个老外一样提供一种渠道去和用户交流，做一些馈赠的工作。或许盗版的人也会有些不好意思。
 自己对盗版软件的态度是，如果实在是买不起的，用着盗版别到处张扬自己用着就行。如果确实是工作所需在承受范围内。买正版是最好的一种选择。对作者是一种尊重。也是对自己的一种尊重。
</content>
    </entry>
    
     <entry>
        <title>食物印象</title>
        <url>https://farwmarth.com/post/%E9%A3%9F%E7%89%A9%E5%8D%B0%E8%B1%A1/</url>
        <categories>
          <category>一个人的喃喃自语</category>
        </categories>
        <tags>
          <tag>一个人的喃喃自语</tag>
        </tags>
        <content type="html"> 早餐 在广州呆了两年多，没吃到啥好吃的东西，多数都会带些甜味而且又不放辣椒，对于无长期吃惯了辣椒的我来说是种折磨。虽然有不少湘菜馆，越总是吃不出读书时代那种小炒的味道。
至于早餐更是不知道如何选择,满大街都是馒头包子油条,对油条是完全无感，自从高中吃过一次后再也没有碰过。刚上班那话还凑合着吃包子，每天早上起得比较早，到公司附近那个小巷子里买3块钱一份的小笼包，每次都都要撒上一把辣椒粉才能咽完，后来真的是吃腻了，开始寻觅新早餐。有天早晨在附近找了一家汤粉店,各种拉肠什么的,挑来挑去点了碗素面。等了大概十来分钟，面终于上来了，愕然. 真的是素面:一叶扁舟江上流的感觉。就两三根青菜漂在面汤上，没有丁点肉丝啊。自此就把早餐给戒了。
回想起读书那会，早餐那叫一个种类繁多，干拌面，鸡蛋卷，玉米，茶叶蛋，还有各种说不出名字的饼。当然面条必不少。特别是冬天那会，早上冷得哆嗦，经常是快迟到的时候到小餐馆里点完热乎乎的面，然后把老板的大半碗酸菜倒光，虎扒式结束早餐时候。其实面条倒是一般，那酸菜和辣椒酱才是让我们欲罢不能的原因。整个冬天基本上都是吃着面条拌酸菜度过的。
如果让我说出最喜欢的而且永远不会厌倦的食物，第一反应肯定是酸菜了。虽然外观不是那么可人,乌漆抹黑的，但是味道却让我流连。
年少时的味道 生长在农村的好处就是对土地和食物有更直观的印象.我知道种子是如何一步步变成稻谷,粮食里渗透了多少汗水.菜地里的菜又是如何在肥沃的土地上萌芽到长出累累的果实.所以对于食物有很多的故事.
那时候一到夏天就成了孩子的季节,我会带着小伙伴到后山,把家里的锅碗瓢盆,油盐味精都带上,打灶生火,美其名曰&amp;quot;野炊”
.烧饭用的是一个叫&amp;quot;炉罐&amp;quot;的器皿,放上两勺菜油再加点盐.然后到山上折一些小木棍,捆上些易燃的松叶用打火机点燃开始野炊之旅.不一会就会炉里就会飘出阵阵香味.因为加上菜油的缘故这饭比在锅里面煮的还要香.然后几个小伙伴就狼吞虎咽了.饭饱之后就在这山坡上的松树下聊会天.
下雨的时候有时候会在山上采蘑菇,下雨过后蘑菇会从潮湿的地表钻出来,一般长在蕨类植物下面或者是一些沟壕的松树底下.蘑菇又分为很多种类.有茶树菇,四季菇,板粟菇等等.颜色也五花八门,有黑色的,褐色的,白色的.有一些却不能吃,如果颜色长得特别鲜艳,那么这是危险的信号,属于不能吃的一类.采蘑菇的过程就像发现新大陆一样.要有耐心.容易发现的自然都身材姣小.那些大点的蘑菇一般都长得较隐蔽,要翻开蕨类植物或者苔藓.采完后可以现炒,也可以晒干储存起来.
夏天还有一项必不可少的活动那就是捕鱼了,我们有一种捕鱼的土方法:就是用榨完油的茶树渣煮沸,然后把这些药水撒到河里.那时候门前的小河里小鱼很多.到中午太阳最晒的时候.我和我哥会用桶把这个熬出来的药水从河上游均匀地撒到各个河道上.然后在出水口堵上抓鱼用的网.过10来分钟.鲤鱼,鲫鱼这种小鱼就会漂出水面.很多小伙伴就会加入这个捕鱼的行列.整个小河里就热闹起来,小伙伴们不停地在水里窜动.想逮着大鱼.大点的鱼一般过了半小时后会游到浅水区去换水.茶树渣的药效会让鱼不适应.然后逮到一条大鱼后,小河里就像炸开了锅,争先恐后地围观.这种乐趣让我们乐此不疲.每年暑假都要经历好几次这样的高潮.前几年回老家一趟后甚是失望.小河被各色生活垃圾填满.河身变窄.鱼儿变点影子也看不着了.
有些东西是只能去怀缅.  (以前在公司的小区里无意中找到的葱油饼,1块一个.这算是在广州吃的比较喜欢的食物中的一种.易饱,吃完有些葱油的香味.)
</content>
    </entry>
    
     <entry>
        <title>摄影入门</title>
        <url>https://farwmarth.com/post/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/</url>
        <categories>
          <category>shoot</category>
        </categories>
        <tags>
          <tag>摄影</tag>
        </tags>
        <content type="html"> 前言 摄影可以看作是绘画的一个缩影，共通的地方有构图，线条和层次感。所谓构图就是将点线面，色彩，明暗合理安排。摄影教程里的什么九宫格构图，对角线构图在特定的场景下拍摄会有很好的效果，但是不要拘泥于这个构图规则，选择自己感觉舒服的角度就可以了。摄影包括很多种，风光，人像，纪实，商业，建筑，静物，还有衍生出来的延时摄影。摄影里最重要的元素之一就是光线,不同的光强度和光的照射角度可以让照片产生风格迥异的效果。清晨和傍晚是光线比较柔软的时候。风光摄影要注重层次感。而人像摄影则要注重人物的神态和情绪。 几点建议:  不要执着于器材,好的器材和只是辅助工具，但不是决定性因素，手机也能拍摄出好照片 可以先用手机来练习构图，然后逐步学习单反这样的器材 拍摄时除了主体对象也要注重背景的搭配 尝试浏览不同的风格类型的照片，总是看一种风格会有审美疲劳 多拍，然后每次只保留一两张照片 多看别人拍摄的照片，然后就会有喜好形成自己的风格。比如我就喜欢静物，建筑，风光这种  感悟  目前我觉得拍照这种视觉媒介带来的生活上的两种功效，一是好玩,像男巫(zach king)一样把脑洞大开的idea付诸实现,然后看完会觉得:It&amp;rsquo;s cool,然后自己也激发了这方面的兴趣。另一方面就是最拍照最原始的意义,作为一种回忆与情绪的载体。就像你看到自己很多前年胖嘟嘟穿着小军装,抱着花盆站在老菜园里一样.那块地可能已经面目全非,那咔嚓一声截取的画面却一直在这里。  资料网站 概念学习  佳能官方入门 http://www.canon.com.cn/specialsite/ds_abcbook/index.html 如何提高手机摄影水平 http://www.zhihu.com/question/20921841/answer/23467328?utm_source=weibo&amp;amp;utm_medium=weibo_share&amp;amp;utm_content=share_answer&amp;amp;utm_campaign=share_button  图片欣赏  500px https://500px.com/ 猫的树 http://cattree.cn/ 蜂鸟网 http://www.fengniao.com/ 图虫网 http://tuchong.com/ 胶片的味道 http://letsfilm.org/ lofter http://danielwoo.lofter.com/ http://l-j-feng.lofter.com/ http://feel1982.lofter.com/ http://yz1992.lofter.com/ http://wt0908.lofter.com/ http://zclqs.lofter.com/ http://zhangneixian.lofter.com/ http://mz1717.lofter.com/  书籍 下载地址: http://pan.baidu.com/s/1hqgzI76
 摄影笔记(最开始看这本书入门) 笔记摘录: http://farwmarth.com/2013/09/16/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0%20%E6%91%98%E5%BD%95/ 自然光人像摄影指南].[美]唐·马.彩图版 [摄亦有道2：摄影构图完全攻略].(日)山口高志  apps&amp;amp;软件 图库  instagram 推荐账号: https://instagram.com/helloemilie https://instagram.com/bythebrush https://instagram.com/monchouchou https://instagram.com/morganbrechler https://instagram.com/blackpigment https://instagram.com/coffeewithme https://instagram.com/aminuteawayfromsnowing https://instagram.com/missanmo lofter 500px  图片编辑app  VSCO Cam Snapseed PS Touch  图片编辑软件  photoshop lightroom  知识 </content>
    </entry>
    
     <entry>
        <title>摄影笔记 摘录</title>
        <url>https://farwmarth.com/post/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0-%E6%91%98%E5%BD%95/</url>
        <categories>
          <category>shoot</category>
        </categories>
        <tags>
          <tag>shoot</tag>
        </tags>
        <content type="html"> 一 相机分类: 一 按取景系统分 :
 平视旁轴取景相机 (人眼与ccd感光器会有视差)
 单反(无视差)
  二 按画幅:
 全画幅：感光器尺寸为36mm*24mm ,相当于135单张胶卷尺寸 Aps画幅:
  二 镜头 镜头的重要参数: 焦距,光圈,特性
焦距 焦距 : 镜头中心点到感光器平面的距离
焦距与视角 每个镜头都有各自的焦距，焦距不同拍摄范围也不同。简单地说，焦距越短（数字越小）， 拍摄画面所能容纳的范围越广；焦距越长（数字越大），拍摄画面所能容纳的范围越窄，类 似于望远镜。
![image]https://farwmarth.bestnewbee.com/images/uploads/2013/09/image11.png)
非全画幅会命使镜头的视角变小: 举个例子200mm焦距的全画幅视角为12°，如果将200mm的镜头装在这三家APS - C 画幅的相机上，等效焦距就变成了300mm，视角就变成了8 °15′。 焦距一般可分为广角、中焦和摄远镜头。 按照135 相机全画幅视角：
 24mm 以下的焦距可称之为超广角。 24- 28mm 的焦距为标准广角。 28- 35mm 的焦距为一般广角。 35- 70mm 的焦距为中焦。 70- 135mm的焦距为中长焦。 135 - 400mm的焦距为摄远，也叫长焦。 400mm以上的焦距为超长焦。 50mm 因为视角与人眼一致，所以50mm 的定焦镜头就是标准镜头，简称标头。  焦距与透视 透视效果是一个常常被大家忽略的由镜头焦距产生的效果。尽管实际情况是透视与焦距 无关，只与拍摄距离有关。但是作为新手，可以简单地记作透视就是画面中的拍摄对象会产 生近大远小的视觉效果。广角镜头焦距短，在画面上表现相同大小的主体时拍摄距离更近， 产生更强烈的透视感。反之，焦距越长，在画面上表现相同大小的主体时拍摄距离更远，透 视感越弱。光圈 光圈值F ＝焦距／孔径
焦距不变，孔径越大，光圈值越小，镜头越明亮。孔径不变，焦距越短，光圈值越小，镜头越明亮。 景深:清晰范围越大我们说是景深越深，清晰范围越小景深越浅。
对于景深，主要由三个参数决定。
 光圈与景深的关系。光圈越大景深越浅。 焦距与景深的关系。焦距越长景深越浅 拍摄距离与景深的关系。拍摄距离越近，景深越浅。（拍摄距离就是相机到被摄体的距离）  镜头购买TIPS：  在资金允许的情况下机身尽量选择全画幅。 避免以后更换镜头损失更大，镜头尽量选择专业级的。 为以后升级考虑，镜头尽量要全画幅的。 最大光圈越大越好。 焦距变焦比最好不要超过3 倍。最多不要超过5 倍。 第一支镜头配合机身的等效焦段尽量涵盖广角和中焦。  三 影调 影调:影调就是指一张照片的明暗程度
曝光补偿:对曝光的干预的一种方式.曝光补偿的单位是EV，当光标处于标尺的0 刻度时，就是0EV ，光标越向正方向移动，影调越高，光标越向负方向移动影调越低。中间调＝18% 灰＝0EV
相机的测光系统 相机的测光系统主要可以分为四种。
 **平均测光：**相机取景中总体曝光的平均值。对于初学者来说很难理解。好吧，做个比喻。3 名评委给超女打分。平均测光就是平均分。我从来不用。 **点测光：**相机取景中中心点周围极小一部分区域的曝光值。3 名评委给超女打分。我只看包小᷿老师或者杨二的分数。一般用于对于Ḁ个区域的精确曝光。比如我只要阴影下人脸的曝光正常，对于其他地方曝光无所谓。 **中央重点测光：**相机取景中心点测光，兼顾平均测光。3 名评委给超女打分。主要听杨二的评价，但是其他人的也听。我从来不用这种模式。 **评价测光：**将取景区域分为多个分区，分别计算曝光，再加成。最高科技的算法。3 名评委给超女打分。包小᷿老师最专业，着重考虑；杨二最不专业，可听可不听；高晓松只要不是评价曾哥的都可以听听。我基本上绝大多数情况下都将相机调整至这个测光方式上。希望你也是。  曝光量:光线进入相机的多少
感光度:感光器对光的敏感程度.ISO 值越高，感光器对光线越敏感。在数码时代CCD和CMOS 的感光度越高，CCD和CMOS 越容易被电信号干扰，照片的噪点越多，所以看起来也越粗糙。细腻照片看起来更好，所以在拍照时摄影师都尽量选择较低的感光度，也就是ISO100
曝光量＝感光器接收光的速度×曝光时间感光器接收光的速度＝环境光的强度×光圈 -----&amp;gt;曝光量＝环境光×光圈×快门(快门越快,曝光时间越短,曝光量越小) 光圈值与曝光量成反比。 光圈与曝光量成正比 所以针对光圈定义的混乱，大家只要记住光圈数值越小光圈越大就行了四 曝光组合  &amp;ldquo;A&amp;quot;档（Aperture Priority）：光圈优先。手动调节光圈，机器自动设置 快门。有利于景深控制。 &amp;ldquo;S&amp;quot;档（Shutter Priority）：快门优先。手动调节快门，机器自动设置光 圈。拍摄运动、瀑布等可用。 ** &amp;ldquo;M&amp;quot;档（Manual Exposure）**：完全手动调节光圈、快门。充分发挥你 用光的创造性。 有的机器有一个“完全傻瓜”的“Auto”档。 P 档和它的不同之处在于 P 档 可以手动调节曝光补偿等参数。而Auto 档则是“纯傻”。 A 档能简单地控制镜头的光圈，从而控制成像质量，和想要的景深效果 M 档在高速闪光和B 门时使用 T 档在追拍和慢速闪光时使用 P 档算是准傻瓜档吧 光圈优先就是手动定义光圈的大小，然后利用相机的测光获取相应的快 门值  五 光线 **方向:**光源方向可以分为四种：
  顺光。光源在被摄体正面。
  侧光。光源一般在被摄体正面45°。可用于人物造型，使人物看起来有立体感
  90°侧光。光源一般在被摄体90°位置。
  逆光。光源在被摄体背面。
  六 色温 色温:还原物体的真实色彩
 烛光的色温大概是1900K 。那张白纸放到烛光下就是橙黄色的。 家用白炽灯的色温大概是2800K 。那张白纸放到白炽灯光下就是黄色的。 日光的色温大概是5500K 。那张白纸放到日光下就是白色的。 频闪灯的色温大概是6000K 。那张白纸放到频闪灯的闪光下就会特别白。 荧光灯 色温大概是7000K 。那张白纸放到荧光灯下就是白色偏蓝的。 天光的色温大概是11000K。那张白纸如果只反射天光就是蓝色的。  所以色温越低，白色越显得发红；色温越高，白色越显得发蓝。 尽管红色是暖色调，蓝色是冷色调，但一定是发红色温低，发蓝色温高。白平衡:用来告诉相机修正真实颜色安全快门速度作为一个初学者的你，要尽量把快门速度保证在焦距2 倍的倒数之上。举例来说当你以30mm 的焦距进行拍摄的时候，你的快门速度就应该是焦距二倍的倒数，也就是最慢也应该在1/60 秒。当你用200mm的长焦镜头来拍摄的时候，最慢应该用1/400 秒的速度拍摄。随着你的摄影技术不断ᨀ高，你端相机的稳定性会越来越好。这时你的安全快门速度可以放慢到焦距的倒数。也就是说，你用30mm 的焦距拍摄时，你的快门速度只要比1/30 秒快就可以了，而你以200mm焦距拍摄的时候，快门速度至少要达到1/200 秒。
满足我们的影调。这时候只有三种办法能够保证你的影调。
 延长曝光时间,并固定相机.  如果手抖不可避免,我们可以将相机固定在这些不会发生位移的物体上,这样就可以放慢快门
优点：最自然的取得需要影调的方式。
缺点：被摄体可能会移动，所以依然可能造成模糊。
适用范围：静物的拍摄
 使用闪光灯  增加照明光源，就可以保证曝光量的充足。
优点：最直接的取得需要影调的方式。
缺点：改变了场景光，可能会出现不自然的光影效果。
适用范围：可以使用闪光灯的场景。
 增加感光度  之前一直说一般情况下不要改变感光度，但是也许这就是不一般的情 况了。有人说增加感光度不是会降低图像质量吗？其实这就要你做个选择了。是要图像质量 还是要一张清晰的照片？如果是我，我会毫不犹豫地选择后者。因为一张模糊的照片，就算 有再高的图像质量也是一张废片。
优点：最简单的取得需要影调的方式。
缺点：降低了图像质量
适用范围：不需要精美印刷的照片。
</content>
    </entry>
    
     <entry>
        <title>随地乱吐槽</title>
        <url>https://farwmarth.com/post/%E9%9A%8F%E5%9C%B0%E4%B9%B1%E5%90%90%E6%A7%BD/</url>
        <categories>
          <category>一个人的喃喃自语</category>
        </categories>
        <tags>
          <tag>一个人的喃喃自语</tag>
        </tags>
        <content type="html">  我的上帝,请赐予我宁静去接受我不能改变的一切，请赐予我勇气，去改变我所能改变的一切，并赐予我智慧，去分辨两者的不同.
 这三月 近三个月没有写博客,到七月份才继续写了些新东西.主要原因是换了一个工作地点.每天疯狂加班.十一点,一点.刚开始还斗志旺盛,每天学习新的东西，赶着新功能，每天回家洗澡倒头就睡。消磨了三个月，最初的新奇感觉也渐渐消退。团队里的人数慢慢扩大,三个月从最初我们五个人增长至二十几个,也有一起共事很久的同事离开.
原因不言而喻长期地熬夜每天都没什么精神。团队的扩增却并非是一场胜利.一句话总结这三个月就是:小收成，瞎忙活.
消失的专注力 近两个星期都处在一种游离状态,精神恍惚。心情浮躁，coding效率极低。像又到了女生的例假时间。完全没法静下心来写些东西。晚上经常熬到四点才能睡着。我想每个人都应该有这样的情况吧，不同时期都心情的起伏跌宕.这倒让我想起来读书时候那段时间，因为干扰的事物少,可以心无旁骛地去做一件事情.
初中的时候上了电路课后就开始拆东西，拆复读机，把那个小型马达用来做船模的电机，拆电子手表,虽然到最后都拆坏了。但那种一折腾一下午那种专注力让我乐此不疲。当你认真去做一件事情的时候，时间会过得相当的快。譬如高中不听课去看小说。看电脑杂志。甚至是看旧书店里买来的二手黑客杂志，即使看不懂也会兴趣盎然，上课的时候会边看杂志看做笔记。比起那些化学公式，物理定律，这些杂志对我更有吸引力.
不得不说20岁以前是学习和摸索的黄金时期，因为干扰的事物较少，承担的责任和风险也要小很多。有充沛的时间去干自己喜欢的事情。20岁以后就会有各种破事缠身。
锻炼身体，增强体质 最近微博上出现的猝死的消息略多，大半是做IT的，长期的加班身体拖成了废铁.前几天听了一期大狗熊的播客，设计师的健康问题，大致分析了IT行业从业人员的健康现状和应对策略，分享一下。
It行业猝死平均年龄为:37.5岁
身体疾病的原因:加班,肥胖,久坐电脑前,饮食习惯不良喜欢吃辛辣油炸食品, 运动少,夜猫型晚上不睡白天补觉，喜欢烟酒, 抑郁,生活压力大.
身体疾病的征兆: 疲劳,心悸,胸痛,胸闷
应对策略:清淡低脂食物,每天至少6小时的睡眠,适当运动,良好心态,扩大交际圈多交朋友,适量烟酒,扩大自己的兴趣爱好.
反观自己的生活状态,中枪n次,经常加班就无需再说了,除了睡觉时间基本上是对着电脑,因为实在是再受不了每天十一点的加班，和boss去谈判,约定是每天9点下班，但是得在一个短期限内完成任务，他是理论是:任务完成度=工作时间长度,实在是不敢苟同.关于运动量,现在倒是每周有两天晚上有活动,一是台球,一是羽毛球,周末基本上是窝在家里懒得动.
podcast 最近发现的新大陆.
刚开始是听Teahour.fm 感觉这类访谈这类播客挺好玩的,然后顺藤摸瓜摸出了一大把. 有科技类，也有生活搞笑类的.这种媒介的好处是不用花时间去阅读,可以在线或者下载在手机上听,适合上班,公交上,或者在旅行途中. 听了一段时间也萌发一个想法:可以以播客为载体去组织一个社群,然后可以商业化.这样的用户比起微博上的粉显然要优质得多。这个领域应该好像还少人涉足。
 Teahour.fm: 面向程序员的访谈节目 iBuick :ios程序开发,&amp;laquo;OS X LION 高手进阶&amp;raquo;作者 tinyfool: ios开发 大狗熊有话要说: ios开发者,生活，苹果 赵畅不误: 屌丝不哭,站起来撸 友的聊 : 科技播客,游戏,电影,数码产品 大内密谈: 生活播客，美食，旅行，音乐，艳遇 坏蛋调频: 无节操,无下限. </content>
    </entry>
    
     <entry>
        <title>cocos2d-x 骨骼动画</title>
        <url>https://farwmarth.com/post/cocos2d-x-%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/</url>
        <categories>
          <category>cocos2d-x</category>
        </categories>
        <tags>
          <tag>cocos2d-x</tag>
        </tags>
        <content type="html"> 何谓骨骼动画? 骨骼动画包括两部分:蒙皮和系列相关联的骨头.在时间线上蒙皮会跟随骨骼的位置改变位置形成动画。
骨骼动画的优势?  骨骼绑定可以让动画更精准，更真实自然，并可通过程序动态控制 动画各部分采用拼接方式，占用位图／内存资源少 骨骼显示对象与骨骼的逻辑分离，可在不影响动画播放的情况下动态更换  如何制作骨骼动画? 这个是设计人员的活，flash cc 中已经取消了骨骼动画,flash cs6中还有。
详解：http://help.adobe.com/zh_CN/flash/cs/using/WS58BD3A02-DA25-488f-B534-AE5463A24833.html http://www.adobe.com/cn/devnet/flash/articles/character_animation_ik.html
DragonBones 　DragonBones是一套开源的 2D骨骼动画框架和工具，它包含了基于Flash Pro的骨骼动画编辑面板.DragonBonesDesignPanel及骨骼动画ActionScript框架。它可以让开发者运用熟悉的Flash Pro元
件及时间轴编辑方式，快速创建2D骨骼动画，并运用到Flash或其他技术的应用中.DragonBones在cocoStudio适配下可以用于cocos2d-x.DragonBones快速指南:[http://dragonbones.github.io/getting_started_cn.html DragonBones](http://dragonbones.github.io/getting_started_cn.html DragonBones)
DragonBone and cocos2d-x 1 zengrong修改的DragonBone插件，为cocos2d-x专用.下载地址: http://zengrong.net/download/115/ 2 导出zip格式。 3 导出的zip分为两部分，一个xml文件包括骨骼的信息,以及导出的图片。 4 将zip解压,打开cocostudio动作编辑器.导入flash项目，要选择解压的skeleton_and_texture.xml 5通过cocostudio导出的包括三个文件
6 在代码中使用
CCArmatureDataManager::sharedArmatureDataManager()-&amp;gt;addArmatureFileInfo(&amp;#34;warr0.png&amp;#34;, &amp;#34;warr0.plist&amp;#34;, &amp;#34;warr.ExportJson&amp;#34;);CCArmature *armature = CCArmature::create(&amp;#34;warr&amp;#34;);armature-&amp;gt;getAnimation()-&amp;gt;playByIndex(3);armature-&amp;gt;setScale(0.5f);armature-&amp;gt;setPosition(ccp(visibleSize.width * 0.5, visibleSize.height * 0.5));this-&amp;gt;addChild(armature,2);要注意的是CCArmature::create(“warr”);这个要在ExportJson中描述的name一样
运行效果
参考:
http://zengrong.net/post/1915.htm
http://zengrong.net/post/1911.htm
</content>
    </entry>
    
     <entry>
        <title>抓抓包</title>
        <url>https://farwmarth.com/post/%E6%8A%93%E6%8A%93%E5%8C%85/</url>
        <categories>
          <category>破解</category>
        </categories>
        <tags>
          <tag>破解</tag>
        </tags>
        <content type="html"> WPE PRO 基于进程的抓包工具.强大的网络封包编辑器，wpe可以截取网络上的信息，修改封包数据，是外挂制作的常用工具
还没研究怎么弄外挂，先拿来看看软件的get,post数据.如七色追剧助手。
Target program : 选择要抓的进程,然后点黑色箭头就可以启动抓包了。
软件发送网络请求后，停止抓包，可以看到一些数据:
可以看到请求的资源和参数。以及返回.这样相当我们可以拿到一个api.如下:
http://www.7se.com/sp?username=dd&amp;amp;keyWord=%E6%81%A9%E8%B5%90%E4%B9%8B%E5%9C%B0
WSExplorer Wireshark 基于网卡的封包工具.是一个网络封包分析软件,winreshark并非一个入侵软件.wireshark的开发简史也有点意思,原名为Ethereal,他妈人为GeraldCombs,97年开始开发，中断过几次开发后，在98年发了每一版本，然后combs收到世界各地的修补程式和建议，陆续有很多人参与开发，包括教师等超过千人参与过开发，后因商标问题更名为wireshark.从图标可以看出是一只鲨鱼的背鳍。呃，废话太多了。。
先来看看过滤器,过滤器分两种  捕捉过滤器(CaptureFilter):控制捕捉的数据大小   Protocol(协议): 可能的值ether, fddi, ip, arp, rarp, decnet, lat, sca, moprc, mopdl, tcp ,udp Direction(方向):可能的值: src(源), dst(目的), src and dst, src or dst Host(s):可能的值:net, port(端口), host(ip), portrange Logical Operations(逻辑运算):not ,and,or  例子:
tcp dst port 8080 目的tcp端口为8080的封包dst host 42.121.110.83 目的ip为42.121.110.83的封包ether host e0-05-c5-44-b1-3c 捕捉此mac地址的封包src portrange 2000-2500 来源在此端口范围的封包dst host 42.121.110.83 and dst port 8080 目的ip为42.121.110.83,端口为8080的封包http &amp;amp;&amp;amp; ip.dst == 45.32.254.126 显示过滤器(DisplayFilter): 定位和缩小数据  Comparison operators （比较运算符）:
例子:
ip.addr == 10.1.1.1 //显示来源或目的IP地址为10.1.1.1的封包。ip.src != 10.1.2.3 or ip.dst != 10.4.5.6 //显示来源不为10.1.2.3或者目的不为10.4.5.6的封包。tcp.port == 25 //显示来源或目的TCP端口号为25的封包。tcp.dstport == 25 //显示目的TCP端口号为25的封包。表达式正确背景为绿色，错误会为红色.
开始抓包 捕捉时要选择指定的网上，可以指定捕捉过滤器，我这里还是拿七色追剧助手为便，这个过滤器的意思是目的地址ip为112.82.244.196的封包. 如果要把抓取的包数据保存成文件，可以填写caputure files. 点击start开始抓包。
tcp的三次握手
1. (Client) –&amp;gt; [SYN] –&amp;gt; (Server)
假如Client和Server通讯. 当Client要和Server通信时，Client首先向Server发一个SYN (Synchronize) 标记的包，告诉Server请求建立连接.
注意: 一个 SYN包就是仅SYN标记设为1的TCP包(参见TCP包头Resources). 认识到这点很重要，只有当Server收到Client发来的SYN包，才可建立连接，除此之外别无他法。因此，如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不 能让外部任何主机主动建立连接。
2. (Client) &amp;lt;– [SYN/ACK] &amp;lt;–(Server)
接着，Server收到来自Client发来的SYN包后，会发一个对SYN包的确认包(SYN/ACK)给Client，表示对第一个SYN包的确认，并继续握手操作.
注意: SYN/ACK包是仅SYN 和 ACK 标记为1的包.
3. (Client) –&amp;gt; [ACK] –&amp;gt; (Server)
Client收到来自Server的SYN/ACK 包,Client会再向Server发一个确认包(ACK)，通知Server连接已建立。至此，三次握手完成，一个TCP连接完成。
Note: ACK包就是仅ACK 标记设为1的TCP包. 需要注意的是当三此握手完成、连接建立以后，TCP连接的每个包都会设置ACK位
和WPE PRO，get数据差不多。包数据更详细，有载入的时间等等。
其他工具  http://freecap.ru/eng/ :可以把不支持socks代理的软件通过freecap设置的socks代理连接到外网 httptunnel
HttpTuunnel(也叫Http隧道，Http穿梭），是这样一种技术:它用HTTP协议在要通信的Client和Server建立起一条”Tunnel”，然后Client和Server之间的通信，都是在这条Tunnel的基础之上。  HttpTunnel通常被用在受限的网络环境中，比如在NAT环境中的Client，受防火墙限制的环境中的Client等，在这样的环境中，Client不能直接连接到公网(WAN)的Server，这时候就可以通过HttpTunnel技术，来解决上述问题。 http://www.wuzesheng.com/?p=2168
 WinPcap  android 抓包 工具:android内核基于linux,linux包分析工具tcpdump. 前提条件:手机已root.
 复制tcpdump到手机: adb push C:/tcpdump /data/local/tcpdump 修改tcpdump权限: chmod 777 /data/local/tcpdump 进入shell: adb shell 进入root: su 运行抓包到存储卡: /data/local/tcpdump -i any -p -s 0 -w /sdcard/capture.pcap 运行应用后按ctrl&#43;c中断抓包. 将抓包结果复制到本地: adb pull /sdcard/capture.pcap c:/ 使用Wireshark等工具查看抓包文件capture.pcap 例: /data/local/tcpdump -w /sdcard/target.pcap host 192.169.1.1 and port 10000 ip 为192.169.1.1端口为10000的数据包保存到文件target.pcap.  ##Charles ##Http Analyzer ##Fiddler ##Network Monitor
##Packet Capture ##bitshark ##网络嗅探Wi.cap
</content>
    </entry>
    
     <entry>
        <title>a* 初探</title>
        <url>https://farwmarth.com/post/a%E6%98%9F%E5%88%9D%E6%8E%A2/</url>
        <categories>
          <category>算法</category>
        </categories>
        <tags>
          <tag>算法</tag>
        </tags>
        <content type="html"> 以前面试被问到过一次，后来没去做这一块的东西就没去理会了。准备辞职找下一个工作，捡起来看了下。
A*算法是一种在多节点网络上寻求最短路径的方法.属于启发式搜索的一种。
先描述一下a星的几个基本概念.
 节点:A星寻路中会将搜索区域划分为一个个小单元。每个单元即一个节点，一般为方格. 开启列表:还未展开的节点列表 关闭列表:已经遍历过的节点列表   A*算法的公式为：f(n)=g(n)&#43;h(n) **G **表示从起点 A 移动到网格上指定方格的移动耗费 (可沿斜方向移动). 一般将普通移动耗费设为值10,斜角移动耗费为14 **H **表示从指定的方格移动到终点 B 的预计耗费 (H 有很多计算方法, 这里我们设定只可以上下左右移动).  曼哈顿式为h(n) =dx(到终点的水平距离) &#43; dy(到终点的竖直距离) ,本文使用为此计算方法.  欧几里得式:h(n) = sqrt(dx^2 &#43; dy^2)  欧几里得式在对角线上有更低的启发值，产生的路径更符合人的习惯，但曼哈顿式数学运算功率更低。所以一般采用曼哈顿式
寻路步骤
把起始节点加进open listwhile (open list 不空) {当前节点 = open list中F值最低的节点if (当前节点 == 目标节点) {路径完成从目标节点开始寻找其母节点，直到母节点是起始节点位置，得到路径}else {把当前节点移入到close list检视当前节点的每个相邻节点for (每个相邻节点){if (该节点不在closed list中 and 该节点不是障碍物){if (该节点不在open list中 ){把该节点移进open list计算其F值记录该节点的母节点为当前节点}else{if(G值更低){该节点的父节点改成当前节点并且重新计算该节点的G和F值}}}}}}if (还没有找到路径) {无法从起始点到达目的地}actionscript实现:
package astar{import flash.display.Sprite;import flash.events.Event;import flash.events.MouseEvent;class AStarTest extends Sprite{private const SIZE:int = 40;private const DIAGONAL:int = 14; //对角线	private const PARALLEL:int = 10; //非对角线private var _map:Array = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]];private var _nodeSprite:Array = [];private var _clickCout:int;private var _fristNodeSp:Rect;private var _secondNodeSp:Rect;private var _firstPoint:Point = new Point();private var _sencondPoint:Point = new Point();private var _openList:Array = [];private var _closeList:Array = [];private var _path:Array = [];public function AStarTest(){if (stage)init(null);elseaddEventListener(Event.ADDED_TO_STAGE, init);}private function init(e:Event):void{removeEventListener(Event.ADDED_TO_STAGE, init);initMap();initEventListener();}private function initEventListener():void{stage.addEventListener(MouseEvent.CLICK, clickHandler);}private function clickHandler(e:MouseEvent):void{if (_clickCout &amp;amp;gt;= 2){_clickCout = 0;clear();}turnNode(e.stageX, e.stageY, _clickCout);}private function clear():void{if (_fristNodeSp)_fristNodeSp.create();if (_secondNodeSp)_secondNodeSp.create();for (var i:int = 0; i &amp;lt; _path.length; i&#43;&#43;){_nodeSprite[_path[i].x][_path[i].y].create();}}private function initMap():void{for (var i:int = 0; i &amp;lt; _map.length; i&#43;&#43;){var rol:Array = _map[i];var node:Array = [];for (var j:int = 0; j &amp;lt; rol.length; j&#43;&#43;){var rect:Rect = new Rect(rol[j]);rect.x = j * SIZE;rect.y = i * SIZE;addChild(rect);node.push(rect);}_nodeSprite.push(node);}}private function turnNode(x:Number, y:Number, nodeSite:int):void{var col:int = x / SIZE;var row:int = y / SIZE;var len:int = (col &#43; 1) * (row &#43; 1);if (_nodeSprite[row] &amp;amp;&amp;amp; _nodeSprite[row][col]){_clickCout&#43;&#43;;var rect:Rect = _nodeSprite[row][col];if (nodeSite == 0){_firstPoint.x = row;_firstPoint.y = col;_fristNodeSp = rect;}if (nodeSite == 1){_sencondPoint.x = row;_sencondPoint.y = col;_secondNodeSp = rect;var endPoint:Point = findPath(_firstPoint, _sencondPoint);if (endPoint != null){while (endPoint != null){_path.unshift(endPoint);endPoint = endPoint.parent;}for (var i:int = 0; i &amp;lt; _path.length; i&#43;&#43;){var po:Point = _path[i];var poNode:Rect = _nodeSprite[po.x][po.y];poNode.turn();}}}rect.turn();}}private function findPath(first:Point, second:Point):Point{_openList = [];_closeList = [];_path = [];trace();trace(first, second);_openList.push(first);while (_openList.length != 0){var po:Point = inList(_openList, second);if (po)return po;_openList.sortOn([&amp;#34;f&amp;#34;]);var curr:Point = _openList.shift();_closeList.push(curr);//得到邻近的点	var sorround:Array = getSorround(curr);trace(curr);for (var i:int = 0; i &amp;lt; sorround.length; i&#43;&#43;){var sorroundPoint:Point = sorround[i];if (inList(_openList, sorroundPoint)){FoundPoint(curr, sorroundPoint);}else{NotFoundPoint(curr, second, sorroundPoint);}}}return null;}private function NotFoundPoint(curr:Point, second:Point, point:Point):void{point.parent = curr;point.g = cacG(curr, point);point.h = cacH(second, point);point.cacF();_openList.push(point);}//计算G值, 如果比原来的大, 就什么都不做, 否则设置它的父节点为当前点,并更新G和F	private function FoundPoint(curr:Point, point:Point):void{var g:int = cacG(curr, point);if (g &amp;lt; point.g){point.parent = curr;point.g = g;point.cacF();}}private function cacG(curr:Point, point:Point):int{var diff:int = Math.abs(curr.x - point.x) &#43; Math.abs(curr.y - point.y);var g:int = (diff == 2) ? DIAGONAL : PARALLEL;var parentG:int = (curr.parent != null) ? curr.parent.g : 0;return g &#43; parentG;}//H值不计算折点	private function cacH(second:Point, point:Point):int{var step:int = Math.abs(second.x - point.x) &#43; Math.abs(second.y - point.y);return step * PARALLEL;}private function getSorround(curr:Point):Array{var surroundPoints:Array = [];for (var i:int = curr.x - 1; i &amp;lt;= curr.x &#43; 1; i&#43;&#43;){for (var j:int = curr.y - 1; j &amp;lt;= curr.y &#43; 1; j&#43;&#43;){var point:Point = new Point();point.x = i;point.y = j;if (canReach(curr, point)){surroundPoints.push(point);}}}return surroundPoints;}private function canReach(curr:Point, point:Point):Boolean{if (!inMap(point.x, point.y) || inList(_closeList, point))return false;return true;}private function inMap(x:int, y:int):Boolean{if (_map[x] &amp;amp;&amp;amp; _map[x][y] &amp;amp;&amp;amp; _map[x][y] == 1)return true;return false;}private function inList(_list:Array, point:Point):Point{if (!_list || _list.length == 0)return null;for (var i:int = 0; i &amp;lt; _list.length; i&#43;&#43;){var po:Point = _list[i];if (po.x == point.x &amp;amp;&amp;amp; po.y == point.y)return po;}return null;}}}import flash.display.Sprite;class Rect extends Sprite{private var _enable:int;public function Rect(enable:int){this._enable = enable;create();}public function create():void{this.graphics.clear();if (_enable)this.graphics.lineStyle(1, 0);elsethis.graphics.beginFill(0, 1);this.graphics.drawRect(0, 0, 40, 40);this.graphics.endFill();}public function turn():void{this.graphics.clear();this.graphics.beginFill(0x00ff00, 1);this.graphics.drawRect(0, 0, 40, 40);this.graphics.endFill();}}class Point{private var _x:int;private var _y:int;private var _g:int;private var _h:int;private var _f:int;private var _parent:Point;public function get x():int{return _x;}public function set x(value:int):void{_x = value;}public function get y():int{return _y;}public function set y(value:int):void{_y = value;}public function get g():int{return _g;}public function set g(value:int):void{_g = value;}public function get h():int{return _h;}public function set h(value:int):void{_h = value;}public function get f():int{return _f;}public function set f(f:int):void{this._f = f;}public function get parent():Point{return _parent;}public function set parent(value:Point):void{_parent = value;}public function cacF():void{_f = _g &#43; _h;}public function toString():String {return &amp;#34;[Point x=&amp;#34; &#43; x &#43; &amp;#34; y=&amp;#34; &#43; y &#43; &amp;#34; g=&amp;#34; &#43; g &#43; &amp;#34; h=&amp;#34; &#43; h &#43; &amp;#34; f=&amp;#34; &#43; f &#43; &amp;#34;]&amp;#34;;}}参考 :
http://www.lihuasoft.net/article/show.php?id=3523
http://www.cnblogs.com/technology/archive/2011/05/26/2058842.html
</content>
    </entry>
    
     <entry>
        <title>一次失败的逆向工程</title>
        <url>https://farwmarth.com/post/%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
        <categories>
          <category>破解</category>
        </categories>
        <tags>
          <tag>破解</tag>
        </tags>
        <content type="html"> 源起是要拿一下一个韩国游戏的图片资源,本以为挺容易的,google了一下, ipa也是压缩包格式,改成zip解压.然后把png图片拿出来，发现有一部分图片在windows上无法解析.继续google.原来是在编译打包到app的过程中，原有的png都被在最后加上了特定都数据段，这样从app里直接取出来图片既不能看，也不能用，所以需要工具来进行还原.网上python脚本一大堆，down下来还原了一下图片，确实可以恢复正常。但是这堆图片里面都是无关紧要的素材，想了想，应该是把图片弄成了自定义格式。在目录下果然发现了一个spr的目录，里面有一堆自定义扩展名叫f3spr的文件，用文本编辑器打开发现是个xml.有一段数据结构如下.
呃，这段数据像是被加密的png图片，再google还真发现可以将图片压缩成base64字符串。c#代码如下:
using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using System.IO;using System.Xml;namespace WindowsFormsApplication1{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void button1_Click(object sender, EventArgs e){try{int readbyte = 0;int bytestoread = 1044;XmlTextReader xmltxtrd = new XmlTextReader(&amp;#34;C:/11.xml&amp;#34;);FileStream fs = new FileStream(&amp;#34;C:/002.png&amp;#34;, FileMode.Create);BinaryWriter bw = new BinaryWriter(fs);byte[] base64buffer = new byte[bytestoread];while (xmltxtrd.Read()){if (xmltxtrd.NodeType == XmlNodeType.Element &amp;amp;&amp;amp; xmltxtrd.Name == &amp;#34;_data_ImageData&amp;#34;){Console.WriteLine(&amp;#34;_data_ImageData&amp;#34;);do{Console.WriteLine(&amp;#34;cout............&amp;#34;);//readbyte = xmltxtrd.ReadBase64(base64buffer, 0, bytestoread); readbyte = xmltxtrd.ReadElementContentAsBase64(base64buffer, 0, bytestoread);bw.Write(base64buffer, 0, readbyte);}while (bytestoread &amp;amp;lt;= readbyte);break;}}bw.Flush();bw.Close();fs.Close();xmltxtrd.Close();MessageBox.Show(&amp;#34;读写结束！&amp;#34;);}catch (Exception ex){MessageBox.Show(ex.ToString());}}private void button2_Click(object sender, EventArgs e){try{XmlDocument myxmldoc = new XmlDocument();myxmldoc.Load(&amp;#34;C:/11.xml&amp;#34;);XmlElement elem = myxmldoc.CreateElement(&amp;#34;_data_ImageData&amp;#34;);FileStream fs = new FileStream(&amp;#34;C:/001.png&amp;#34;, FileMode.Open);BinaryReader br = new BinaryReader(fs);byte[] imagebuffer = new byte[br.BaseStream.Length];br.Read(imagebuffer, 0, Convert.ToInt32(br.BaseStream.Length));string textstring = System.Convert.ToBase64String(imagebuffer);fs.Close();br.Close();XmlText text = myxmldoc.CreateTextNode(textstring);myxmldoc.DocumentElement.AppendChild(elem);myxmldoc.DocumentElement.LastChild.AppendChild(text);myxmldoc.Save(&amp;#34;C:/11.xml&amp;#34;);MessageBox.Show(&amp;#34;读写结束！&amp;#34;);}catch (Exception ex){MessageBox.Show(ex.ToString());}}}}加密后数据格式和f3spr的格式近似,本以为可以还原这个图片资源，然后写个批处理就搞定了。结果还原的png无法显示。用winHex看了下。
上图依次是png,rar和f3spr还原图片在winhex下的数据.正常图片和压缩文件都要数据段标识.而我还原的png图片却是一堆乱码。未果。在f3spr里看到一个数据段
这个看起来有点像texturepacker打包的plist文件。之前的是图片数据是无疑的,可能是在转成base64之前用byte数组错位加密了一下。
应该有android版本.搜索了一下果然有.又有了一丝希望的小火花。破解apk还是熟悉一些。逆向了一下导成android工程.
果然是cocos2dx又一作品。从包结构名可以看出公司域名:http://www.n2play.co.kr/.一堆韩语看不懂.google了一翻这引擎，在github找了一下看是否源了这类库。还是没有结果。看了下代码结构，
发现那f3spr文件解析是用调的c&#43;&#43;代码。so文件怎么破啊。。只能反汇编没法还原。。卡住了。功力不够了。
</content>
    </entry>
    
     <entry>
        <title>android 删除未引用资源,优化字节码</title>
        <url>https://farwmarth.com/post/android-%E5%88%A0%E9%99%A4%E6%9C%AA%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E5%AD%97%E8%8A%82%E7%A0%81/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag>
        </tags>
        <content type="html"> 一 资源文件 删除未使用图片资源 .
adt 的 android tool有一个检测app潜在问题的选项叫Run Lint.检测之后有各种各种检测的信息,包括px单位，资源未使用等等。在android sdk里也有这个工具Lint.
但这个并不能直接将未使用的资源删除。于是想着把这个log信息导成txt然后用脚本去删除未使用资源。
linux 平台 用sdk :
Run lint under &amp;#39;/SDK/tools/lint&amp;#39;, save the output to file.lint . |grep &amp;#39;to be unused&amp;#39; &amp;amp;gt; /tmp/unused.txtRemove all unused resouces.rm `cat /tmp/unused.txt | gawk -F: &amp;#39;{print $1}&amp;#39; |sed -e &amp;#39;s/ *$//&amp;#39;|grep png`Rebuild the project with &amp;#39;ant release&amp;#39;.windows 平台可以用adt生成的log保存为txt.
bat脚本:
@echo offSetlocal ENABLEDELAYEDEXPANSIONset dirpath=&amp;#34;res\drawable&amp;#34;lint .| find %dirpath%|find &amp;#34;UnusedResources&amp;#34; &amp;amp;gt;a.txtfor /f %%i in (a.txt) do (set tempstr=%%idel !tempstr:~0,-1!)del a.txtpause二 优化字节码 ProGuard是一个压缩、优化和混淆Java字节码文件的免费的工具，它可以删除无用的类、字段、方法和属性。可以删除没用的注释，最大限度地优化字节码文件。它还可以使用简短的无意义的名称来重命名已经存在的类、字段、方法和属性
</content>
    </entry>
    
     <entry>
        <title>JAVA内存分配</title>
        <url>https://farwmarth.com/post/java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
        <categories>
          <category>java</category>
        </categories>
        <tags>
          <tag>java</tag>
        </tags>
        <content type="html">  寄存器：我们在程序中无法控制 栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中 堆：存放用new产生的数据 静态域：存放在对象中用static定义的静态成员 常量池：存放常量 非RAM存储：硬盘等永久存储空间  Java内存分配中的栈 在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。
当在一段代码块定义一个变量时，Java就在栈中 为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。
Java内存分配中的堆 堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
在堆中产生了一个数组或对象后，还可以 在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 引用变量就相当于是 为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称。
引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序 运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍 然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。
实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！
常量池 (constant pool)
常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值(final)还包含一些以文本形式出现的符号引用，比如：
 类和接口的全限定名; 字段的名称和描述符; 方法和名称和描述符。  虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和 floating point常量）和对其他类型，字段和方法的符号引用。
对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的， 对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引 用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。 在程序执行的时候,常量池 会储存在Method Area,而不是堆中。
堆与栈
Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、 anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存 大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态 分配内存，存取速度较慢。
栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是 确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int, short, long, byte, float, double, boolean, char）和对象句柄(引用)。
栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：
int a = 3;int b = 3;编译器先处理inta=3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。
这时，如果再令 a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响 到b的值。
要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。
String是一个特殊的包装类数据。可以用：
String str = new String(&amp;#34;abc&amp;#34;);String str = &amp;#34;abc&amp;#34;;两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。而第二种是先在栈中创建一个对String类的对象引用变量str，然后通过符号引用去字符串常量池 里找有没有&amp;quot;abc&amp;rdquo;,如果没有，则将&amp;quot;abc&amp;quot;存放进字符串常量池 ，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。
比较类里面的数值是否相等时，用equals()方法;当测试两个包装类的引用是否指向同一个对象时，用==，下面用例子说明上面的理论。
String str1 = &amp;#34;abc&amp;#34;;String str2 = &amp;#34;abc&amp;#34;;System.out.println(str1==str2); //true可以看出str1和str2是指向同一个对象的。
String str1 =new String (&amp;#34;abc&amp;#34;);String str2 =new String (&amp;#34;abc&amp;#34;);System.out.println(str1==str2); // false用new的方式是生成不同的对象。每一次生成一个。
因此用第二种方式创建多个”abc”字符串,在内存中 其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(&amp;ldquo;abc&amp;rdquo;);的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。
另 一方面, 要注意: 我们在使用诸如String str = &amp;ldquo;abc&amp;rdquo;;的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的 对象。只有通过new()方法才能保证每次都创建一个新的对象。
由于String类的immutable性质，当String变量需要经常变换 其值时，应该考虑使用StringBuffer类，以提高程序效率。
 首先String不属于8种基本数据类型，String是一个对象。因为对象的默认值是null，所以String的默认值也是null;但它又是一种特殊的对象，有其它对象没有的一些特性。 &#43;** new String()和new String(”&amp;quot;)都是申明一个新的空字符串，是空串不是null;** String str=”kvill”;String str=new String (”kvill”)的区别  示例：
String s0=&amp;#34;kvill&amp;#34;;String s1=&amp;#34;kvill&amp;#34;;String s2=&amp;#34;kv&amp;#34; &#43; &amp;#34;ill&amp;#34;;System.out.println( s0==s1 );System.out.println( s0==s2 );结果为：
truetrue首先，我们要知结果为道Java 会确保一个字符串常量只有一个拷贝。
因为例子中的 s0和s1中的”kvill”都是字符串常量，它们在编译期就被确定了，所以s0==s1为true;而”kv”和”ill”也都是字符串常量，当一个字 符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中” kvill”的一个引用。所以我们得出s0==s1==s2;用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。
示例：
String s0=&amp;#34;kvill&amp;#34;;String s1=new String(&amp;#34;kvill&amp;#34;);String s2=&amp;#34;kv&amp;#34; &#43; new String(&amp;#34;ill&amp;#34;);System.out.println( s0==s1 );System.out.println( s0==s2 );System.out.println( s1==s2 );结果为：
falsefalsefalse例2中s0还是常量池 中&amp;quot;kvill”的应用，s1因为无法在编译期确定，所以是运行时创建的新对象”kvill”的引用，s2因为有后半部分 new String(”ill”)所以也无法在编译期确定，所以也是一个新创建对象”kvill”的应用;明白了这些也就知道为何得出此结果了。
 String.intern()：  再补充介绍一点：存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的 intern()方法就是扩充常量池的 一个方法;当一个String实例str调用intern()方法时，Java 查找常量池中 是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常 量池中增加一个Unicode等于str的字符串并返回它的引用;看示例就清楚了
示例：
String s0= &amp;#34;kvill&amp;#34;;String s1=new String(&amp;#34;kvill&amp;#34;);String s2=new String(&amp;#34;kvill&amp;#34;);System.out.println( s0==s1 );System.out.println( &amp;#34;**********&amp;#34; );s1.intern();s2=s2.intern(); //把常量池中&amp;#34;kvill&amp;#34;的引用赋给s2System.out.println( s0==s1);System.out.println( s0==s1.intern() );System.out.println( s0==s2 );结果为：
falsefalse //虽然执行了s1.intern(),但它的返回值没有赋给s1true //说明s1.intern()返回的是常量池中&amp;#34;kvill&amp;#34;的引用true最后我再破除一个错误的理解：有人说，“使用 String.intern() 方法则可以将一个 String 类的保存到一个全局 String 表中 ，如果具有相同值的 Unicode 字符串已经在这个表中，那么该方法返回表中已有字符串的地址，如果在表中没有相同值的字符串，则将自己的地址注册到表中”如果我把他说的这个全局的 String 表理解为常量池的话，他的最后一句话，”如果在表中没有相同值的字符串，则将自己的地址注册到表中”是错的：
示例：
String s1=new String(&amp;#34;kvill&amp;#34;);String s2=s1.intern();System.out.println( s1==s1.intern() );System.out.println( s1&#43;&amp;#34; &amp;#34;&#43;s2 );System.out.println( s2==s1.intern() );结果：
falsekvill kvilltrue在这个类中我们没有声名一个”kvill”常量，所以常量池中一开始是没有”kvill”的，当我们调用s1.intern()后就在常量池中新添加了一 个”kvill”常量，原来的不在常量池中的”kvill”仍然存在，也就不是“将自己的地址注册到常量池中”了。
s1==s1.intern() 为false说明原来的”kvill”仍然存在;s2现在为常量池中”kvill”的地址，所以有s2==s1.intern()为true。
 关于equals()和==:  这个对于String简单来说就是比较两字符串的Unicode序列是否相当，如果相等返回true;而==是 比较两字符串的地址是否相同，也就是是否是同一个字符串的引用。
 关于String是不可变的  这一说又要说很多，大家只 要知道String的实例一旦生成就不会再改变了，比如说：String str=”kv”&#43;”ill”&#43;” “&#43;”ans”; 就是有4个字符串常量，首先”kv”和”ill”生成了”kvill”存在内存中，然后”kvill”又和” ” 生成 “kvill “存在内存中，最后又和生成了”kvill ans”;并把这个字符串的地址赋给了str,就是因为String的”不可变”产生了很多临时变量，这也就是为什么建议用StringBuffer的原 因了，因为StringBuffer是可改变的。
下面是一些String相关的常见问题：
String中的final用法和理解
final StringBuffer a = new StringBuffer(&amp;#34;111&amp;#34;);final StringBuffer b = new StringBuffer(&amp;#34;222&amp;#34;);a=b;//此句编译不通过final StringBuffer a = new StringBuffer(&amp;#34;111&amp;#34;);a.append(&amp;#34;222&amp;#34;);// 编译通过可见，final只对引用的&amp;quot;值&amp;rdquo;(即内存地址)有效，它迫使引用只能指向初始指向的那个对象，改变它的指向会导致编译期错误。至于它所指向的对象 的变化，final是不负责的。
String常量池问题的几个例子
下面是几个常见例子的比较分析和理解：
String a = &amp;#34;a1&amp;#34;;String b = &amp;#34;a&amp;#34; &#43; 1;System.out.println((a == b)); //result = trueString a = &amp;#34;atrue&amp;#34;;String b = &amp;#34;a&amp;#34; &#43; &amp;#34;true&amp;#34;;System.out.println((a == b)); //result = trueString a = &amp;#34;a3.4&amp;#34;;String b = &amp;#34;a&amp;#34; &#43; 3.4;System.out.println((a == b)); //result = true分析：JVM对于字符串常量的&amp;quot;&#43;&amp;quot;号连接，将程序编译期，JVM就将常量字符串的&amp;quot;&#43;&amp;quot;连接优化为连接后的值，拿&amp;quot;a&amp;rdquo; &#43; 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。
String a = &amp;#34;ab&amp;#34;;String bb = &amp;#34;b&amp;#34;;String b = &amp;#34;a&amp;#34; &#43; bb;System.out.println((a == b)); //result = false分析：JVM对于字符串引用，由于在字符串的&amp;quot;&#43;&amp;quot;连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即&amp;quot;a&amp;rdquo; &#43; bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。
String a = &amp;#34;ab&amp;#34;;final String bb = &amp;#34;b&amp;#34;;String b = &amp;#34;a&amp;#34; &#43; bb;System.out.println((a == b)); //result = true分析：和[3]中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量 池中或嵌入到它的字节码流中。所以此时的&amp;quot;a&amp;rdquo; &#43; bb和&amp;quot;a&amp;rdquo; &#43; &amp;ldquo;b&amp;quot;效果是一样的。故上面程序的结果为true。
String a = &amp;#34;ab&amp;#34;;final String bb = getBB();String b = &amp;#34;a&amp;#34; &#43; bb;System.out.println((a == b)); //result = falseprivate static String getBB() {return &amp;#34;b&amp;#34;;}分析：JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和&amp;quot;a&amp;quot;来动态连接并分配地址为b，故上面 程序的结果为false。
通过上面4个例子可以得出得知：
String s = &amp;quot;a&amp;quot; &#43; &amp;quot;b&amp;quot; &#43; &amp;quot;c&amp;quot;;就等价于String s = &amp;quot;abc&amp;quot;;
String a = &amp;#34;a&amp;#34;;String b = &amp;#34;b&amp;#34;;String c = &amp;#34;c&amp;#34;;String s = a &#43; b &#43; c;这个就不一样了，最终结果等于：
StringBuffer temp = new StringBuffer();temp.append(a).append(b).append(c);String s = temp.toString();由上面的分析结果，可就不难推断出String 采用连接运算符（&#43;）效率低下原因分析，形如这样的代码：
public class Test {public static void main(String args[]) {String s = null;for(int i = 0; i &amp;amp;lt; 100; i&#43;&#43;) {s &#43;= &amp;#34;a&amp;#34;;}}}每做一次 &#43; 就产生个StringBuilder对象，然后append后就扔掉。下次循环再到达时重新产生个StringBuilder对象，然后 append 字符串，如此循环直至结束。如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 N - 1 次创建和销毁对象的时间。所以对于在循环中要进行字符串连接的应用，一般都是用StringBuffer或StringBulider对象来进行 append操作。
String对象的intern方法理解和分析：
public class Test4 {private static String a = &amp;#34;ab&amp;#34;;public static void main(String[] args){String s1 = &amp;#34;a&amp;#34;;String s2 = &amp;#34;b&amp;#34;;String s = s1 &#43; s2;System.out.println(s == a);//false System.out.println(s.intern() == a);//true }}这里用到Java里面是一个常量池的问题。对于s1&#43;s2操作，其实是在堆里面重新创建了一个新的对象,s保存的是这个新对象在堆空间的的内容，所 以s与a的值是不相等的。而当调用s.intern()方法，却可以返回s在常量池中的地址值，因为a的值存储在常量池中，故s.intern和a的值相等。
总结 栈中用来存放一些原始数据类型的局部变量数据和对象的引用(String,数组.对象等等)但不存放对象内容
堆中存放使用new关键字创建的对象.
字符串是一个特殊包装类,其引用是存放在栈里的,而对象内容必须根据创建方式不同定(常量池和堆).有的是编译期就已经创建好，存放在字符串常 量池中，而有的是运行时才被创建.使用new关键字，存放在堆中
</content>
    </entry>
    
     <entry>
        <title>cocos2d-x vs开发</title>
        <url>https://farwmarth.com/post/cocos2d-x-vs%E5%BC%80%E5%8F%91/</url>
        <categories>
          <category>cocos2d-x</category>
        </categories>
        <tags>
          <tag>cocos2d-x</tag>
        </tags>
        <content type="html"> 一 vs环境配置 android环境配置不累赘了:http://farwmarth.com/?p=657
vs配置：下载cocos2d-x 2.1.4 , install-templates-msvc. bat是安装vs模板的，安装的时候发现2.1.4里竟然没有msv目录，下了2.1.3将msv目录复制到2.1.4重新运行，模板就安装成功了
没有文件扩展&amp;rdquo;.js&amp;quot;的脚本引擎 解决办法 在命令行运行JScript脚本时，遇到如下的错误提示： “输入错误: 没有文件扩展“.js”的脚本引擎。”
这样的错误,原因是因为JS扩展名的文件被其他软件关联了，需要取消关联。
如系统中安装了ULTRAEDIT或者E钻加密软件等，就需要去掉关联； 或者如下解决方法： 在运行中输入“regedit”进入注册表， 只需要把[HKEY_CLASSES_ROOT.js] 项下的那个默认值改成 &amp;ldquo;JSFile&amp;rdquo; 就可以正常运行JS 文件了。
还有一种创建项目的方式就是用tools目录下带的python脚本.注意python版本要为2.7,执行 python create_project.py -project BiuBiuSecondDemo -package com.jingui.BiuBiuSecondDemo -language cpp然后会生成projects目录下会生成一个工程
导入vs,就可以开始coding了。
二 cocos2d-x基本概念 下面这张图很生动地描述了cocos2d-x的舞台基本构成.
 CCDirector 导演，负责场景之间的导航 CCScene 类似flash中的场景，用Transition在场景之间跳转 CCLayer 层,表现各种元素的层级关系,接受触控反馈. CCSprite 精灵,如flash中Sprite,元素容器. CCAction 节点的动作  坐标系 在移动游戏开发过程中，有三种类型的坐标系你可能遇到：
UI坐标系: iOS/Android/Windows SDK/Flash中的通用UI坐标系: 起点坐标(x=0, y=0)位于左上角 · X轴从屏幕最左边开始，由左向右渐增 · Y轴坐标从屏幕最上方开始，由上向下渐增 详见下图
Direct3D坐标系: DirectX 使用Left-handed Cartesian Coordinate
OpenGL****和Cocos2d坐标系: Cocos2d-x/-html5/-iphone使用的坐标系和OpenGL的坐标系一样，名为“Right-handed Cartesian Coordinate Syste”。
下面这张图片有助于更好的阐述Cocos2d-x坐标：
AnchorPoint :锚点,单位为精灵的宽度百分比，而不是像素.默认为0.5,0.5位于精灵的中心,所以,当我们设置坐标为0,0时,精灵只有一半显示
三 notices 打开输出到控制台:
#define COCOS2D_DEBUG 1CCLog(&amp;#34;%f&amp;#34;,visibleSize.width);关闭fps显示:
CCDirector::sharedDirector()-&amp;amp;gt;setDisplayStats(false);</content>
    </entry>
    
     <entry>
        <title>visual studio 2012 备忘</title>
        <url>https://farwmarth.com/post/-visual-studio-2012-%E5%A4%87%E5%BF%98/</url>
        <categories>
          <category>c&#43;&#43;</category>
        </categories>
        <tags>
          <tag>c&#43;&#43;</tag>
        </tags>
        <content type="html"> 一 插件:   Productivity Power Tools
最近发现神器Productivity Power Tools也更新了支持VS2012的版本（之前只有适用于VS2008/2010的）,和上面的VS Commands不太相同，这个插件更倾向于补足VS本身的功能。比如Ctrl&#43;点击转到定义、一键整理C#的using和VB的Imports、括号自动补 全、标签栏按颜色分组、代码着色拷贝到HTML格式等.
  Visual Assist X Options 代码助手
  二 ** Tips**   在VS工程中，添加c/c&#43;&#43;工程中外部头文件及库的基本步骤：
 添加工程的头文件目录：工程&amp;mdash;属性&amp;mdash;配置属性&amp;mdash;c/c&#43;&#43;&amp;mdash;常规&amp;mdash;附加包含目录：加上头文件存放目录。 添加文件引用的lib静态库路径：工程&amp;mdash;属性&amp;mdash;配置属性&amp;mdash;链接器&amp;mdash;常规&amp;mdash;附加库目录：加上lib文件存放目录。 添加工程引用的lib动态文件名：工程&amp;mdash;属性&amp;mdash;配置属性&amp;mdash;链接器&amp;mdash;输入&amp;mdash;附加依赖项：加上lib文件名。 添加工程引用的dll动态库：把引用的dll放到工程的可执行文件所在的目录下。     VC/VS调试时按Alt&#43;8就可以看到相应的汇编代码。
  显示代码行号:工具/选项/文本编辑器/c/c&#43;&#43;/常规/行号
  项目依赖性配置 : 解决方案&amp;mdash;属性
  三 快捷键  格式化代码:Ctrl&#43;K&#43;D 检查括号匹配(在左右括号间切换): Ctrl &#43;] 全屏编辑：Alt&#43;Shift&#43;Enter 注释选定块：Control&#43;K,Control&#43;C 转跳到定义，很有用的快捷键：F12 删除整行：Control&#43;L 查看上次阅读处\反上次查看处：Control&#43;&amp;rdquo;-&amp;quot;\Control&#43;Shift&#43;&amp;rdquo;-&amp;rdquo; 转到行: CTRL &#43; G 设置断点：F9 运行不调试:Ctrl &#43;F5 调试：F5 生成解决方案: F7  四 ** Problem**  因为计算机中丢失MSVCP120D.dll 使用vs2013编译的vc代码，在其他机器上运行时需要安装vc2013运行库。如果没有vc运行库， 需要将 C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\redist\Debug_NonRedist\x86\Microsoft.VC120.DebugCRT(Debug) 或者 C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\redist\x86\Microsoft.VC120.CRT(Release)下的三个支持库文件拷到system32下。 或模拟器下面 （msvcp120.dll, msvcr120.dll, vccorlib120.dll） </content>
    </entry>
    
     <entry>
        <title>svn 常用命令和服务器配置</title>
        <url>https://farwmarth.com/post/-svn-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
        <categories>
          <category>svn</category>
        </categories>
        <tags>
          <tag>svn</tag>
        </tags>
        <content type="html"> Subversion 与版本控制 http://svnbook.red-bean.com/nightly/en/index.html http://svnbook.red-bean.com/nightly/zh/svn-book.html
SVN 操作 常用操作  svn propset svn:ignore &#39;test&#39; . 添加到忽略目录 svn update 更新 svn update -r 更新到一个指定版本 svn checkout 检出svn svn checkout --depth=empty 检出为空文件夹 svn revert -R . 递归还原当前目录 svn commit -m &#39;&#39; 提交 svn add * --force 强制提交所有 &#43; svn diff filename 比较文件 svn status 查看库文件状态 svn relocate svn switch --relocate 源地址 新地址 切换svn地址 svn info 查看目录信息 svn cleanup 清理文件 svn (del, remove, rm) 从svn中移除文件 svn export -r 导出一个没有svn文件夹的目录 svn merge -r 28:25  从28到25回滚 svn resolved filename 解决冲突 svn rm filename 从svn中删除 svn rm --keep-local filename 从svn中删除并保留本地文件  清除svn缓存的密码 rm -rf ~/.subversion/auth
svn的working copy locked并且cleanup不能恢复 产生这种情况大多是因为上次svn命令执行失败且被锁定了。如果cleanup没有效果的话只好手动删除锁定文件。cd 到svn项目目录下，然后执行如下命令del lock /q/s就把锁删掉了。设置svn 默认编辑器 export SVN_EDITOR=vimsvn ignore  若想创建一个文件夹，但不加入版本控制，即忽略这个文件夹：  #多行svn propset svn:ignore &amp;#34;cache\tmp\null\and_so_on&amp;#34; .#或者手动编辑svn propedit svn:ignore . 若已经创建了文件夹，并加入了版本控制，现在想忽略这个文件夹，但要保持文件夹的内容：  svn rm --keep-local path/directory_to_keep/*svn propset svn:ignore &amp;#39;path/directory_to_keep/*&amp;#39; . 未加入版本控制,要忽略子目录  svn add -N dircd dirsvn propset svn:ignore &amp;#34;igdir&amp;#34;svn add .svn st 检查设置的忽略属性在哪个地方  svn proplist#查看设置的忽略详情svn propget svn:ignore# 删除设置的忽略目录svn propdel svn:ignore svn-ignore-all :设置所有状态带?的资源ignore.  #!/bin/sh# svn-ignore-all# usage:# 1. run svn status to see what is going on at each step# 2. add or commit all files that you DO want to have in svn# 3. remove any random files that you don&amp;#39;t want to svn:ignore# 4. run this script to svn:ignore everything marked &amp;#39;?&amp;#39; in output of `svn status`svn status |grep &amp;#39;^?&amp;#39; |sed &amp;#39;s/^? *//&amp;#39; |while read f; dod=`dirname &amp;#34;$f&amp;#34;`b=`basename &amp;#34;$f&amp;#34;`ignore=`svn propget svn:ignore &amp;#34;$d&amp;#34;`if [ -n &amp;#34;$ignore&amp;#34; ]; thenignore=&amp;#34;$ignore&amp;#34;fiignore=&amp;#34;$ignore$b&amp;#34;svn propset svn:ignore &amp;#34;$ignore&amp;#34; &amp;#34;$d&amp;#34;done svn-ignore目录 .输入目录加入忽略  #!/bin/sh# svn-ignore# usage:# svn-ignore file/to/ignore ...for f; dod=`dirname &amp;#34;$f&amp;#34;`b=`basename &amp;#34;$f&amp;#34;`ignore=`svn propget svn:ignore &amp;#34;$d&amp;#34;`if [ -n &amp;#34;$ignore&amp;#34; ]; thenignore=&amp;#34;$ignore&amp;#34;fiignore=&amp;#34;$ignore$b&amp;#34;svn propset svn:ignore &amp;#34;$ignore&amp;#34; &amp;#34;$d&amp;#34;donesvn代码回滚改动已经被提交 这种情况下，用svn merge命令来进行回滚。
#假设最新版本号是28。svn update# 然后找出要回滚的确切版本号：svn log [something]#回滚到版本号25：svn merge -r 28:25 something#为了保险起见，再次确认回滚的结果：svn diff -r 28:25 [something]#提交回滚：svn commit -m &amp;#34;Revert revision from r28 to r25,because of ...&amp;#34;#提交后版本变成了29。svn 删除带!的文件 linux(支持带空格的文件)
svn st | grep ^! | awk &amp;#39;{$1=&amp;#34;&amp;#34;; print &amp;#34; --force \&amp;#34;&amp;#34;substr($0,2)&amp;#34;@\&amp;#34;&amp;#34; }&amp;#39; | xargs svn rmwin
### svndel.batsvn status | findstr /R &amp;#34;^!&amp;#34; &amp;gt; missing.listfor /F &amp;#34;tokens=* delims=! &amp;#34; %%A in (missing.list) do (svn delete &amp;#34;%%A&amp;#34;)del missing.list 2&amp;gt;NULsvn server 配置 目录结构 svnserve.conf [general]password-db = passwdauthz-db = authzpasswd
[users]wujiyu = wujiyuchenshu = chenshuhuangjunhai = huangjunhailiujiefeng = liujiefengauthz
[groups]client = wujiyu,chenshuserver = liujiefengdoc = huangjunhai[/]wujiyu = rw[/client]@client = rw[/server]@server = rw[/doc]@doc = rw@client = r@server = r[/&amp;lt;span style=&amp;#34;color: #0000ff&amp;#34;&amp;gt;public&amp;lt;/span&amp;gt;]*=rw这样就可以实现目录权限分配了.
其他工具  scm manager visual svn </content>
    </entry>
    
     <entry>
        <title>顺丰快递接口</title>
        <url>https://farwmarth.com/post/%E9%A1%BA%E4%B8%B0%E5%BF%AB%E9%80%92%E6%8E%A5%E5%8F%A3/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag><tag>顺丰快递</tag>
        </tags>
        <content type="html"> 事件起源是:买了某物品,快递公司是顺丰. 手机本是装了快递100来追踪快件的.结果输入单号居然查不到信息.只能抱怨快递100这软件坑爹了.于是度娘一下.找到了顺风的官网查单号
http://kf.sf-express.com/css/myquery/trackSmallTel.action
查询结果是有的,可能是给快递100的接口有问题吧.
又突然想起在手机上是否也可以查呢?还真有”顺丰速运通”.也可以查询到详单信息. 只是这UI和体验真蛋疼.
作为一个纯正码农.又无节操地反编了一下顺丰速运通的apk.扒出了手机端的通信接口..居然没有作验证.
http://syt.sf-express.com/css/newmobile/queryBillInfo.action?delivery_id=199120042475
delivery_id就是快件单号.
返回json格式:
{&amp;#34;message&amp;#34;: &amp;#34;成功&amp;#34;,&amp;#34;result&amp;#34;: {&amp;#34;delivery_id&amp;#34;: &amp;#34;199120042475&amp;#34;,&amp;#34;delivery_message&amp;#34;: &amp;#34;快件在广州集散中心,准备送往下一站&amp;#34;,&amp;#34;delivery_status&amp;#34;: &amp;#34;1&amp;#34;,&amp;#34;router&amp;#34;: [{&amp;#34;address&amp;#34;: &amp;#34;上海市&amp;#34;,&amp;#34;statue_message&amp;#34;: &amp;#34;快件在上海,准备送往下一站&amp;lt;font color=&amp;#39;red&amp;#39;&amp;gt;上海集散中心\t&amp;#34;,&amp;#34;time&amp;#34;: &amp;#34;2013-05-21 22:19:38&amp;#34;}, {&amp;#34;address&amp;#34;: &amp;#34;上海市&amp;#34;,&amp;#34;statue_message&amp;#34;: &amp;#34;快件在上海集散中心\t,准备送往下一站&amp;lt;font color=&amp;#39;red&amp;#39;&amp;gt;深圳集散中心\t&amp;#34;,&amp;#34;time&amp;#34;: &amp;#34;2013-05-22 10:24:00&amp;#34;}, {&amp;#34;address&amp;#34;: &amp;#34;深圳市&amp;#34;,&amp;#34;statue_message&amp;#34;: &amp;#34;快件在深圳集散中心\t,准备送往下一站&amp;lt;font color=&amp;#39;red&amp;#39;&amp;gt;广州集散中心&amp;#34;,&amp;#34;time&amp;#34;: &amp;#34;2013-05-22 15:15:45&amp;#34;}, {&amp;#34;address&amp;#34;: &amp;#34;广州市&amp;#34;,&amp;#34;statue_message&amp;#34;: &amp;#34;快件在广州集散中心,准备送往下一站&amp;#34;,&amp;#34;time&amp;#34;: &amp;#34;2013-05-22 17:15:33&amp;#34;}]},&amp;#34;success&amp;#34;: &amp;#34;0&amp;#34;}</content>
    </entry>
    
     <entry>
        <title>About TexturePacker</title>
        <url>https://farwmarth.com/post/about-texturepacker/</url>
        <categories>
          <category>starling</category>
        </categories>
        <tags>
          <tag>starling</tag>
        </tags>
        <content type="html"> TexturePacker是一个材质打包工具,最近学习starling的时候需要用到这个工具.先来个图 功能很齐全,支持众多语言. 平台支持也齐全,mac,windows,linux都可支持 使用也极其简单,将文件夹拖放到中间区域,在左边设置好导出的png,xml等.然后按菜单栏中的publish就ok了.licnese申请的条件是:有独立博客,然后5个月内至少发了5篇文章.还是很好申请的. 同类软件对比. 之前在微博关注的一个人也写了一个用于starling的.
功能简单,也够用了. 还有一个工具叫shoeBox.这个工具也不错,就不详细介绍了. 如果只是starling开发,后面两个工具足够了..如果要是平时开发的环境众多,texturepacker是不二的选择.
</content>
    </entry>
    
     <entry>
        <title>Android 开发调试</title>
        <url>https://farwmarth.com/post/android-%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag><tag>调试</tag>
        </tags>
        <content type="html"> update: 2016-1-14 更新模拟器夜神模拟器update: 2013-8-13 更新模拟器Genymotionupdate: 2013-5-19 更新wifi调试工具模拟器 android自带模拟器真是龟速,果断放弃
 夜神模拟器 bluestacks: 可以安装软件和调试的模拟器,速度比android的不知道快到哪去了. 安装完后,eclipse会把它识别为一台设备 .和真机调试没啥区别.运行界面  Genymotion 逍遥安卓模拟器 靠谱助手安卓模拟器 海马玩模拟器 mac下连接: adb connect 192.168.56.101  wifi 调试 今天没带数据线,搜了一下居然可以wifi调试. 1. 要求 手机必须root过，手机和电脑必须都联网且在同一局域网内。
2. 步骤
 手机端启动adbd服务 在手机端打开终端运行shell命令，终端可使用软件&amp;quot;终端模拟器&amp;rdquo; 或 &amp;ldquo;BetterTerminal&amp;rdquo; ，通过下面命令启动adbd服务  setprop service.adb.tcp.port 5555stop adbdstart adbd```上面su命令表示切换到root状态，setprop service.adb.tcp.port 5555表示设置adb tcp连接的端口为5555。stop adbd start adbd表示重启adbd服务这时到手机的**设置-&amp;gt;系统-&amp;gt;网络里查看手机ip地址多少**，如为192.168.1.193&#43; 在PC端打开cmd命令行**，输入`adb connect 192.168.1.193`表示adb连接到手机，连接成功会显示connected to 192.168.1.194:5555或already connected to 192.168.1.194:5555。如果adb命令不认识，添加android sdk的tools目录到系统path中。接下来eclipse编译选择相应的AVD即可。要关闭连接可以在pc端输入`adb disconnect 192.168.1.110`如果不想在手机中这么麻烦输入命令,可以下现成的工具 adb wireless## 一些工具&#43; tempMonitor: cpu温度监控</content>
    </entry>
    
     <entry>
        <title>最近迷恋上小霸王游戏:小蜜蜂</title>
        <url>https://farwmarth.com/post/%E6%9C%80%E8%BF%91%E8%BF%B7%E6%81%8B%E4%B8%8A%E5%B0%8F%E9%9C%B8%E7%8E%8B%E6%B8%B8%E6%88%8F%E5%B0%8F%E8%9C%9C%E8%9C%82/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>nes</tag>
        </tags>
        <content type="html"> 这个东东是不是勾起了你童年的回忆..是的,80,90都是这么过来的.黑白电视机加小霸王学习机就是那个年代的无敌装备.
在网上搜索了一下居然原版的没有swf单机版,用4399游戏盒只能下到nes版的.用模拟器才能运行起来.本来还想看下代码ai的部分.百科一下就无语了,红白机开发nes时用的是汇编,我等小白只能望洋兴叹.不甘心啊,还是想找flash版的.搜索半天居然搜索到几个as 的nes开源项目.
 as3nes  https://code.google.com/p/as3nes/ 项目不知道是韩语还是日语,反正就是看不懂的鸟语.down来下把 小蜜蜂的nes装置…一漆黑.不知道是不支持64位还是什么原因.as代码里有cpu,寄存器代码转换指令..看不懂..
 aminne  https://code.google.com/p/aminnes/ 国人的项目 天地会帖子地址:http://bbs.9ria.com/thread-34851-1-1.html .已开源.装载小蜜蜂.nes. 哈哈,终于出来了.
不过有点缺陷就是:有点掉帧, 还有就是没有声音,不过这个已经相当强大了.只能说作者牛屎.
 fc64  http://codeazur.com.br/stuff/fc64_final/
老外的这个写了更全面,在github上开源了:https://github.com/claus/fc64 .还支持android. 有意思 ..
</content>
    </entry>
    
     <entry>
        <title>数据结构整理</title>
        <url>https://farwmarth.com/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86/</url>
        <categories>
          <category>base</category>
        </categories>
        <tags>
          <tag>base</tag>
        </tags>
        <content type="html"> 数据结构形式定义:  逻辑结构 集合,线性,树形,图,网状
“数据结构”定义中的“关系”指数据间的逻辑关系，故也称数据结构为逻辑结构。 存储结构 数据结构在计算机中的表示称为物理结构。又称存储结构。
顺序存储结构
链式存储结构  数组 (Array) 数组设计之初是在形式上依赖內存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性：
 请求空间以后大小固定，不能再改变(数据溢出问题) 在內存中有空间连续性的表现，中间不会存在其他程序需要调用的数据，为此数组的专用內存空间； 数组通过索引来访问元素,不用遍历整个数组列表,所以访问速度很快.但是因为数组是存储结构是连续的,在头部删除,中间插入元素时,操作的后半部分项都需要进行移动导致速度慢.所以删除可以从数组的尾部开始.  AS的数组与java不同,非定长.测试代码
var arr:Array = [];for(var i:uint= 0 ;i&amp;lt;1000000;i&#43;&#43;)arr[i]=i ;var startT:Number = getTimer();var num:uint = 500;while(num&amp;gt;0){arr.shift();num--;}trace(&amp;#34;time:&amp;#34;,getTimer() - startT);上面消耗 822ms,改为pop.消耗1ms.var arr:Array = [];for(var i:uint= 0 ;i&amp;lt;1000000;i&#43;&#43;)arr[i]=i ;var startT:Number = getTimer();var num:uint = 500;while(num&amp;gt;0){arr.pop();num--;}trace(&amp;#34;time:&amp;#34;,getTimer() - startT);栈 (Stack) 是只能在某一端插入和删除的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。 as用数组实现的栈
public class Stack{private var _data:Array;public function Stack(){_data = new Array();}public function push(item:Object):void{_data.push(item);}public function pop():Object{return _data.pop();}}java实现
public class Stack {private Object[] obj;private int minSize = 2;private int cursor = 0;public Stack() {obj = new Object[minSize];}public void push(Object item) {if(cursor&amp;gt;=obj.length-1){obj =Arrays.copyOf(obj, obj.length&#43;minSize);}obj[cursor&#43;&#43;]=item;}public Object pop() {return obj[--cursor];}}队列 (Queue) 一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列是按照“先进先出”或“后进后出”的原则组织数据的。队列中没有元素时，称为空队列。
public class Queue{private var _data:Array;public function Queue(){_data = new Array();}public function push(item:Object):void{_data.push(item);}public function shift():Object{return _data.shift();}}优先队列 :有优先级别 ////////////////////////////////////////////////////////////////class PriorityQ{// array in sorted order, from max at 0 to min at size-1 private int maxSize;private long[] queArray;private int nItems;//------------------------------------------------------------- public PriorityQ(int s) // constructor {maxSize = s;queArray = new long[maxSize];nItems = 0;}//------------------------------------------------------------- public void insert(long item) // insert item {int j;if(nItems==0) // if no items, queArray[nItems&#43;&#43;] = item; // insert at 0 else // if items, {for(j=nItems-1; j&amp;gt;=0; j--) // start at end, {if( item &amp;gt; queArray[j] ) // if new item larger, queArray[j&#43;1] = queArray[j]; // shift upward else // if smaller, break; // done shifting } // end for queArray[j&#43;1] = item; // insert it nItems&#43;&#43;;} // end else (nItems &amp;gt; 0) } // end insert()//------------------------------------------------------------- public long remove() // remove minimum item { return queArray[--nItems]; }//------------------------------------------------------------- public long peekMin() // peek at minimum item { return queArray[nItems-1]; }//------------------------------------------------------------- public boolean isEmpty() // true if queue is empty { return (nItems==0); }//------------------------------------------------------------- public boolean isFull() // true if queue is full { return (nItems == maxSize); }//------------------------------------------------------------- } // end class PriorityQ链表 (Linked List) 是一种物理存储单元上非连续、非顺序的存储结构，它既可以表示线性结构，也可以用于表示非线性结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。
 单向链表: 从头部插入节点.   public class LinkList {private Node first;public LinkList() {first = null;}public void insertFirst(Object data) {Node newNode = new Node(data);newNode.next = first;first = newNode;}public Node deleteFirst() {Node temp = first;first = first.next;return temp;}public boolean isEmpty() {return first == null;}public void print() {Node cu = first;while (cu != null) {cu.display();cu = cu.next;}}public class Node {private Object data;private Node next;private Node(Object data) {this.data = data;}public void display() {System.out.println(data);}}} 双端链表:不要和双向链表混淆了,双端列表持有了末尾的节点可以方便地在末尾插入节点  package datastruce;public class FirstLastList {private Link first; // ref to first link	private Link last; // ref to last linkpublic FirstLastList() // constructor	{first = null; // no links on list yet	last = null;}public boolean isEmpty() // true if no links	{return first == null;}public void insertFirst(long dd) // insert at front of list	{Link newLink = new Link(dd); // make new linkif (isEmpty()) // if empty list,	last = newLink; // newLink &amp;lt;-- last	newLink.next = first; // newLink --&amp;gt; old first	first = newLink; // first --&amp;gt; newLink	}// -------------------------------------------------------------	public void insertLast(long dd) // insert at end of list	{Link newLink = new Link(dd); // make new link	if (isEmpty()) // if empty list,	first = newLink; // first --&amp;gt; newLink	elselast.next = newLink; // old last --&amp;gt; newLink	last = newLink; // newLink &amp;lt;-- last	}// -------------------------------------------------------------	public long deleteFirst() // delete first link	{ // (assumes non-empty list)	long temp = first.dData;if (first.next == null) // if only one item	last = null; // null &amp;lt;-- last	first = first.next; // first --&amp;gt; old next	return temp;}// -------------------------------------------------------------	public void displayList() {System.out.print(&amp;#34;List (first--&amp;gt;last): &amp;#34;);Link current = first; // start at beginning	while (current != null) // until end of list,	{current.displayLink(); // print data	current = current.next; // move to next link	}System.out.println(&amp;#34;&amp;#34;);}public class Link {public long dData; // data item	public Link next; // next link in listpublic Link(long d) // constructor	{dData = d;}public void displayLink() // display this link	{System.out.print(dData &#43; &amp;#34; &amp;#34;);}}} 双向链表:  双向链表的缺点是每一个插入删除操作,都要处理四个链节点的引用,因为持有前后结点的引用,内存占用也相应增加.
package datastruce;public class DoubleLinkedList {private Link first;private Link last;public boolean isEmpty() {return first == null;}public void insrtFirst(Object data) {Link newData = new Link(data);if (isEmpty()) {last = newData;} else {first.pre = newData;}newData.next = first;first = newData;}public void insertLast(Object data) {Link newData = new Link(data);if (isEmpty()) {first = newData;} else {last.next = newData;newData.pre = last;}last = newData;}public void displayPre() {Link cu=first;while (cu != null) {cu.displayLink();cu = cu.next;}}public void displayLast() {Link cu=last;while (cu != null) {cu.displayLink();cu = cu.pre;}}public class Link {public Object dData;public Link next;public Link pre;public Link(Object d) {dData = d;}public void displayLink() {System.out.print(dData &#43; &amp;#34; &amp;#34;);}}}树 (Tree) 是包含n（n&amp;gt;0）个结点的有穷集合K，且在K中定义了一个关系N，N满足 以下条件： （1）有且仅有一个结点 K0，他对于关系N来说没有前驱，称K0为树的根结点。简称为根（root）。　（2）除K0外，K中的每个结点，对于关系N来说有且仅有一个前驱。 （3）K中各结点，对关系N来说可以有m个后继（m&amp;gt;=0）。 二叉搜索树 :一个节点的左子节点的关键字值小于这个节点,右子节点的关键字值大于或等于这个节点.(可以快速地插入和删除数据项) package datastruce;import java.util.Stack;public class BinaryFindTree {public class Node {public int data;public Node leftChild;public Node rightChild;public Node(int data) {this.data = data;}}private Node root;public BinaryFindTree() {root = null;}public void insert(int data) {Node newNode = new Node(data);if (root == null)root = newNode;else {Node current = root; // start at root	Node parent;while (true) {parent = current;if (data &amp;lt; current.data) {current = current.leftChild;if (current == null) {parent.leftChild = newNode;return;}} else {current = current.rightChild;if (current == null) {parent.rightChild = newNode;return;}}}}}public void displayTree() {Stack globalStack = new Stack();globalStack.push(root);int nBlanks = 32;boolean isRowEmpty = false;System.out.println(&amp;#34;......................................................&amp;#34;);while (isRowEmpty == false) {Stack localStack = new Stack();isRowEmpty = true;for (int j = 0; j &amp;lt; nBlanks; j&#43;&#43;)System.out.print(&amp;#39; &amp;#39;);while (globalStack.isEmpty() == false) {Node temp = (Node) globalStack.pop();if (temp != null) {System.out.print(temp.data);localStack.push(temp.leftChild);localStack.push(temp.rightChild);if (temp.leftChild != null || temp.rightChild != null)isRowEmpty = false;} else {System.out.print(&amp;#34;--&amp;#34;);localStack.push(null);localStack.push(null);}for (int j = 0; j &amp;lt; nBlanks * 2 - 2; j&#43;&#43;)System.out.print(&amp;#39; &amp;#39;);} // end while globalStack not empty	System.out.println();nBlanks /= 2;while (localStack.isEmpty() == false)globalStack.push(localStack.pop());} // end while isRowEmpty is false	System.out.println(&amp;#34;......................................................&amp;#34;);}}四叉树:四叉树通常用于2d游戏碰撞检测.ghostcat版as实现: package ghostcat.algorithm{import flash.geom.Rectangle;/*** 图形筛选4叉树* @author flashyiyi**/public class QuadTree{/*** 第1象限*/public var q1:QuadTree;/*** 第2象限*/public var q2:QuadTree;/*** 第3象限*/public var q3:QuadTree;/*** 第4象限*/public var q4:QuadTree;/*** 父节点*/public var parent:QuadTree;/*** 起始节点*/public var root:QuadTree;/*** 图形范围*/public var rect:Rectangle;/*** 数据*/public var data:Array = [];public function QuadTree(rect:Rectangle){this.rect = rect;this.root = this;}/*** 创建树结构* @param deep**/public function createChildren(deep:int):void{if (deep == 0)return;const hw:Number = rect.width / 2;const hh:Number = rect.height / 2;q1 = new QuadTree(new Rectangle(rect.x &#43; hw, rect.y, hw, hh));q2 = new QuadTree(new Rectangle(rect.x &#43; hw, rect.y &#43; hh, hw, hh));q3 = new QuadTree(new Rectangle(rect.x, rect.y &#43; hh, hw, hh));q4 = new QuadTree(new Rectangle(rect.x, rect.y, hw, hh));q1.parent = q2.parent = q3.parent = q4.parent = this;q1.root = q2.root = q3.root = q4.root = this.root;q1.createChildren(deep - 1);q2.createChildren(deep - 1);q3.createChildren(deep - 1);q4.createChildren(deep - 1);}/*** 是否有子树* @return**/public function get hasChildren():Boolean{return q1 &amp;amp;&amp;amp; q2 &amp;amp;&amp;amp; q3 &amp;amp;&amp;amp; q4;}/*** 添加一个数据* @param v* @param x* @param y* @return**/public function add(v:*, x:Number, y:Number):QuadTree{if (!isIn(x,y))return null;if (hasChildren){return q1.add(v,x,y) || q2.add(v,x,y) || q3.add(v,x,y) || q4.add(v,x,y);}else{data.push(v);return this;}}/*** 删除一个数据，坐标为NaN则会进行遍历查找* @param v* @param x* @param y* @return**/public function remove(v:*, x:Number = NaN, y:Number = NaN):QuadTree{if (!isIn(x,y))return null;if (hasChildren){return q1.remove(v,x,y) || q2.remove(v,x,y) || q3.remove(v,x,y) || q4.remove(v,x,y);}else{var index:int = data.indexOf(v);if (index!=-1){data.splice(index, 1);return this;}else{return null;}}}/*** 检测是否还在当前区间内，并返回新的区间* @param v* @param x* @param y* @return**/public function reinsert(v:*, x:Number, y:Number):QuadTree{if (!isIn(x,y)){var result:QuadTree = root.add(v,x,y);if (result){remove(v);return result;}}return this;}/*** 判断坐标是否在界限内，设为NaN则不做限制* @param x* @param y* @return**/public function isIn(x:Number, y:Number):Boolean{return (isNaN(x) || x &amp;gt;= rect.x &amp;amp;&amp;amp; x &amp;lt; rect.right) &amp;amp;&amp;amp; (isNaN(y) || y &amp;gt;= rect.y &amp;amp;&amp;amp; y &amp;lt; rect.bottom);}/*** 获得一个范围内的所有数据** @param rect**/public function getDataInRect(rect:Rectangle):Array{if (!this.rect.intersects(rect))return [];var result:Array = data.concat();if (hasChildren){result.push.apply(null,q1.getDataInRect(rect));result.push.apply(null,q2.getDataInRect(rect));result.push.apply(null,q3.getDataInRect(rect));result.push.apply(null,q4.getDataInRect(rect));}return result;}}}图 (Graph) 图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。
堆 (Heap) 在计算机科学中，堆是一种特殊的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。
二叉堆 :特殊结构的二叉树,比优先队列效率更高
package ds{/*** Heap是一种特殊的二叉树，它的每个节点都比它的子节点大。内部实现是用数组存储的。* &amp;lt;p&amp;gt;* 比如原树状结构为：* 2* / \* 1 0* 则存储成数组为：* [2,1,0]* &amp;lt;/p&amp;gt;*/public class Heap{private var _heap:Arrayprivate var _compare:Function/*** @param compare 返回正数，则a排在b前边,如果不指定，默认为 function (a:int,b:int):int{return a-b};*/public function Heap(compare:Function = null):void{_heap = [];if(compare==null)_compare = function (a:int,b:int):int{return a-b};else_compare =compare;}public function get length():uint{return _heap.length}public function modify(obj:*,newObj:*):Boolean{var objIndex:int = this._heap.indexOf(obj);if(objIndex&amp;lt;0)return false_heap[objIndex]= newObjvar parentIndex:int = (objIndex-1)&amp;gt;&amp;gt;1var temp:* = _heap[objIndex]while(objIndex&amp;gt;0) //只有objIndex&amp;gt;0才有可能有parent	{//如果新插入的数据大于parent的数据，则应不断上移与parent交换位置	if(_compare(temp,this._heap[parentIndex])&amp;gt;0){this._heap[objIndex] = this._heap[parentIndex]objIndex = parentIndexparentIndex = (parentIndex-1)&amp;gt;&amp;gt;1 //parent索引的算法	}else{break;}}_heap[objIndex] = tempreturn true}//入队	//parentIndex = (childindex -1)/2	public function enqueue(obj:*):void{this._heap.push(obj)var parentIndex:int = (this._heap.length-2)&amp;gt;&amp;gt; 1var objIndex:int = this._heap.length -1var temp:* = this._heap[objIndex]while(objIndex&amp;gt;0) //只有objIndex&amp;gt;0才有可能有parent	{//如果新插入的数据大于parent的数据，则应不断上移与parent交换位置	if(_compare(temp,this._heap[parentIndex])&amp;gt;0){this._heap[objIndex] = this._heap[parentIndex]objIndex = parentIndexparentIndex = (parentIndex-1)&amp;gt;&amp;gt;1 //parent索引的算法	}else{break;}}_heap[objIndex] = temp}//出队	public function dequeue():*{if(_heap.length&amp;gt;1){var r:* = _heap[0]_heap[0] = _heap.pop()var parentIndex:int = 0var childIndex:int = 1var temp:* = _heap[parentIndex]while(childIndex &amp;lt;= _heap.length-1){if(_heap[childIndex&#43;1] &amp;amp;&amp;amp; this._compare(_heap[childIndex],_heap[childIndex&#43;1])&amp;lt;0){childIndex&#43;&#43;}if(this._compare(temp,this._heap[childIndex])&amp;lt;0){this._heap[parentIndex] = _heap[childIndex]parentIndex = childIndex;childIndex = (childIndex &amp;lt;&amp;lt;1)&#43;1}else{break}}_heap[parentIndex] = tempreturn r}return _heap.pop()}public function toString():String{return this._heap.toString()}public function get heap():Array{return _heap;}}}散列表 (Hash) 若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数(Hash function)，按这个思想建立的表为散列表。
http://www.nshen.net/dataStructure/2011/08/25/AS3-DataStructure.html
http://blog.csdn.net/zhanxinhang/article/details/6706217
</content>
    </entry>
    
     <entry>
        <title>斗地主结构分析</title>
        <url>https://farwmarth.com/post/%E6%96%97%E5%9C%B0%E4%B8%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag>
        </tags>
        <content type="html"> 这段时间在反编别人的代码,基本了解了android的游戏开发过程.在这里总结一下蛙蛙斗地主的体系结构.

activity管理:
注意在activity的回调中资源的创建及销毁.管理好activity的生命周期.
资源管理:
手机和pc不一样,在内存和运行性能上还有一定差距.所以资源的释放非常重要,在pc页游项目中,经常采用缓存图片资源的做法来提高程序的流畅性,手机项目最好在activity切换时如果内存达到一个上限时释放掉.可以把资源集中管理.
耗时操作
flash11.4之前不提供多线程api,用分帧来处理耗时操作,11.4后有了work线程. android里耗时操作可以另劈线程,防止阻塞UI.
蛙蛙结构:
图片资源管理器: 分为单张图片和多个资源合成的图片.在管理器内切割.部分动画也打包成一张图片. 程序初始化的时候将图片加载好变成Bitmap,加载完所有资源后通知activity初始化界面.在退出程序之前销毁所有图片资源.
游戏桌:分为了两层. 底层是GameScene,继承了SurfaceView,用于绘制牌和一些动画. 上层放android其他常规组件,如聊天,表情按钮什么的. 绘制对象上图已经描述清楚了. 蛙蛙的性能有待考究.绘制频率太快.屏幕元素太多时消耗太大.在mx上玩了一会就开始发热了 .draw的面积越大消耗越大.SurfaceView采用了双缓冲机制,图片是静态的不做动作的话,其实只要绘制二帧就可以了.可以将背景图这些少更改面积大的单独只绘制两帧.
位图文字: 为了美化可能要显示一些样式特别的字体.就可以用Canvas.drawText方法将文字绘制成位图,当然要传入文字样式的笔刷.
** 扑克规则**: 这个属于玩牌的规则了.牌型有:单张,对子,三张,三张一/二,炸弹等等. 基础功能点还包括:牌型大小比较,提示功能. 如果单纯的斗地主这里的代码量并不多.但是加上癞子斗地主,四人斗地主.复杂度也就增加不了.现在做的是把他的牌型分析抽离出来.判断规则和提示重写了.
通信: 这块要分几种情况.是wap连接的时候要设置代理用HttpUrlConnection来操作.wifi和net直接用Socket就可以了.Socket连接时最好是单独开辟读写流线程.
第三方接口:第三方接入其实是比较容易的.一般第三方都会提供demo.主要是要注册签约及与php调试要花一些时间 .蛙蛙的充值里包括了移动短信充值,支付宝. 看到的代码里还有google,lephone的一些东西 . 之前反编了博雅斗地主稍微看了一下.他们的充值接入更丰富.支付宝,移动短信,充值卡.等等. 登录接入包括了qq,sina,人人 一些平台.
核心代码并不很多,就通信,规则,游戏桌渲染.抛却那些附加的功能点界面也不多,就首页,登录,注册,大厅. 但是如果想做成一个好的完备的产品.还是需要发一些时间来优化.以下是博雅的基本功能点.
我这前一直纳闷的是为什么公司会选择这样一款产品.个人感觉斗地主这块市场是比较饱和.有联众,qq斗地主,博雅,蛙蛙.等等.后来boss给了一些数据.蛙蛙的月流水是500万的样子.我只能说.cao.
</content>
    </entry>
    
     <entry>
        <title>android 支付宝 快捷支付 接入</title>
        <url>https://farwmarth.com/post/android-%E6%94%AF%E4%BB%98%E5%AE%9D-%E5%BF%AB%E6%8D%B7%E6%94%AF%E4%BB%98-%E6%8E%A5%E5%85%A5/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag><tag>支付宝</tag>
        </tags>
        <content type="html"> update: 2013-4-28 私钥安全性修正一 sdk下载 https://b.alipay.com/order/techService.htm.最下面有快捷支付(无线)zip包,包含了教程,开发指南和demo.
二 状态图 基本流程: 客户端签名发送订单信息&amp;mdash;&amp;ndash;支付宝支付&amp;mdash;&amp;ndash;支付宝主动通知服务器验证数据及加上逻辑,如将充值成功的钱转换成虚拟货币(这个主动通知地址在客户端发送订单时的notice_url指定,可以不指定)&amp;mdash;服务器返回success状态&amp;mdash;支付宝返回结果给客户端.
在游戏中的图例
三 分析demo结构如下 AlixDemo为入口.onItemClick这里为支付调用的api
public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position,long id) {// // check to see if the MobileSecurePay is already installed. // 检测安全支付服务是否安装 MobileSecurePayHelper mspHelper = new MobileSecurePayHelper(this);boolean isMobile_spExist = mspHelper.detectMobile_sp();if (!isMobile_spExist)return;// check some info. // 检测配置信息 if (!checkInfo()) {BaseHelper.showDialog(AlixDemo.this,&amp;#34;提示&amp;#34;,&amp;#34;缺少partner或者seller，请在src/com/alipay/android/appDemo4/PartnerConfig.java中增加。&amp;#34;,R.drawable.infoicon);return;}// start pay for this order. // 根据订单信息开始进行支付 try {// prepare the order info. // 准备订单信息 String orderInfo = getOrderInfo(position);// 这里根据签名方式对订单信息进行签名 String signType = getSignType();String strsign = sign(signType, orderInfo);Log.v(&amp;#34;sign:&amp;#34;, strsign);// 对签名进行编码 strsign = URLEncoder.encode(strsign);// 组装好参数 String info = orderInfo &#43; &amp;#34;&amp;amp;sign=&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34; &#43; strsign &#43; &amp;#34;\&amp;#34;&amp;#34; &#43; &amp;#34;&amp;amp;&amp;#34;&#43; getSignType();Log.v(&amp;#34;orderInfo:&amp;#34;, info);// start the pay. // 调用pay方法进行支付 MobileSecurePayer msp = new MobileSecurePayer();boolean bRet = msp.pay(info, mHandler, AlixId.RQF_PAY, this);if (bRet) {// show the progress bar to indicate that we have started // paying. // 显示“正在支付”进度条 closeProgress();mProgress = BaseHelper.showProgress(this, null, &amp;#34;正在支付&amp;#34;, false,true);} else;} catch (Exception ex) {Toast.makeText(AlixDemo.this, R.string.remote_call_failed,Toast.LENGTH_SHORT).show();}}先判断安全支付服务是否安装,如果没有会提示安装.然后对订单数据进行签名
public String getOrderInfo(int position) {String strOrderInfo = &amp;#34;partner=&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34; &#43; PartnerConfig.PARTNER &#43; &amp;#34;\&amp;#34;&amp;#34;;strOrderInfo &#43;= &amp;#34;&amp;amp;&amp;#34;;strOrderInfo &#43;= &amp;#34;seller=&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34; &#43; PartnerConfig.SELLER &#43; &amp;#34;\&amp;#34;&amp;#34;;strOrderInfo &#43;= &amp;#34;&amp;amp;&amp;#34;;strOrderInfo &#43;= &amp;#34;out_trade_no=&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34; &#43; getOutTradeNo() &#43; &amp;#34;\&amp;#34;&amp;#34;;strOrderInfo &#43;= &amp;#34;&amp;amp;&amp;#34;;strOrderInfo &#43;= &amp;#34;subject=&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34; &#43; mproductlist.get(position).subject&#43; &amp;#34;\&amp;#34;&amp;#34;;strOrderInfo &#43;= &amp;#34;&amp;amp;&amp;#34;;strOrderInfo &#43;= &amp;#34;body=&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34; &#43; mproductlist.get(position).body &#43; &amp;#34;\&amp;#34;&amp;#34;;strOrderInfo &#43;= &amp;#34;&amp;amp;&amp;#34;;strOrderInfo &#43;= &amp;#34;total_fee=&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34;&#43; mproductlist.get(position).price.replace(&amp;#34;一口价:&amp;#34;, &amp;#34;&amp;#34;) &#43; &amp;#34;\&amp;#34;&amp;#34;;strOrderInfo &#43;= &amp;#34;&amp;amp;&amp;#34;;strOrderInfo &#43;= &amp;#34;notify_url=&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34;&#43; &amp;#34;http://notify.java.jpxx.org/index.jsp&amp;#34; &#43; &amp;#34;\&amp;#34;&amp;#34;;return strOrderInfo;}要签名的数据为partner(合作者身份ID),seller(商户收款支付宝账号),subject(商品名称),body(商品描述),total_fee(总价),notify_url支付宝主动通知的服务器url.
调用MobileSecurePayer 的pay方法进行支付 booleanbRet = msp.pay(info, mHandler, AlixId.RQF_PAY, this); info为发送的参数,mhandler为回调,AlixId.RQF_PAY为回调消息头.这里是判断返回状态.交易成功还是失败.集成还是比较容易的.关键还是要注册企业账户,准备资料审核.然后将合作id和key配置好.
 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;更新&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
之前拿的是博雅的账号,他的原始 商户rsa私钥暴露在客户端.这样是不安全的.所以改进了一下,客户端对订单数据签名过程放在服务器端.
更改的代码只有签名部分.
 4.0上访问网络另开线程.将结果用handler发送.
php返回
接收到返回处理签名
 三 服务器注意事项
 在服务器demo中找到AppBackDemo这个项目的RSANotifyReceiver类.这个就是接收支付宝通知的.
支付宝以post请求notify_url.数据样例
处理
验证方法
和客户端的验证是一样的.
</content>
    </entry>
    
     <entry>
        <title>android 反编译和代码解读</title>
        <url>https://farwmarth.com/post/android-%E5%8F%8D%E7%BC%96%E8%AF%91%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag>
        </tags>
        <content type="html"> update :2013-5-18反编译工具小米人改之理: http://www.xiaomiren.net/apkmodifier/
一 apk反编译 将apk文件解压后有两部分文件需要处理，一种是xml文件，另一种一个dex文件（.dex）
 对xml文件进行包的解析，一般有两种方式:apktool（推荐）和AXMLPrinter2.jar; 从dex到class公认dex2jar.bat，实现反编译；公认的强者； 而class到java的方式要更多样化一些,因为只是查看反编译后的代码：jd-gui（推荐），Jodeclipse（Jode的Eclipse插件），JadClipse（Jad的Eclipse插件）。 dex解包   首先把apk文件改名为.zip，然后解压缩其中的class.dex文件，它就是java文件编译再通过dx工具打包成的。 把class.dex拷贝到dex2jar.bat所在目录。运行dex2jar.bat class.dex，生成classes.dex.dex2jar.jar。 运行JD-GUI工具（绿色软件，好用的软件！），打开上面的jar文件，即可看到java源代码。 file-saveall将java源码保存为zip文件 资源文件解包 1 安装apktool,将apk反编译 将smali文件包删除. 2 将上一步保存的源码解压,在此建立一个src目录.将源码放入src下,导入到eclipse中.结构如下. 反编译完成.错误会很多..可以选择不同的工具来反编译,然后交叉对比.我一般使用jd-ui和jad-eclipse插件来编译. jad-eclipse配置 二 错误代码还原规则  if…else 语句: 反编译代码
if (paramBoolean)paramTextView.setTextColor(-16727809);while (true){return;paramTextView.setTextColor(-1315861);}还原后
if (paramBoolean){paramTextView.setTextColor(-16727809);}else{paramTextView.setTextColor(-1315861);} 会把if ..esle 反编译成 if …while(true)结构. 反编译代码
if (paramInt1 != 1)break label185;if (this.countChild_1 == null){this.countChild_1 = new PokerCountChild(this.mContext);this.countChild_1 = new PokerCountChild(this.mContext);this.countChild_1.setPosition((int)(0.83D * BaseGameActivity.screenWidth- this.countChild_1.getWidth()), (int)(0.2D * BaseGameActivity.screenHeight));this.countChild_1.setCount(paramInt2);addOneChild(this.countChild_1);if (paramInt2 == 0)this.countChild_1.setAlpha(0);}this.countChild_1.setCount(paramInt2);}label185: doreturn;while (paramInt1 != 2);if (this.countChild_2 == null){this.countChild_2 = new PokerCountChild(this.mContext);this.countChild_2 = new PokerCountChild(this.mContext);this.countChild_2.setPosition((int)(0.17D * BaseGameActivity.screenWidth),(int)(0.2D * BaseGameActivity.screenHeight));this.countChild_2.setCount(paramInt2);addOneChild(this.countChild_2);if (paramInt2 == 0)this.countChild_2.setAlpha(0);}this.countChild_2.setCount(paramInt2);还原
if(i == 1){if(countChild_1 == null){countChild_1 = new PokerCountChild(mContext);countChild_1 = new PokerCountChild(mContext);countChild_1.setPosition((int)(0.83D * (double)BaseGameActivity.screenWidth - (double)countChild_1.getWidth()), (int)(0.2D * (double)BaseGameActivity.screenHeight));countChild_1.setCount(j);addOneChild(countChild_1);if(j == 0)countChild_1.setAlpha(0);}countChild_1.setCount(j);} elseif(i == 2){if(countChild_2 == null){countChild_2 = new PokerCountChild(mContext);countChild_2 = new PokerCountChild(mContext);countChild_2.setPosition((int)(0.17D * (double)BaseGameActivity.screenWidth), (int)(0.2D *(double)BaseGameActivity.screenHeight));countChild_2.setCount(j);addOneChild(countChild_2);if(j == 0)countChild_2.setAlpha(0);}countChild_2.setCount(j);return;}会将语句倒序,出现break label结构 反编译代码 image jd-gui有时会将whilei语句翻译成if,此处要将if改成while
switch语句 反编译代码
switch (this.mBand){default:case 0:case 1:case 2:}while (true){return;this.mBand.setText(&amp;#34;FM1&amp;#34;);continue;this.mBand.setText(&amp;#34;FM2&amp;#34;);continue;this.mBand.setText(&amp;#34;AM&amp;#34;);}还原
switch (mBand){case 0:mBand.setText(&amp;#34;FM1&amp;#34;);break;case 1:mBand.setText(&amp;#34;FM2&amp;#34;);break;case 2:mBand.setText(&amp;#34;AM&amp;#34;);break;default:}switch规则就是一个continue对应一个case.要注意是是要外层的continue才算数,在if里的continue不算
enum枚举 还原 jd-gui http://www.qiaodiqiu.com/how-to-read-java-confusion-after-the-anti-compiled-code.html http://blog.csdn.net/xyz_fly/article/details/8014455 http://blog.csdn.net/hp_2008/article/details/8626010
jad http://blog.csdn.net/z3h/article/details/2515287 http://blog.csdn.net/z3h/article/details/2640522
</content>
    </entry>
    
     <entry>
        <title>android 组件Activity</title>
        <url>https://farwmarth.com/post/android-%E7%BB%84%E4%BB%B6activity/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag>
        </tags>
        <content type="html"> Android开发四大组件分别是：
 活动（Activity)： 用于表现功能。 服务（Service)： 后台运行服务，不提供界面呈现。 广播接收器（BroadcastReceiver)：用于接收广播。 数据实体（Content Provider）： 支持在多个应用中存储和读取数据，相当于数据库  一 Acvitivity Activity 是用户唯一可以看得到的东西。Activity主要负责的就是创建显示窗口，你可以在这些窗口里使用setContentView(View)来显示你自己的UI。activity展现在用户面前的经常是全屏窗口，你也可以将activity作为浮动窗口来使用（使用设置了windowIsFloating的主题），或者嵌入到其他的activity（使用ActivityGroup）中。 **Activity的四种状态:
 Active/Runing: 一个新 Activity 启动入栈后，它在屏幕最前端，处于栈的最顶端，此时它处于可见并可和用户交互的激活状态。 Paused: 当 Activity 被另一个透明或者 Dialog 样式的 Activity 覆盖时的状态。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见，但它已经失去了焦点故不可与用户交互。 Stoped: 当 Activity 被另外一个 Activity 覆盖、失去焦点并不可见时处于 Stoped 状态。 Destroyed: Activity 被系统杀死回收或者没有被启动时处于 Killed 状态。 201104291036314498 官方给的生命周期图，意思差不多:   方法何时被调用:
 **onCreate ：**当活动第一次启动的时候，触发该方法，可以在此时完成活动的初始化工作.onCreate 方法有一个参数，该参数可以为空（ null ），也可以是之前调用 onSaveInstanceState （）方法保存的状态信息。 onStart ： 在启动或从stoped状态重新启动时调用，所以初始化工作不应该放在这里，比如socket连接之类的。 onResume : 启动,paused到running状态，stoped到running状态. **onPause ：**当一个正在前台运行的活动因为其他的活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。 **onStop ：**当一个活动不再需要展示给用户的时候，触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发 onStop 方法。 所以保存状态信息是应该在onPause时做，而不是onStop时做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动。因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。 **onRestart ：**stoped到running状态，触发该方法。 **onDestroy ：**当活动销毁的时候，触发该方法。和 onStop 方法一样，如果内存紧张，系统会直接结束这个活动而不会触发该方法。 **onSaveInstanceState ：**系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。通常情况下，开发者不需要重写覆盖该方法，在默认的实现中，已经提供了自动保存活动所涉及到的用户界面组件的所有状态信息。  Activity栈:
Android 是通过一种 Activity 栈的方式来管理 Activity 的，一个 Activity 的实例的状态决定它在栈中的位置。处于前台的 Activity 总是在栈的顶端，当前台的 Activity 因为异常或其它原因被销毁时，处于栈第二层的 Activity 将被激活，上浮到栈顶。当新的 Activity 启动入栈时，原 Activity 会被压入到栈的第二层。一个 Activity 在栈中的位置变化反映了它在不同状态间的转换。Activity 的状态与它在栈中的位置关系如下图所示： 除了最顶层即处在 Active 状态的 Activity 外，其它的 Activity 都有可能在系统内存不足时被回收，一个 Activity 的实例越是处在栈的底层，它被系统回收的可能性越大。系统负责管理栈中 Activity 的实例，它根据 Activity 所处的状态来改变其在栈中的位置。
Activity 之间通信
 ** 使用Intent通信 **  // 发送Intent intent = new Intent(EX06.this, OtherActivity.class);intent.putExtra(&amp;#34;boolean_key&amp;#34;, true);intent.putExtra(&amp;#34;string_key&amp;#34;, &amp;#34;string_value&amp;#34;);startActivity(intent);// 接收Intent intent = getIntent();intent.getBooleanExtra(&amp;#34;boolean_key&amp;#34;, false);intent.getStringExtra(&amp;#34;string_key&amp;#34;);使用 SharedPreferences SharedPreferences 使用 xml 格式为 Android 应用提供一种永久的数据存贮方式。对于一个 Android 应用，它存贮在文件系统的 /data/ data/your_app_package_name/shared_prefs/目录下，可以被处在同一个应用中的所有 Activity 访问。Android 提供了相关的 API 来处理这些数据而不需要程序员直接操作这些文件或者考虑数据同步问题。  2: SharedPreferences preferences = getSharedPreferences(&amp;#34;name&amp;#34;, MODE_PRIVATE); 3: Editor editor = preferences.edit(); 4: editor.putBoolean(&amp;#34;boolean_key&amp;#34;, true); 5: editor.putString(&amp;#34;string_key&amp;#34;, &amp;#34;string_value&amp;#34;); 6: editor.commit(); 8: // 读取 SharedPreferences  9: SharedPreferences preferences = getSharedPreferences(&amp;#34;name&amp;#34;, MODE_PRIVATE); 10: preferences.getBoolean(&amp;#34;boolean_key&amp;#34;, false); 11: preferences.getString(&amp;#34;string_key&amp;#34;, &amp;#34;default_value&amp;#34;); 其它方式 Android 提供了包括 SharedPreferences 在内的很多种数据存贮方式，比如 SQLite，文件等，程序员可以通过这些 API 实现 Activity 之间的数据交换。如果必要，我们还可以使用 IPC 方式。  Activity启动模式：
 Application、task、Activity三者之间的关系:   Android为了使我们能够打破默认的堆栈的先后出的模式，提供了两个种方式：一种是在AndroidManifest.xml定义Activity时指定它的加载模式，另一种是在用Intent开启一个Activity时，在Intent中加入标志。如果两种方式都用了，则后者的优先级更高
 standard “拿来主义”standard模式。哪里需要调用我我就去哪里，可以多次实例化，可以几个相同的Activity重叠。(系统默认) singleTop “拒绝堆叠”singleTop模式。可以多次实例化，但是不可以多个相同的Activity重叠，当堆栈的顶部为相同的Activity时，会调用onNewIntent函数。 singleTask 独立门户”singleTask模式。同一个应用中调用该Activity时，如果该Activity没有被实例化，会在本应用程序的Task内实例化，如果已经实例化，会将Task中其上的Activity销毁后，调用onNewIntent；其它应用程序调用该Activity时，如果该Activity没有被实例化，会创建新的Task并实例化后入栈，如果已经实例化，会销毁其上的Activity，并调用onNewIntent。一句话，singleTask就是“独立门户”，在自己的Task里，并且启动时不允许其他Activity凌驾于自己之上。 singleInstance 孤独寂寞”singleInstance模式。加载该Activity时如果没有实例化，他会创建新的Task后，实例化入栈，如果已经存在，直接调用onNewIntent，该Activity的Task中不允许启动其它的Activity，任何从该Activity启动的其他Activity都将被放到其他task中，先检查是否有本应用的task，没有的话就创建。  在androidmainfest.xml中设置：android:launchMode=”standard”
&amp;lt;activityandroid:name=&amp;#34;com.example.studyandroidcode.MainActivity&amp;#34;android:label=&amp;#34;@string/app_name&amp;#34;android:launchMode=&amp;#34;standard&amp;#34; &amp;gt;&amp;lt;intent-filter&amp;gt;&amp;lt;action android:name=&amp;#34;android.intent.action.MAIN&amp;#34; /&amp;gt;&amp;lt;category android:name=&amp;#34;android.intent.category.LAUNCHER&amp;#34; /&amp;gt;&amp;lt;/intent-filter&amp;gt;&amp;lt;/activity&amp;gt;参考
http://www.cnblogs.com/ghj1976/archive/2011/04/29/2032495.html http://www.ibm.com/developerworks/cn/opensource/os-cn-android-actvt/ http://winuxxan.blog.51cto.com/2779763/504047 http://www.blogjava.net/marshal-hird/archive/2008/07/25/217389.html
</content>
    </entry>
    
     <entry>
        <title>android　框架结构</title>
        <url>https://farwmarth.com/post/android%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag>
        </tags>
        <content type="html"> 一 Android平台结构,SDK目录结构,目录结构 　android是一个linux内核的操作系统，常规编程语言是java,不过也推出了NDK,可以用c&#43;&#43;来访问部分接口。这篇就略去环境搭建和hello world了。
1. 平台整体架构
 Applications： 应用程序层(自带的短信一些功能) Application Framework： 应用程序框架层(主要关注点) Library &amp;amp;&amp;amp; Android Runtime： 底层功能库以及Android运行时 Linux Kernel： Linux 内核  2. SDK目录:
3. 项目目录详解
 src: 专门存放我们编写的java源代码的包。 gen: 该目录不用我们开发人员维护，但又非常重要的目录。该目录用来存放由Android开发工具所生成的目录。该目录下的所有文件都不是我们创建的，而是由ADT自动生成的。该目录下的R.java文件非常重要。 android 2.1: 存放Android自身的jar包。 assets：该目录用来存放应用中用到的类似于视频文件、Mp3一些媒体文件。 res：res是resource的缩写，我们称该目录为资源目录。该目录可以存放一些图标、界面文件、应用到的文字信息。  res下有三个dawable文件夹：drawable-hdpi：用来存放高分辨率的图标；drawable-mdpi:用来存放中等分辨路的图标；drawable-ldpi:用来存放低分辨率的图标。程序运行时可以根据手机分辨率的高低选取相应的目录下的图标。res下还有一个layout文件夹，里面是ADT默认自动创建的main.xml文件，在mian.xml中存放的是布局文件,下面是mian.xml中的部分代码：
res下的values中的strings.xml用来定义字符串和数值，在Activity中使用getResources().getString(resourceId)或getResources().getText(resourceId)取得资源。strings.xml中的部分代码:  AndroidManifest.xml:该文件是功能清单文件，该文件列出了应用中所使用的所有组件，如“activity”。 proguard.cfg：混淆脚本文件。 project.properties:该文件存放了项目的一些环境配置，根据需要可以手工改动。  可以将7改为3,4，7,8,10,11,12,13,14中的任意数值。 res下的文件在R.java中生成唯一id，layout和Activity也通过id关联 程序入口: AndroidManifest.xml中intent-filter为上图配置的Activity即为程序入口.
三　签名apk 1.签名的意义 为了保证每个应用程序开发商合法ID，防止部分开放商可能通过使用相同的Package Name来混淆替换已经安装的程序，我们需要对我们发布的APK文件进行唯一签名，保证我们每次发布的版本的一致性(如自动更新不会因为版本不一致而无法安装)。
2.签名的步骤
  创建key 创建key，需要用到keytool.exe (位于jdk1.6.0_24\jre\bin目录下)，使用产生的key对apk签名用到的是jarsigner.exe (位于jdk1.6.0_24\bin目录下)，把上两个软件所在的目录添加到环境变量path后，打开cmd输入 D:\&amp;gt;keytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore 说明：-genkey 产生密钥 -alias demo.keystore 别名 demo.keystore -keyalg RSA 使用RSA算法对签名加密 -validity 40000 有效期限4000天 -keystore demo.keystore
  使用key对apk签名 D:\&amp;gt;jarsigner -verbose -keystore demo.keystore -signedjar demo_signed.apk demo.apk demo.keystore 说明：-verbose 输出签名的详细信息 -keystore demo.keystore 密钥库位置 -signedjar demor_signed.apk demo.apk demo.keystore 正式签名，三个参数中依次为签名后产生的文件demo_signed，要签名的文件demo.apk和密钥库demo.keystore. 注意事项：android工程的bin目录下的demo.apk默认是已经使用debug用户签名的，所以不能使用上述步骤对此文件再次签名。正确步骤应该是:在工程点击右键-&amp;gt;Anroid Tools-Export Unsigned Application Package导出的apk采用上述步骤签名。
  3.签名之后,用zipalign(压缩对齐)优化你的APK文件
　未签名的apk不能使用,也不能优化.签名之后的apk使用zipalign.exe(android-sdk-windows\tools目录下)工具对其优化:D:\&amp;gt;zipalign -v 4 demo_signedfinal.apk
如上，zipalign能够使apk文件中未压缩的数据在4个字节边界上对齐（4个字节是一个性能很好的值），这样android系统就可以使用mmap()(请自行查阅这个函数的用途)函数读取文件，可以在读取资源上获得较高的性能.
 在4个字节边界上对齐的意思就是，一般来说，是指编译器吧4个字节作为一个单位来进行读取的结果，这样的话，CPU能够对变量进行高效,快速的访问（较之前不对齐）。 对齐的根源：android系统中的Davlik虚拟机使用自己专有的格式DEX，DEX的结构是紧凑的，为了让运行时的性能更好，可以进一步用&amp;quot;对齐&amp;quot;进一步优化，但是大小一般会有所增加。 </content>
    </entry>
    
     <entry>
        <title>centos 命令，基本设置</title>
        <url>https://farwmarth.com/post/centos-%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</url>
        <categories>
          <category>centos</category>
        </categories>
        <tags>
          <tag>centos</tag>
        </tags>
        <content type="html"> update 2016-7-21 13:53CentOS6.4配置163的yum源 CentOS系统自带的更新源的速度实在是慢，为了让CentOS6使用速度更快的YUM更新源，可以选择163（网易）的更新源。
 查看版本  cat /etc/redhat-release 查看cpu核数  # 总核数 = 物理CPU个数 X 每颗物理CPU的核数# 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数# 查看物理CPU个数cat /proc/cpuinfo| grep &amp;#34;physical id&amp;#34;| sort| uniq| wc -l# 查看每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep &amp;#34;cpu cores&amp;#34;| uniq# 查看逻辑CPU的个数cat /proc/cpuinfo| grep &amp;#34;processor&amp;#34;| wc -l 下载repo文件  wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 备份并替换系统的repo文件  [root@localhost ~]# cd /etc/yum.repos.d/[root@localhost ~]# mv CentOS-Base.repo CentOS-Base.repo.bak[root@localhost ~]# mv CentOS6-Base-163.repo CentOS-Base.repo 执行yum源更新  [root@localhost ~]# yum clean all[root@localhost ~]# yum makecache[root@localhost ~]# yum updateYUM** yum: Yellow dog Updater, Modified. 主要功能是更方便的添加/删除/更新RPM包.它能自动解决包的倚赖性问题.它能便于管理大量系统的更新问题.
1. yum的使用: 1)包的更新 1.1)检查可更新包: yum check-update 1.2)更新所有包: yum update 1.3)更新指定包: yum update package_name 1.4)版本升级: yum upgrade 2)包安装与删除 2.1)yum install package_name 2.2)yum remove package_name 3)包搜索 3.1)搜索特定包: yum search package_name 3.2)搜索包含特定文件名的包:yum provides name 4)包列表 4.1)列出所有安装或更新的包: yum list 4.2)列出指定包:yum list name 4.3)列出可更新包:yum list updates 4.4)列出已安装包:yum list installed 4.5)列出已安装但不包含在资源库中的包:yum list extras
2. 自动选择最快的源:
安装yum-fastestmirror插件，它会在下载时自动选择最快的源。  yum install yum-fastestmirror
3. 使用图形化的yum: yum install yumex 二 安装各种包 安装bin文件
1: //授予当前用户执行权限2: chmod a&#43;x jdk-6u26-linux-i586.bin3: //执行安装文件4: ./jdk-6u26-linux-i586.bin5: 卸载：把安装时中选择的安装目录删除就OK**安装rpm rpm -ivh /home/server/bind-9.8.1-6.2.x86_64.rpm
 查询软件包 rpm -q [选项] [软件包名称] 常用选项： -a ：查询所有安装的软件包。 -i ：显示软件包的概要信息。 -l ：显示软件包中的文件列表。 -c ：显示配置文件列表。 -d ：显示文档文件列表。 -s ：显示软件包中的文件列表和每个文件状态。 -f file ：查询属于哪个软件包。 -p file ：查询某个RPM包内含有的文件。  --import ：导入公钥。# rpm -qa 查询所有的软件包# rpm -qi make 查询make软件包的概要。# rpm -ql apache 查询apache软件包的文件列表。2、安装软件包 rpm -i [选项] [软件包名称] 常用选项： -h ：显示安装进度。 -v ：显示详细信息。 &amp;ndash;force ：忽略冲突强制安装。 &amp;ndash;nodeps ：不检查依赖关系。 # rpm -ivh /home/server/bind-9.8.1-6.2.x86_64.rpm 安装一个bind软件包，并显示安装进度。
3、升级软件包 rpm -U [选项] [软件包名称] 常用选项： -h ：显示安装进度。 -v ：显示详细信息。 &amp;ndash;force ：忽略冲突强制安装。 &amp;ndash;nodeps ：不检查依赖关系。 # rpm -Uvh /home/vim-7.3.338-1.src.rpm 升级vim软件包，并显示安装进度。
4、卸载软件包 rpm -e [选项] [软件包名称] 常用选项： &amp;ndash;nodeps ：不检查依赖关系。 # rpm -e vim-common 卸载vim-common软件包。PS：rpm包的弊端就是它的依赖性。rpm包的依赖性据说是这样的，当要安装软件包A时提示先要安装软件包B，当安装软件包B时又提示先要安装软件包C。当装完软件包C和B后装软件包A又提示C的版本不对。。。所以现在都直接用yum命令了 安装tar.gz(bz或bz2等)结尾的源代码包. 这种软件包里面都是源程序，没有编译过，需要编译后才能安装，安装方法为: 1、用CD 命令进入源代码压缩包所在的目录 2、根据压缩包类型解压缩文件(*代表压缩包名称)
tar -zxvf ****.tar.gztar -jxvf ****.tar.bz(或bz2)3、用CD命令进入解压缩后的目录 4、输入编译文件命令：./configure(有的压缩包已经编译过，这一步可以省去) 5、然后是命令：make 6、再是安装文件命令：make install 卸载：make uninstall
三　常规设置 1 安装中文输入法: yum install &amp;ldquo;@Chinese Support&amp;rdquo; 2 修改hosts : /etc/hosts 3 切换权限: su root 4 让Centos解压RAR:
1: //安装2: wget http://www.rarsoft.com/rar/rarlinux-3.9.3.tar.gz3: tar -xvf rarlinux-3.9.3.tar.gz4: cd rar5: make6: //用法7: rar x vpsyou.rar //解压 vpsyou.rar 到当前目录8: rar vpsyou.rar ./vpsyou.com/ //将 vpsyou.com 目录打包为 vpsyou.rar5 安装字体:
1: //创建目录YaHei2: mkdir -p /usr/share/fonts/YaHei3: cp YaHei.Consolas.1.12.ttf /usr/share/fonts/YaHei/YaHei.Consolas.ttf4: //安装字体5: cd /usr/share/fonts/YaHei/6: mkfontscale7: mkfontdir8: fc-cache -fv9: //最后，到系统－首选项－字体里修改字体６centos设置文件夹打开方式：在同一窗口打开文件夹 编辑 － 首选项 － 行为，勾选“总是在浏览器窗口打开”，点击关闭
四　开发环境  安装jdk :  1: //授予当前用户执行权限2: chmod a&#43;x jdk-6u26-linux-i586.bin3: //执行安装文件4: ./jdk-6u26-linux-i586.bin5:配置环境变量: gedit /etc/profile 打开后加入配置:
export JAVA_HOME=/usr/java/jdk1.6.0_24export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin#立即生效. /etc/profile解决/usr/bin/ld: cannot find -lmysqlclient错误 #mysqlclinet地址/usr/local/mysql/lib/libmysqlclient.so.18/usr/lib64/mysql/libmysqlclient.so.16#查找libmysqlclient的位置repoquery --whatprovides *libmysqlclient*#mysql-libs-0:5.1.71-1.el6.x86_64repoquery -l mysql-libs-0:5.1.71-1.el6.x86_64 | head -9#/etc/my.cnf#/usr/lib64/mysql#/usr/lib64/mysql/libmysqlclient.so.16#/usr/lib64/mysql/libmysqlclient.so.16.0.0centos7 最小化安装配置 基本 &#43;查看版本 cat /etc/redhat-release
 ifconfig yum provides ifconfig centos7 failed to start lsb 网卡地址被删除或者配置错误 http://blog.sina.com.cn/s/blog_4bbf963a0102vnk8.html ip addr 查看网卡地址(liner/ether)，填写到配置 HWADDR 编辑ip地址  #static assignmentONBOOT=yes #开机启动BOOTPROTO=static #静态IPIPADDR=192.168.1.151 #本机地址NETMASK=255.255.255.0 #子网掩码GATEWAY=192.168.1.1 #默认网关/etc/sysconfig/network-scripts 或者
yum install NetworkManager-tuinmtui edit enp0s3(网络配置文件名)systemctl enable NetworkManager-wait-online.servicesystemctl status NetworkManager.servicesystemctl restart network.service 重启网络http://blog.csdn.net/johnnycode/article/details/50184073 虚拟 机网卡记得改为桥接模式
mysql 安装 http://www.cnblogs.com/starof/p/4680083.html
dns设置 vi /etc/resolv.confdns查询 nslookup open.huanjia.cccentos 问题 centos下出现/lib64/libc.so.6: version `GLIBC_2.17&amp;rsquo; not found问题解决方案 #查看glibc版本strings /lib64/libc.so.6 |grep GLIBCwget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gztar xvf glibc-2.14.tar.gzcd glibc-2.14mkdir buildcd ./build../configure --prefix=/opt/glibc-2.14chmod &#43;r ../configuremake -j4sudo make installexport LD_LIBRARY_PATH=/opt/glibc-2.14/lib:$LD_LIBRARY_PATH#解除环境变量 unset LD_LIBRARY_PATHglibc操作
#查看glibc版本引用objdump -p skynet#查看指定版本引用的函数nm skynet |grep GLIBC_2.14#查看strings /lib64/libc.so.6 |grep GLIBC_#升级wget http://ftp.gnu.org/gnu/glibc/glibc-2.14.tar.gztar xvf glibc-2.14.tar.gzcd glibc-2.14mkdir buildcd ./build../configure --prefix=/opt/glibc-2.14make -j4make install#备份rm -rf /lib64/libc.so.6ln -s /opt/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6#删除libc.so.6之后可能导致系统命令不可用的情况, 可使用如下方法解决:LD_PRELOAD=/opt/glibc-2.14/lib/libc-2.14.so ln -s /opt/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6#如果上述更新失败可使用如下命令还原:LD_PRELOAD=/lib64/libc-2.12.so ln -s /lib64/libc-2.12.so /lib64/libc.so.6 #libc-2.12.so 此项是系统升级前的版本升级 升级git #编译环境yum install crul curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel gcc perl-ExtUtils-MakeMaker#下载wget https://www.kernel.org/pub/software/scm/git/git-1.9.4.tar.gztar xzf git-1.9.4.tar.gz#编译cd git-1.9.4autoconf./configuremakemake install#指定git版本echo &amp;#34;export PATH=$PATH:/usr/local/bin/git&amp;#34; &amp;gt;&amp;gt; /etc/bashrcsource /etc/bashrc#检查git --version升级node,npm yum install nodeyum install npmnpm install -g nn stableecho &amp;#34;export PATH=$PATH://usr/local/bin/node&amp;#34; &amp;gt;&amp;gt; /etc/bashrcsource /etc/bashrc#延缓npmnpm install npm@latest -g安装nmon cd /tmpwget http://sourceforge.net/projects/nmon/files/nmon16e_mpginc.tar.gz# Untar archivetar -xzvf nmon16e_mpginc.tar.gz# Copy nmon filecp nmon_x86_64_centos7 /usr/local/bin/chmod a&#43;x /usr/local/bin/nmon_x86_64_centos7# Create symbolic linkln -s /usr/local/bin/nmon_x86_64_centos7 /usr/local/bin/nmon# tidy up tmprm -f nmon_*curl,wget下载github,releases curl -sL https://github.com/fatedier/frp/releases/download/v0.9.3/frp_0.9.3_linux_amd64.tar.gz | tar xzwget --no-check-certificate https://github.com/fatedier/frp/releases/download/v0.9.3/frp_0.9.3_linux_amd64.tar.gz -O - | tar xz</content>
    </entry>
    
     <entry>
        <title>windows下蛋疼的cocos2d-x，android配置。</title>
        <url>https://farwmarth.com/post/windows%E4%B8%8B%E8%9B%8B%E7%96%BC%E7%9A%84cocos2d-xandroid%E9%85%8D%E7%BD%AE/</url>
        <categories>
          <category>c&#43;&#43;</category><category>cocos2d-x</category>
        </categories>
        <tags>
          <tag>c&#43;&#43;</tag>
        </tags>
        <content type="html"> 安装android开发环境 接着上一篇: http://farwmarth.com/?p=584
在装了eclipse和cdt的环境下:
 安装adt(http://dl.google.com/android/ADT-21.0.0.zip)和android sdk 配置android sdk  配置环境变量:

将这两项加入到path中, adb –h 测试环境变量是否配置成功。(ps 发现一个配置环境变量的图形化好工具envman) 下载ndk (http://developer.android.com.nyud.net/tools/sdk/ndk) 用于编译c&#43;&#43;代码。解压。 
配置ndk环境变量:
  Cygwin安装(这个很蛋疼): 由于NDK开发大都涉及到C/C&#43;&#43;在GCC环境下编译、运行，所以在Windows环境下，需要模拟Linux模拟编译环境，下载地址： http://www.cygwin.com/
下载后是个setup.exe文件，使用过程如下：
第一步：运行setup程序，第一步图略，直接点击Next进入下一步。
第二步：选择安装方式，第一次可以采用Direct Connection在线下载安装，如有现成的离线包，可以选择离线安装（Install from Local Directory）。
第三步：选择安装目录，比如C:\Cygwin，注意此目录是指Cygwin最终的安装目录，不是下载文件暂存目录。

我们编译NDK，在默认设置下，只需选择Devel（点击列表中Devel，将后面的Default改为Install，图中箭头所示），其它均为默认状态。(其实NDK需要的不多，主要autoconf2.1、automake1.10、binutils、gcc-core、gcc- , g&#43;&#43;、gcc4-core、gcc4-g&#43;&#43;、gdb、pcre、pcre-devel、gawk、make )

一定要注意红线部分，之前使用默认设置安装，最后编译android项目时报什么没make.
还有一个是报错make与cygwin不兼容，是因为我之前装了migwin .把migwin卸载掉。然后用图上配置重新装了cygwin,

一般选163的镜像快一些。下载完成装好后打开cygwin输入cygcheck -c cygwin命令，会打印出当前cygwin的版本和运行状态，如果status是ok的话，则cygwin运行正常。然后依次输入gcc –v，g&#43;&#43; &amp;ndash;version，make –version，gdb –version进行测试，(注意空格和-)如果都打印出版本信息和一些描述信息，这说明cygwin安装成功了。
配置cygwin: 在命令行中进入cygwin目录，并执行cygwin.bat，会在cygwin/home/文件夹中生成一个以你的登录名命名的新的文件夹。会有一个“.bash_profile”文件，我运行的时候没有生成这个文件夹，可以从cygwin/etc/skel/下复制.bash_profile文件到cygwin/home/Administrator(用户名)下面。然后在.bask_profile中配置如下: 
配置cygwin环境变量: 
配置到path中，这个是让eclipse来找到cygwin及其库路径的。之前未配置这个，eclipse编译的时候出现:gcc not found in path错误。
编译cocos2d-x 工程:

解压到这了，编辑create-android-proejct.bat 
_CYGBIN :cygwin的bin目录 _ANDROIDTOOLS: android sdk工具 _NDKROOT :　ndk路径。 配置好后执行此bat.输入包名,工程名,targetid.


在目录下生成了android工程文件:
android工程还不能用，还要用cygwin编译。 打开cygwin，进入到testandroid/proj.android目录，输入 ./build_native.sh  
我在win7下倒是没有碰到什么权限不足的情况。编译成功之后把这个导入到eclipse里面联真机调试吧
 
编译的时候出现找不到coco2d的库，我直接将这个路径的源文件拷贝到工程了 
连手机调试的时候要把手机的开发者模式打开。而且要装adb interface驱动。

在设置管理器看手机驱动是否装好，如果没有则找到android sdk里面的驱动

运行配置:

没有在模拟器里跑是因为模拟器不支持openGL.终于搞定了cocos2d-x android demo了。

还没结束。。准备跑之前建的c&#43;&#43;工程，报错了。找不到gcc,g&#43;&#43;库.找了好久才发现

这里指向的是migwin的库，因为把migwin卸载了所以这个工程库路径找不到了，重新建了一个工程。继续hello,world

运行没了问题。这个时候调试又出问题了。

搜索了一下解决方案:配置路径映射，因为cygwin的路径表示为linux的路径。

再调试就ok了。配置告一段落。折腾了一天。
参考: http://www.cnblogs.com/lhming/archive/2012/06/27/2566460.html http://www.cnblogs.com/lhming/archive/2012/06/27/2566467.html
</content>
    </entry>
    
     <entry>
        <title>在菲音听的几堂培训课</title>
        <url>https://farwmarth.com/post/%E5%9C%A8%E8%8F%B2%E9%9F%B3%E5%90%AC%E7%9A%84%E5%87%A0%E5%A0%82%E5%9F%B9%E8%AE%AD%E8%AF%BE/</url>
        <categories>
          <category>mind</category>
        </categories>
        <tags>
          <tag>mind</tag>
        </tags>
        <content type="html"> 　在菲音也呆了半年多了，新人培训一次也没去，讲的是什么时间管理，高效XX的东西，技术培训倒是去了不少，每周四的晚上会有项目负责人或者主程宣讲。工作心得，一些问题解答，个人觉得某些课听了还是收获裨益的。当时的ppt没能要过来，时隔几个月才想起来写一篇稿子总结一下。 刚进公司那会听第一堂技术课，有种膜拜大牛的感觉。主讲是一个新项目的主程，讲的是as的基本知识体系和ARPG游戏引擎设计思路.当时还做了大量笔记，现在笔记本都不知道丢哪去了，记得的唯一的一点是。以组件方式编程，将功能点设计成组件，而不是用深层次的继承，这和最近看的robotlegs有异曲同工之妙。每个功能点都分离成组件，这样就代码就可以灵活装配了，(哈，想法是好的，但是将抽象付于实践才是最难的一部分，努力向着这一步迈进) 再有印象点的就是天地会的舵主弃笑天的效率之道讲座。介绍了不少提高效率的途径和方法.
 把重复而繁琐的步骤用工具或者脚本化，可以用ant,bat,air,或者自己写些插件工具。核心思想就是以”偷懒”为首要任务。 持续集成 ，大体就是将项目发布流程的自动化和即时化，用持续集成服务器(Jenkins)每日构建出测试版本，这样就能即早地发现问题，对于这点深有体会啊，每周四更新的时候都会各种问题，如果能尽早出功能性的测试版本就不用熬那么晚了。 规划和回顾: 每天晚上或者是是上公交上规划一下一天大概要干什么,可以借助GTD软件，像anydo,或者doit.im,　anydo相对而言更简洁一些，如果是有长期的计划的话，doit.im更加全面，还有回顾功能。 思路整理: 在开始着手一个新的功能时可以用思维导图来整理一下次要点和流程。复习回顾的时候也可以用思维导图,建一张空白的图，然后不断扩充知识点，这样就大概知道了有什么薄弱的地方。 独立思考时间: 这个在夜间比较合适，干扰较少，思绪比较清晰。写周期总结或者博客。 后来腾讯的一个技术总监来讲座，更系统地划分了一下层级。  　程序基础知识和开发效率应该齐头并进。空有一腔理论而无法快速高效地产出，或者只是能快速完成任务而基础知识不牢固都是发育不良的，可以把程序基础看作是树根，而开发效率是上面的树干，根深则叶茂。 不知道是因为长期埋头编码还是个人性情所致，大多数程序员都不善于发言，每次座谈都是主讲一个人在上面滔滔不绝，提问的时候下面一片冷寂。在工作室的每日晨会演讲也是如此，除了老大，没有几个能思路清晰，不慌不忙地表达自己的想法。并不是没有想法，而是没有适应这种场合。每个人不是与生惧来就有这种理智和气场。而是在于勤于锻炼自己。 总结一下在菲音的这些日子，还是收获颇非的。特别是最近和部门老大的一次谈话又触动了自己的脑神经。不要把自己当作苦逼的程序员看。境界高一点，视野开阔一点，敢于去追求和拼搏。不要只看着眼前的小利益。虽然知道有点忽悠人，是不想加工资的借口。但有些话还是不无道理。除了自身知识结构这一生态系统的完善，还有一套生态系统值得完善，那就是自身经验积累和视野的开阔。多交朋友。多与有益的群体交流,多点兴趣爱好,养成良性的习惯。
Do the best。
</content>
    </entry>
    
     <entry>
        <title>折腾一下，游戏每周首页</title>
        <url>https://farwmarth.com/post/%E6%8A%98%E8%85%BE%E4%B8%80%E4%B8%8B%E6%B8%B8%E6%88%8F%E6%AF%8F%E5%91%A8%E9%A6%96%E9%A1%B5/</url>
        <categories>
          <category>bat</category>
        </categories>
        <tags>
          <tag>闲得蛋疼</tag>
        </tags>
        <content type="html"> 　昨天晚上版本更新，又到了难熬的等待时刻了，看完了更新的绿箭侠，邪恶力量，实在是不想干活了，突然想起来最近每周都把游戏更新的首页截图做个纪念，索性把以前的首页也翻出来吧。
找了找工程目录，素材是一个叫homePage.tempdata的文件，被加密了的，ok，开始工作.
基本思路是把 homePage.tempdata 的每个历史版本都保留副本,然后解密成swf,再用jsfl将swf导成png.
第一步: 拿到每个历史版本,首先得拿到版本号 这是svn上的版本历史,把版本历史复制用一个文本保存起来如revison.txt,结果如下版本号在Revison:后面，写段bat,其实一句话就够了:
结果
整理后就可以得到homePage.tempdata的所有历史版本号了，命名为a.txt
再写一段bat，用svn命令来还原到某一版本，再保存复本，以版本号命名
第一步就完成了，得到了homePage.tempdata的所有历史版本.
第二步　解密成swf 这一步可以略过，用air搞成绿色的接受命令行的程序批理解密，得到如下swf.
第三步　用jsfl来给swf截图 jsfl脚本如下:
var doc=fl.getDocumentDOM();var path=&amp;#34;file:///C|/home/homepage/&amp;#34;;var files = FLfile.listFolder(path&#43;&amp;#34;*.swf&amp;#34;,&amp;#34;files&amp;#34;);for(var i=0;i&amp;lt;files.length;i&#43;&#43;){doc.importSWF(path&#43;files[i]);var filename = files[i];var exportName = filename.substring(0,filename.lastIndexOf(&amp;#34;.&amp;#34;))&#43;&amp;#34;.png&amp;#34;;doc.exportPNG(path&#43;exportName,true,true);doc.selectAll();doc.deleteSelection();}这段脚本就是将路径下所有swf文件依次导入到舞台，然后导出舞台内容为png ,注意的是这里的exportPNG第二个参数是否使用默认的导出设置，我的设置: “包含” 这一项选中的是”完整文档大小”，而不是”最小影像区域”. ok，成果如下:
</content>
    </entry>
    
     <entry>
        <title>ipad2初级指南</title>
        <url>https://farwmarth.com/post/ipad2%E5%88%9D%E7%BA%A7%E6%8C%87%E5%8D%97/</url>
        <categories>
          <category>教你瞎折腾</category>
        </categories>
        <tags>
          <tag>ipad</tag>
        </tags>
        <content type="html"> 本来是打算买个nexus 7 玩玩的，港版好像没货，叫朋友同事从香港带了个ipad2.
一 越狱  升级到ios 6.1.2 : 开机设置apple id后, 设置&amp;mdash;通用&amp;ndash;软件更新 中更新到ios 6.1.2.大概七八分钟的样子。自动重启升级后同步itunes 设置。 越狱 : 下载 evasi0n 1.5.1 http://www.evasi0n.com/ ,连接usb ,打开 evasion 点击jailbreak.中途会重启ipad,在ipad桌面上创建jailbreak的图标 ，在第二步它会提示你按ipad上的jailbreak图标 ，基本就完成了。在越狱过程中不要触摸ipad的屏幕。我的在这上面悲剧。重启电脑和ipad后才越狱成功。成功后会在桌面多一个商店 cydia .教程:http://www.evasi0n-cn.com/6x_jiaocheng.  二 基本操作  关机:iPad是不用关机的，待机就够。如果硬是要关机就按住锁屏键，也就是顶部右方的黑键， 一直到屏幕出现滑动关键的提示时滑动关机即可。 重启:同时长按home和power键,直到屏幕黑后,松开两键,按power开机即可. 安装程序:用同步助手搞定，也可以在appstore中直接下载. 关闭程序:按home键程序会存留在后台，要彻底关闭双击home键，长按要关闭的图标. 待机: 按一下关机键就是待机模式 移动和分组: 和android类似，按住图标过一会图标会晃动就可以操作，取消这种状态按home键  三 进阶 给cydia 添加中文源: cydia 软件源&amp;mdash;编辑&amp;ndash;添加源. 两个中文源: http://apt.weiphone.com http://apt.178.com
用cydia安装ifanbox.下载软件快一些。如果要安装破解软件需要安装appsync补丁，注意对应的固件版本。
cydia一些系统增强软件 :
 switcher cleaner : 任务管理器弹出就可以关闭程序，不用长按图标，长按关闭所有打开的程序. sbsetings : 快捷开关,蓝牙，wifi等 activator :手势增强 icleaner : 清理缓存，包括safari,日志等。 ifile :文件管理器,可以访问系统文件,移动复制.搜索.搜索功能很强大.支持所有层次目录搜索. 百度文库: 这个可以用来看txt,android上的开卷有益,熊猫看书,宜搜都没有ipad版.用android的宜搜下载好txt,用快牙输送到iapd.再用ifile将txt移动到百度文库的目录就可以看了. rmvb播放: 下个破解版的oPlayer,支持的格式很多.支持wifi传输视频.音乐播放等.界面也比较舒适. flex2 : ios上的神器,可以篡改应用的任意函数,应用在视频应用去广告,游戏数值修改等.  四 吐槽 也许是还没用习惯，ibook看书好生蛋疼，不支持txt还要转换，换了个goodreader.
appstores 连接很慢，而且下载没有取消选项。。换ifanbox.
不过也有其优势.相对于android, ios更像是一个封闭的黑匣子，简洁操作易上手，软件质量整体上比android好些，体验感和流畅性也更胜一筹。
五 一些零碎的东东  修改hosts 有时候想上一下google plus,path ,改下ipad的hosts 用ifile打开文件 root&amp;mdash;etc&amp;mdash;-hosts. 修改dns appstore加载速度太慢，修改dns提高响应 设置-wifi&amp;ndash;选择连接的wifi&amp;ndash;dns. 我改成了 8.8.8.8,114.114.114.114 </content>
    </entry>
    
     <entry>
        <title>Another New Year 2013</title>
        <url>https://farwmarth.com/post/another-new-year-2013/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>life</tag><tag>新目标</tag>
        </tags>
        <content type="html">  过年在家里的一个星期相对清静，不用整天对着屏幕，不用一坐就一整天，晚上10点就上床睡觉，睡觉前看看以前下的电影。本来还想着放假做点什么小游戏的，又夭折在日程表上，杀鸡宰鱼的事情占满了前几天。还是农村里过年气氛浓郁，团圆饭，一家人看看春晚烤烤火，打打牌，还有一个个人觉得很有意思的保留节目:除夕夜到认识或者不不认识的人家庭高声辞岁，一声呐喊算时辞旧迎新，给人们带来美好的祝愿。我记得小时候老是盼着过年，过年意味着 有新衣服穿，可以拿压岁钱，可以吃好吃的，更好玩的是可以在除夕夜里辞岁，要到很多糖果和零食，还有就是在除夕夜里可以”守岁”,可以通宵达旦地玩。
 两年没回家过年，家乡也发生了挺大的变化，买车买房的多了，生活水平似乎提高了一个档次。很大部分同学嫁的嫁了，结的结婚了，我哥的孩子都可以在地上爬来爬去。一回家邻里就开始问:女朋友带回家没，果然回家避免不了的三大问题:工资，房子，结婚。老妈也在筹备着:今年带女朋友回家，明年把你妹嫁了，你也把婚给结了。突觉惶恐，正如找第一份工作一样，觉得没有准备好，后来回过头去想，如果不积极地不断面试而是呆在宿舍里复习,那永远也没准备好，敢于去改变，船到桥头自然直.
 出来工作快两年了，这些年感觉爸妈老了很多 ，不再是读书时代那个样子每日叮嘱着好好学习,天天向上。决策权也归还到我手里。买什么样的房子，买什么样的床，甚至是什么颜色的地板, 我爸都会打个电话给我，并不是不知道买什么样的，只是想听听我的意见，我俨然成了家里的主力军。什么样的未来在我手里。
 小锅昨天对我发出了不满,说我变得懒散,没有了追求。着实生了气，怎么能说我没有追求。事后想想也是。在她心里我一直是很厉害，很棒的。现在却整天看看视频，拿着微薄的工资不思进取。我严重忏悔，因为这篇博文拖了快一个月了，每次晚上打开live writer都不知道写些什么，骚年该崛起了。
新年写下新的目标(新年过了好久了)
 多交朋友 换个工作 晚上早点睡觉，最近没玩游戏了追剧有点厉害。 买个入门的单反,积累一些旅游基金 每周学做菜. 学习一两门新的语言 </content>
    </entry>
    
     <entry>
        <title>Crocus Modeller 试用无限期</title>
        <url>https://farwmarth.com/post/crocus-modeller-%E8%AF%95%E7%94%A8%E6%97%A0%E9%99%90%E6%9C%9F/</url>
        <categories>
          <category>破解</category>
        </categories>
        <tags>
          <tag>破解</tag>
        </tags>
        <content type="html"> 想找一个本地的画as的uml图软件，从美观程序和功能性选择了crocus modeller,它提供了试用版和付费版，付费版49美元，用不起，而是试用版只能试用五天.尝试着去破解。
用的是rsa算法 ,类库为 as3crypto，算法如下:
将输入的key 用公钥解密，与输入的licenseName对比是否相同.相同则注册成功，还原算法后死活验证不成功。。未果突然发现了一段代码:
验证是否超过试用期竟然是判断安装目录下crocus.swf的创建日期与当前日期对比 。这个创建日期是可以用软件去修改的.就找了个软件改了下这个swf的创建日期:
![image]https://farwmarth.bestnewbee.com/images/uploads/2013/02/image2.png)
重新打开后果然可以了好吧，就凑合着用吧先
</content>
    </entry>
    
     <entry>
        <title>进制及位运算</title>
        <url>https://farwmarth.com/post/%E8%BF%9B%E5%88%B6%E5%8F%8A%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>基础</tag>
        </tags>
        <content type="html"> 单位  1TB=1024 GB = 1024 M = 1024 KB = 1024 BYTE(字节) = 8 BIT(二进制位) ASCII码：一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。如一个ASCII码就是一个字节。 UTF-8编码:一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 Unicode编码:一个英文等于两个字节，一个中文（含繁体）等于两个字节。 符号:英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。  一 进制转换  在2进制中只有2个数字,即1,0 在8进制中只有8个数字,即0,1,2,3,4,5,6,7 在10进制中有10个数字,即0,1,2,3,4,5,6,7,8,9 在16进制中有10个数字和6个字母,即0,1,2,3,4,5,6,7,8,9和A,B,C,D,E,F, 字母A代表数字10,字母B代表数字11,字母C代表数字12,字母D代表数字13,字母E代表数字14,字母F代表数字15  1 正数 1 十进制转二进制 对于整数部分,用被除数反复除以2,除第一次外,每次除以2均取前一次商的整数部分作被除数并依次记下每次的余数.另外,所得到的商的最后一位余数是所求二进制数的最高位.
对于小数部分,采用连续乘以基数2,并依次取出的整数部分,直至结果的小数部分为0为止.故该法称&amp;quot;乘基取整法&amp;rdquo;
2 十进制转十六进制 10进制数转换成16进制的方法,和转换为2进制的方法类似,唯一变化:除数由2变成16.
120,转换成16进制则为:
   被除数 计算过程 商 余数     120 120/16 7 8   7 7/16 0 7    120转换为16进制,结果为:78.
3 二进制转十进制 二进制数第0位的权值是2的0次方,第1位的权值是2的1次方,把0110 0100二进制转换为10进制为:
0 * 2 ^ 0 &#43; 0 * 2 ^ 1 &#43; 1 * 2 ^ 2 &#43; 0 * 2 ^ 3 &#43; 0 * 2 ^ 4 &#43; 1 * 2 ^ 5 &#43; 1 * 2 ^ 6 &#43; 0 * 2 ^ 7 = 100
4 二进制转十六进制 将二进制分为4位一组
0000 = 0 = 01010 = 10 = A1011 = 11 = B1100 = 12 = C1101 = 13 = D1110 = 14 = E1111 = 15 = F由于1111才4位,所以我们必须直接记住它每一位的权值,并且是从高位往低位记:8、4、2、1.即,最高位的权值为2^3 = 8,然后依次是 2^2 = 4,2^1=2, 2^0 = 1.
记住8421,对于任意一个4位的二进制数,我们都可以很快算出它对应的10进制值.
仅4位的2进制数 快速计算方法 十进制值 十六进值
1111 = 8 &#43; 4 &#43; 2 &#43; 1 = 15 (F)1110 = 8 &#43; 4 &#43; 2 &#43; 0 = 14 (E)如(上行为二制数,下面为对应的十六进制):
             1111 1101 1010 0101 1001 1011   F D A 5 9 B    5 十六进制转十进制 十六进制数的第0位的权值为16的0次方,第1位的权值为16的1次方,第2位的权值为16的2次方…
AF5换算成10进制 直接计算就是:
5 * 16^0 &#43; F * 16^1 &#43; A * 16^2 &#43; 2 * 16^3 = 10997
6 十六进制转二进制 与二进制转十六进制雷同.
2 负数 负数的补码等于其符号位不变,数值部分的各位取反,然后整个数加1,正数加0.
 -7的原码(10000111)→按位取反(11111000)(负数符号位不变)→加1(11111001) 所以-7的补码是11111001.求得二进制,负数的其他进制也可以求出了.
 二 位运算 补码　所有的整数类型(除了char类型之外)都是有符号的整数.这意味着他们既能表示正数,又能表示负数.Java使用补码来表示二进制数,在补码表示中,最高位为符号位,正数的符号位为0,负数为1.补码的规定如下:
对正数来说,最高位为0,其余各位代表数值本身(以二进制表示),如 &#43;42的补码为 00101010.
对负数而言,把该数绝对值的补码按位取反,然后对整个数加1,即得该数的补码.如-42的补码为11010110(00101010按位取反11010101&#43;1=11010110)
运算符 含义 描述
 &amp;amp; 按位与 如果两个相应的二进制位都为1,则该位的结果值为1,否则为0 | 按位或 两个相应的二进制位中只要有一个为1,该位的结果值为1 ^ 按位异或 若参加运算的两个二进制位值相同则为0,否则为1 ~ 取反 用来对一个二进制数按位取反,即将0变1,将1变0 &amp;lt;&amp;lt; 左移 用来将一个数的各二进制位全部左移N位,右补0 &amp;gt;&amp;gt; 右移 将一个数的各二进制位右移N位,移到右端的低位被舍弃,对于无符号数,高位补0 详细解释  1 按位与&amp;quot;运算符(&amp;amp;) 按位与:运算数全真,结果才为真按位与运算3&amp;amp;5:
00000011(2)&amp;amp;00000101(2)00000001(2)由此可知3&amp;amp;5=1
按位与的用途:
 清零 若想对一个存储单元清零,即使其全部二进制位为0,只要找一个二进制数,其中各个位符合一下条件:
原来的数中为1的位,新数中相应位为0.然后使二者进行&amp;amp;运算,即可达到清零目的.
例:原数为43,即00101011(2),另找一个数,设它为148,即10010100(2),将两者按位与运算:  00101011(2)&amp;amp;10010100(2)00000000(2) 取一个数中某些指定位 若有一个整数a(2byte),想要取其中的低字节,只需要将a与8个1按位与即可.  a 00101100 10101100b 00000000 11111111c 00000000 10101100 保留指定位:
与一个数进行&amp;quot;按位与&amp;quot;运算,此数在该位取1. 例如:有一数84,即01010100(2),想把其中从左边算起的第3,4,5,7,8位保留下来,运算如下:  01010100(2)&amp;amp;00111011(2)00010000(2)----&amp;gt;a=84,b=59c=a&amp;amp;b=162 &amp;ldquo;按位或&amp;quot;运算符(|) 一真为真例如:60(8)|17(8),将八进制60与八进制17进行按位或运算.
00110000|0000111100111111应用:按位或运算常用来对一个数据的某些位定值为1.例如:如果想使一个数a的低4位改为1,则只需要将a与17(8)进行按位或运算即可.
3、&amp;ldquo;异或&amp;quot;运算符(^) 若参加运算的两个二进制位值相同则为0,否则为1即0^0=0,0^1=1,1^0=1, 1^1=0
00111001^0010101000010011应用:
 使特定位翻转 设有数01111010(2),想使其低4位翻转,即1变0,0变1.可以将其与00001111(2)进行&amp;quot;异或&amp;quot;运算,即:  01111010^0000111101110101运算结果的低4位正好是原数低4位的翻转.可见,要使哪几位翻转就将与其进行^运算的该几位置为1即可.
 与0相&amp;quot;异或&amp;rdquo;,保留原值 例如: 012^00=012  00001010^0000000000001010因为原数中的1与0进行异或运算得1,0^0得0,故保留原数.
 交换两个值,不用临时变量 例如:a=3,即11(2);b=4,即100(2). 想将a和b的值互换,可以用以下赋值语句实现:  a=a^b;b=b^a;a=a^b;a=011(2)(^)b=100(2)a=111(2)(a^b的结果,a已变成7)(^)b=100(2)b=011(2)(b^a的结果,b已变成3)(^)a=111(2) &amp;lt;p&amp;gt;a=100(2)(a^b的结果,a已变成4)等效于以下两步:执行前两个赋值语句:&amp;#34;a=a^b;&amp;#34;和&amp;#34;b=b^a;&amp;#34;相当于b=b^a^b).再执行第三个赋值语句: a=a^b.由于a的值等于(a^b),b的值等于(b^a^b), &amp;lt;p&amp;gt;因此,相当于a=a^b^b^a^b,即a的值等于a^a^b^b^b,等于b.4、&amp;ldquo;取反&amp;quot;运算符(~) 他是一元运算符,用于求整数的二进制反码,即分别将操作数各二进制位上的1变为0,0变为1. 例如:~77(8) 源代码:
#include &amp;lt;stdio.h&amp;gt;main(){int a=077;printf(&amp;#34;%d&amp;#34;,~a);}5、左移运算符(&amp;laquo;) 左移运算符是用来将一个数的各二进制位左移若干位,移动的位数由右操作数指定(右操作数必须是非负值),其右边空出的位用0填补,高位左移溢出则舍弃该高位.
例如:将a的二进制数左移2位,右边空出的位补0,左边溢出的位舍弃.若a=15,即00001111(2),左移2位得00111100(2).
源代码:
#include &amp;lt;stdio.h&amp;gt;main(){int a=15;printf(&amp;#34;%d&amp;#34;,a&amp;lt;&amp;lt;2);}左移1位相当于该数乘以2,左移2位相当于该数乘以2*2=4,15&amp;lt;&amp;lt;2=60,即乘了4.但此结论只适用于该数左移时被溢出舍弃的高位中不包含1的情况.
右移运算符:是用来将一个数的各二进制位右移若干位,移动的位数由右操作数指定(右操作数必须是非负值),移到右端的低位被舍弃
对于无符号数,高位补0.对于有符号数,某些机器将对左边空出的部分用符号位填补(即&amp;quot;算术移位&amp;rdquo;)
而另一些机器则对左边空出的部分用0填补(即&amp;quot;逻辑移位&amp;rdquo;).注意:对无符号数,右移时左边高位移入0;对于有符号的值,如果原来符号位为0(该数为正),则左边也是移入0.如果符号位原来为1(即负数),则左边移入0还是1,要取决于所用的计算机系统.有的系统移入0,有的系统移入1.移入0的称为&amp;quot;逻辑移位&amp;rdquo;,即简单移位;移入1的称为&amp;quot;算术移位&amp;rdquo;.
例: a的值是八进制数113755:
a:1001011111101101 (用二进制形式表示)a&amp;gt;&amp;gt;1: 0100101111110110 (逻辑右移时)a&amp;gt;&amp;gt;1: 1100101111110110 (算术右移时)在有些系统中,a&amp;gt;&amp;gt;1得八进制数045766,而在另一些系统上可能得到的是145766.Turbo C和其他一些C编译采用的是算术右移,即对有符号数右移时,如果符号位原来为1,左面移入高位的是1. 源代码:
#include &amp;lt;stdio.h&amp;gt;main(){int a=0113755;printf(&amp;#34;%d&amp;#34;,a&amp;gt;&amp;gt;1);}7、位运算赋值运算符 位运算符与赋值运算符可以组成复合赋值运算符. 例如: &amp;amp;=, |=, &amp;raquo;=, &amp;laquo;=, ^= 例: a &amp;amp; = b相当于 a = a &amp;amp; b a &amp;laquo; =2相当于a = a &amp;laquo; 2
三 实例   Integer.toHexString(bt &amp;amp; 0xFF);//为什么在算MD5时为什么与要0xff进行与运算呢
先来看二进制的与运算，如：-1 &amp;amp; 1 ＝ 1
-1（负1）的二进制编码为： 11111111 11111111 11111111 11111111 即一个32位的字符串，前面一位是1表示负数
1（正1） 的二进制编码为： 00000000 00000000 00000000 00000001 即，只有最后一位是1，其他部分全部为0
按&amp;amp;（与运算）的法则结果： 00000000 00000000 00000000 00000001 即，只有当两个都为1时才为1，所以最后的结果为：1(正1)
则可以知道为什么要与0xFF进行与运算，因为OxFF的16进行为 ：000000FF。任意数与OxFF进行与运算都是取16进制的后两位 运算示例如下：
-127(负数127)的16进制为： FFFFFF81
0xFF的16进制为： 000000FF
则&amp;amp;（与）运算是结果为： 00000081
所以：Integer.toHexStriing(-127 &amp;amp; 0xFF) 的结果为：81
  以十六进制查看二进制文件
  public class Hex {public static String format(byte[] data) {StringBuilder result = new StringBuilder();int n = 0;for (byte b : data) {if(n%16==0)result.append(String.format(&amp;#34;%05x: &amp;#34;,n));result.append(String.format(&amp;#34;%02x &amp;#34;,b));n&#43;&#43;;if(n%16==0)result.append(&amp;#39;\n&amp;#39;);}return result.toString();}}位运算总览    运算符 描述 图解 实例     &amp;amp; 按位与。按位与运算符对两个数进行操作，然后返回一个新的数，这个数的每个位都需要两个输入数的同一位都为1时才为1  (A &amp;amp; B) 结果为 12, 二进制为 0000 1100   或 按位或。按位或运算符比较两个数，然后返回一个新的数，这个数的每一位设置1的条件是两个输入数的同一位都不为0(即任意一个为1，或都为1)  (A或 B) 结果为 61, 二进制为 0011 1101   ^ 按位异或. 按位异或运算符^比较两个数，然后返回一个数，这个数的每个位设为1的条件是两个输入数的同一位不同，如果相同就设为0  (A ^ B) 结果为 49, 二进制为 0011 0001   ~ 按位取反运算符~对一个操作数的每一位都取反  (~A ) 结果为 -61, 二进制为 1100 0011   &amp;lt;&amp;lt; 按位左移。左移操作符（&amp;lt;&amp;lt;）将操作数的所有位向左移动指定的位数 下图展示了11111111 &amp;lt;&amp;lt; 1（11111111 左移一位）的结果。蓝色数字表示被移动位，灰色表示被丢弃位，空位用橙色的0填充 A &amp;lt;&amp;lt; 2 结果为 240, 二进制为 1111 0000   &amp;gt;&amp;gt; 按位右移。右移操作符（&amp;lt;&amp;lt;）将操作数的所有位向又移动指定的位数 下图展示了11111111 &amp;gt;&amp;gt; 1（11111111 右移一位）的结果。蓝色数字表示被移动位，灰色表示被丢弃位，空位用橙色的0填充 A &amp;gt;&amp;gt; 2 结果为 15, 二进制为 0000 1111   </content>
    </entry>
    
     <entry>
        <title>同步利器GoodSync</title>
        <url>https://farwmarth.com/post/%E5%90%8C%E6%AD%A5%E5%88%A9%E5%99%A8goodsync/</url>
        <categories>
          <category>tools</category>
        </categories>
        <tags>
          <tag>效率之道</tag>
        </tags>
        <content type="html"> Goodsync 用了两年了，个人感觉是比较好的同步工具，适合各种同步场景。u盘到目录，本地目录到本地目录，本地到远程，局域网共享目录到目录 等等。
Goodsync分为免费和付费版，我用的版本是9.1 破解版，破解前要将日期往2010年前调，破解之后去掉自动更新设置，网上有破解版本。
使用它第一步就是新建任务，任务分两种类型:备份和同步. 备份任务是单向的，如左向右，则备份则是保证右边和左边的状态一致，右边有多余的文件会删除。 同步任务会保证两边的状态保证一致。
新建任务后浏览左右边的目录，点击分析,分析完成后，点击同步就开始同步了.
下面我建立的arrow是一个单向从左到右的备份任务，用来发布测试工程到tomcat,不用每次都重新复制整个工程.publish任务是将编译好的工程与要发布到外网svn上的工程同步.assets是用来同步普通版本和台湾版本素材的。 如图中向右的箭头表示会将左边的数据覆盖到右边,树形视图中有各个状态的目录. 更改: 要更改的文件, 已排除: 不会同步的文件 ， 新建: 新添加的文件 , 覆盖: 右边将要被覆盖的文件.
1 如果要排除文件: 右键分析的文件夹:有排除选项. 我通常用这个功能来排除所有的.svn文件.
2 如果从向左到右的任务里只是想将左边新增的项复制到右边，而不覆盖右边的文件，可选中树形视图中覆盖选项，在根项目中不做复制昨天晚上发现可以用它来备份wordpress数据.如图sftp协议格式: sftp://ip:port 注意的是要支持SSH-2的服务器 ,配置可参考:http://www.goodsync.com/support/manual#fs-sftp
不知道是国外主机的原因还是什么: 40M的内容sftp 用了将近两个小时，恒定速度为8kb/s.求解.
</content>
    </entry>
    
     <entry>
        <title>浅析 robotlegs2</title>
        <url>https://farwmarth.com/post/%E6%B5%85%E6%9E%90-robotlegs2/</url>
        <categories>
          <category>actionscript</category>
        </categories>
        <tags>
          <tag>robotlegs2</tag>
        </tags>
        <content type="html"> 当前阅读版本: 2.0.0b3. https://github.com/robotlegs/robotlegs-framework 源代码中有readme文档，阅读readme可以了解整个程序的大致结构.
1 概述 robotlegs2比 1.5 的结构更加灵活,但是额外加了两个依赖包:
重构后robotlegs2分为四个部分 ：
 核心framework,包括:容器(Context) ,配置管理器(Configuration manager),扩展管理(Extension installer),两个新的状态对象(Guards and hooks) ,生命周期管理(Lifecycle),日志(Logging) 扩展 :包括了 m v c 的管理器，日志扩展，事件中心等等。 扩展包(Bundles): 实现的只有一个MVCSBundle,顾名思义是MVC的扩展组合 . MXML支持  2 容器解析 RobotLegs的核心类是Context 管理整个程序的生命周期，和 puremvc 的Facade 有点类似的味道.
我们先来创建一个简单的容器,再分析创建容器具体做了一些什么.
_context = new Context().install(MVCSBundle).configure(AppConfig,new ContextView(this));这句代码就是创建一个容器上下文，并且装载mvc扩展包，添加一些自定的配置，将主视图初始化. Context初始化调用的方法
private function setup():void{_injector.map(Injector).toValue(_injector);_injector.map(IContext).toValue(this);_logger = _logManager.getLogger(this);_lifecycle = new Lifecycle(this);_configManager = new ConfigManager(this);_extensionInstaller = new ExtensionInstaller(this);beforeInitializing(beforeInitializingCallback);afterInitializing(afterInitializingCallback);beforeDestroying(beforeDestroyingCallback);afterDestroying(afterDestroyingCallback);}大概操作为:绑定注入器,绑定上下文，为容器提供日志,生命周期对象 ,配置管理，扩展安装类，后面几个是执行几个回调.
MVCSBundle 装载
public function extend(context:IContext):void{context.logLevel = LogLevel.DEBUG;context.install(TraceLoggingExtension,VigilanceExtension,InjectableLoggerExtension,ContextViewExtension,EventDispatcherExtension,ModularityExtension,CommandCenterExtension,EventCommandMapExtension,LocalEventMapExtension,ViewManagerExtension,StageObserverExtension,ManualStageObserverExtension,MediatorMapExtension,StageSyncExtension);context.configure(ContextViewListenerConfig);}写了个关于下拉切换图片的demo,还发邮件给作者 Shaun Smith 问了个低级问题:怎么样在初始化容器后派发事件来启动框架，Shaun Smith 让我把问题提交到http://knowledge.robotlegs.org/discussions/robotlegs-2/ ,在这找到了答案，在你的config里面里就可以使用容器上下文，和事件派发器了:
package com.far.robotlegs2{import com.far.robotlegs2.commands.GetDataCommand;import com.far.robotlegs2.common.view.ImageSelect;import com.far.robotlegs2.common.view.ImageShow;import com.far.robotlegs2.events.AppEvent;import com.far.robotlegs2.mediators.ImageSelectMediator;import com.far.robotlegs2.mediators.ImageShowMediator;import com.far.robotlegs2.models.ImageModel;import flash.display.DisplayObjectContainer;import flash.events.IEventDispatcher;import robotlegs.bender.extensions.contextView.ContextView;import robotlegs.bender.extensions.eventCommandMap.api.IEventCommandMap;import robotlegs.bender.extensions.mediatorMap.api.IMediatorMap;import robotlegs.bender.framework.api.IContext;public class AppConfig{[Inject]public var eventDispatcher:IEventDispatcher;[Inject]public var contextview:ContextView;[Inject]public var mediatorMap:IMediatorMap;[Inject]public var commandMap:IEventCommandMap;[Inject]public var context:IContext;public function AppConfig(){}[PostConstruct]public function start():void{context.injector.map(ImageModel).toSingleton(ImageModel);mediatorMap.map(ImageSelect).toMediator(ImageSelectMediator);mediatorMap.map(ImageShow).toMediator(ImageShowMediator);commandMap.map(AppEvent.GETDATA,AppEvent).toCommand(GetDataCommand);addImageSelect(contextview.view);addImageShow(contextview.view);eventDispatcher.dispatchEvent(new AppEvent(AppEvent.GETDATA));}public function addImageSelect(container:DisplayObjectContainer):ImageSelect{return new ImageSelect(container);}public function addImageShow(container:DisplayObjectContainer):ImageShow{var imshow:ImageShow=new ImageShow();imshow.y=50;container.addChild(imshow);return imshow;}}}还要注意的是Mediator的onRegister 在2里面是initialize. robotlegs2还在开发中，希望作者尽快出来正式版.这段时间会仿着写个更轻量的框架.
</content>
    </entry>
    
     <entry>
        <title>GTD</title>
        <url>https://farwmarth.com/post/gtd/</url>
        <categories>
          <category>mind</category>
        </categories>
        <tags>
          <tag>gtd</tag>
        </tags>
        <content type="html">  GTD流程图 : Getting Things Done的缩写
 把所有事情都从你的脑袋里弄出来。在事情出现就做好相关行动的一系列决定，而不是在事情爆发的时候。以合适的类别组织好你的项目的各种提醒以及下一步行动。保持你的系统更新和完整，及时进行回顾，使你在任何时候都能信任你的系统和对任务的处理。”
GTD系统由五条核心原则组成：收集、处理、管理、执行、回顾
搜集 把任何你需要跟踪或者记住或者做的事情记在Allen称之为‘水桶’的地方：一个收件箱，电子邮箱，磁带，笔记本，PDA，或者它们的组合。把你脑子里的任何东西都拿出来放到你的搜集设备里，准备好做下一步的处理。每星期所有的水桶都应该被至少清空一次。
处理 处理你的收件箱要遵循一个严格的工作流程： 从最上面开始。 一次处理一项。 不把任何东西放回收件箱。 如果任何一项需要做： 做（如果花的时间少于两分钟） 委托别人完成，或者 把它延期。 否则 把它存档以便查询， 把它扔掉，或者 使它成熟以便下一步的处理 两分钟原则：任何事情如果花的时间少于两分钟，那么马上就去做。两分钟是一个分水岭，这样的时间和正式地推迟一个动作所花的时间差不多。
组织 Allen描述了一个建议的列表集合，你可以用来跟踪需要关注的项目： 下一步行动(Next actions) - 对于每个需要你关注的事项，定好什么是你可以实际采取的下一步行动。例如，如果事项为“写项目报告”，下一步行动可能会是“给Fred发邮件开个简短会议”，或者“给Jim打电话问报告的要求”，或者类似的事情。虽然要完成这个事项，可能会有很多的步骤和行动，但是其中一定会有你需要首先去做的事情，这样的事情就应该被记录在“下一步行动”列表上。较好的做法是把这些事项根据能够被完成的“环境”整理分类，例如“在办公室”,“用电话”,“在商场”.
专案(Projects) - 每个需要多于一个实际的行动才能达到的生活或者工作中的“开放式回路”就是一个“专案”.
使用跟踪以及周期性的回顾来确保每个专案都有一个下一步的行动进行下去。
等待(Waiting for) - 当你已经指派了一个事项给其他人或者在项目进行下去之前需要等待外部的事件，就应当在你的系统当中跟踪以及定期检查是否已经可以采取行动或者需要发出一个提醒。
将来／可能(Someday/Maybe) - 这些事情你需要在某个点去做，但是不是马上。例如：“学习中文”，或者“进行一个潜水假期”.
对于跟踪你的预约和委托，一个日历也是重要的；另外，Allen特别推荐日历应该被用在他所谓的“硬工程”上：必须在某个特定的期限之前完成的事情，或者在约定的时间和地点完成的会议和约会.“待办”事项应该用在下一步行动列表当中。
GTD的最后一个关键组织模块是归档系统.“Getting Things Done”书里说如果要用一个归档系统，那它必须得是简单易用和有趣。即使是一张纸，如果你需要用来记录参考信息，如果不属于你已经有的一个目录，也要有自己的文件组织方式。Allen的建议是你可以维护一个按照字母顺序组织的归档系统，这样可以比较容易快速的存储和提取你所想要的信息。
Google的Gmail的用户可以用创建标签的方式来创建“待办事项”和“项目”，这种方式在Bryan Murdaugh的 “Getting Things Done with Gmail” [1]白皮书中有清楚的描述。它保留了很多GTD的相同概念，但是是在在线的电子邮件系统中实施。
检查 做 软件  doit.im </content>
    </entry>
    
     <entry>
        <title>用bat来提高工作效率</title>
        <url>https://farwmarth.com/post/%E7%94%A8bat%E6%9D%A5%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/</url>
        <categories>
          <category>bat</category>
        </categories>
        <tags>
          <tag>bat</tag><tag>效率之道</tag>
        </tags>
        <content type="html"> 项目发布流程通常是手工的，需要加密，编译模块，改名，svn提交，生成版本号。上传svn服务器。手工发布效率很低。还容易出错。就写了个bat脚本 。
本来是打算写ant脚本的。但ant脚本需要环境支持,还是用bat算了。
关键的语法解析:
%~d0 定位到bat所在盘符cd %~dp0 定位到bat目录find &amp;#34;isDebug&amp;#34; %sysnet%|find &amp;#34;true&amp;#34;&amp;amp;gt;nul 检测as文件开关是否是发布版本mydailybuild\bin\adl mydailybuild\bin\aidiTestCode-app.xml -- %projectPath%bin-debug\  0 1 给air程序传递参数来加密素材还有就是遍历模块编译bat,不再详细写出了。代码如下:
::aidiTestCode-app.xml::递归加密目录 目录 ,1,0::非递归加密目录 目录 ,0,0::加密单个文件 文件,1,0::加密主文件 目录 ,0,1@echo off::工程路径 ，项目路径改变时请更改%~d0cd %~dp0cd ..set projectPath=%cd%\ :: 每个bat生成的编译数set pageNum=15::不同版本的素材别称 tw\ ::set langType=tw\  ::下面的变量不要配置set buildPath=%projectPath%bin-buildset versionPath=%projectPath%src\%langType%assetsset modulesPath=%versionPath%\appset versionFile=%versionPath%\ui\common\filever.xmlset ucommon=%versionPath%\ui\commonset u7kcommon=%versionPath%\ui\7k7k\commonset sysnet=%projectPath%src\etc\net\SysNet.asfind &amp;#34;isDebug&amp;#34; %sysnet%|find &amp;#34;true&amp;#34;&amp;gt;nulif %errorlevel% equ 0 ( echo 不是发行版本,请修改SysNet.as pause exit)echo 是发行版本echo *****echo 1 大陆版 2台湾版set /p langTypeChoice=&amp;#34;选择编译版本 &amp;#34; if %langTypeChoice% EQU 1 (set langType=) if %langTypeChoice% EQU 2 (set langType=tw)%~d0cd %~dp0echo 开始发布主程序call &amp;#34;Main.bat&amp;#34;%~d0cd %~dp0echo 开始生成模块编译文件mydailybuild\bin\adl mydailybuild\bin\scriptBuilder-app.xml -- %projectPath% %pageNum% %langType%echo 开始加密主程序mydailybuild\bin\adl mydailybuild\bin\aidiTestCode-app.xml -- %projectPath%bin-debug\  0 1move /y &amp;#34;%projectPath%bin-debug\utils.tempdata&amp;#34; &amp;#34;%ucommon%&amp;#34;move /y &amp;#34;%projectPath%bin-debug\events.tempdata&amp;#34; &amp;#34;%ucommon%&amp;#34;mydailybuild\bin\adl mydailybuild\bin\aidiTestCode-app.xml -- %projectPath%bin-debug\7k7k\  1 0move /y &amp;#34;%projectPath%bin-debug\7k7k\utils.tempdata&amp;#34; &amp;#34;%u7kcommon%&amp;#34;move /y &amp;#34;%projectPath%bin-debug\7k7k\events.tempdata&amp;#34; &amp;#34;%u7kcommon%&amp;#34;echo 移动加密好的主程序成功:beginCodesetlocal enabledelayedexpansionecho ********echo 请输入选项：echo -2 直接生成版本号xmlecho -1 编译并加密所有模块echo 0 退出for /f &amp;#34;tokens=*&amp;#34; %%i in (&amp;#39;dir /s/b %buildPath%\modules*.bat&amp;#39;) do ( set batPath=!batPath!%%i; set /a count=!count!&#43;1 echo !count! %%~ni )set /p coi=&amp;#34;请输入选项： &amp;#34; if %coi% EQU -2 (goto createVersion) if %coi% EQU -1 (goto codeAll) if %coi% EQU 0 (exit)for %%m in (!batPath!) do ( set /a counta=!counta!&#43;1 if %coi%==!counta! ( for /f &amp;#34;tokens=4 delims= &amp;#34; %%x in (&amp;#39;find &amp;#34;mxmlc&amp;#34; %%m&amp;#39;) do ( set tempstr=%%x set &amp;#34;tempstr=!tempstr:/=!&amp;#34; set oneModuleSwfPath=%projectPath%!tempstr:~6! call %%m %~d0 cd %~dp0 mydailybuild\bin\adl mydailybuild\bin\aidiTestCode-app.xml -- !oneModuleSwfPath! 1 0 del !oneModuleSwfPath! echo !oneModuleSwfPath! ok endlocal pause ) goto beginCode )):codeAllecho 编译所有模块for /f &amp;#34;tokens=*&amp;#34; %%j in (&amp;#39;dir /s/b %buildPath%\all*.bat&amp;#39;) do ( call &amp;#34;%%j&amp;#34; )%~d0cd %~dp0echo 加密模块mydailybuild\bin\adl mydailybuild\bin\aidiTestCode-app.xml -- %modulesPath% 1 0echo 加密模块成功,清除swffor /f &amp;#34;tokens=*&amp;#34; %%k in (&amp;#39;dir /s/b %modulesPath%*.swf&amp;#39;) do ( del &amp;#34;%%k&amp;#34; )goto beginCode:createVersionecho ******echo 提交模块 (1 提交 0不提交 )set /p commitAll=&amp;#34;是否提交所有更改: &amp;#34;if %commitAll% EQU 0 (goto createXML)if %commitAll% EQU 1 (echo 提交所有更改模块svn commit -m &amp;#34;commit modules&amp;#34; %modulesPath%echo 提交7k7k更改svn commit -m &amp;#34;commit 7k7kcommon&amp;#34; %u7kcommon%echo 提交common更改svn commit -m &amp;#34;commit normalcommon&amp;#34; %ucommon%pause):createXMLecho 生成版本号xmlcd %versionPath%svn status assets . -v --xml&amp;gt;%versionFile%echo 转换版本号文件%~d0cd %~dp0mydailybuild\bin\adl mydailybuild\bin\createVersion-app.xml -- %versionFile% echo 加密版本号文件mydailybuild\bin\adl mydailybuild\bin\aidiTestCode-app.xml -- %versionFile% 1 0del %versionFile% 等有时间改成ant脚本试试
</content>
    </entry>
    
     <entry>
        <title>初入wordpress</title>
        <url>https://farwmarth.com/post/%E5%88%9D%E5%85%A5wordpress/</url>
        <categories>
          <category>wordpress</category>
        </categories>
        <tags>
          <tag>wordpress</tag>
        </tags>
        <content type="html"> 刚开始玩网站，记录一下。多谢litefeel的帮忙
申请域名  注册: godaddy.com ,注册教程:http://jingyan.baidu.com/article/414eccf63bb2ea6b421f0a47.html   域名解析:DNSpod 教程: http://xianhuo.org/godaddy-yuming-dnspod-jiexi.html  连接vps 推荐两个工具:
 putty :纯命令行 winscp:有图形界面  putty:

上传文件 用pscp . –r 参数递归拷贝目录.  pscp -P 端口号 -l 用户 -r 本地路径 服务器ip:服务器目录
winscp:

还可以绑定putty来启动.

熟悉的图形界面.

绑定域名 vps上的环境litefeel都搭好了,centos &#43;lnmp ,服务器是nginx:
ngnix配置 log_format 域名 &amp;#39;$remote_addr - $remote_user [$time_local] $request &amp;#39;&amp;#39;$status $body_bytes_sent $http_referer &amp;#39;&amp;#39;$http_user_agent $http_x_forwarded_for&amp;#39;;server{listen 80;server_name 域名;index index.html index.htm index.php default.html default.htm default.php;root 项目目录;include wordpress.conf;location ~ .*.(php|php5)?${try_files $uri =404;fastcgi_pass unix:/tmp/php-cgi.sock;fastcgi_index index.php;include fcgi.conf;}location ~ .*.(gif|jpg|jpeg|png|bmp|swf)${expires 30d;}location ~ .*.(js|css)?${expires 1y;}access_log /home/wwwlogs/*.log 域名;} 检测配置是否正常:/usr/local/nginx/sbin/nginx –t 重启nginx: /usr/local//sbin/nginx -s reload  ok 网站搭建好了。
数据导入。 我的数据是从cnblog上导过来的。用了一个插件。导数据过程中出现warming.是网站目录的文件所属用户不正确的原因。可参考:http://www.litefeel.com/solve-wordpress-need-to-login-to-ftp/.其实也可以通过mysql导入。/usr/bin/mysql -u root –p 登录mysql后用导入命令.
选择写博工具.   wordpress for android:我的wordpress是3.5的版本，默认开启了xml-rpc服务。这个工具还是挺不错，可以在android手机上管理自己的博客，评论文章等功能。
  Windows Live Writer :离线写作的好工具.
  唯一要注意的是日志的远程发布url和日志类型。我选择的是wordpress2.2&#43;
Down.
</content>
    </entry>
    
     <entry>
        <title>在github上建立自己的开源项目</title>
        <url>https://farwmarth.com/post/%E5%9C%A8github%E4%B8%8A%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
        <categories>
          <category>git</category>
        </categories>
        <tags>
          <tag>programm</tag>
        </tags>
        <content type="html">  由于代码一直在自己这保存，一方面别人看不见，也不安全。搜了下，发现在github是一个提供免费git管理的网站，于是用了下，非常爽，功能很强大。
下面就是我注册和提交github代码的流程
先到地址https://github.com/signup/free
注册你的个人信息,用户名，密码，注册邮箱，
其中的ssh public key使用如下命令得到：
ssh-keygen -C guobamantou@126.com -t rsa
这里的-C后的内容就是注册时要登记的邮箱地址
如果你本机已经有个用于ssh的公私钥，就注意把新生成的那个放到别的目录，否则就覆盖掉了。我这条命令是在普通目录下打的，输入命令后输出如下：
Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): test这时我打了一个test,也就是改变了生成公私钥的默认位置，这样就不会覆盖.ssh下的了。
接着一路回车，生成的公私钥就在当前目录下的test和test.pub了。
把这两个文件拷到.ssh下（注意备份旧的）
这时执行cat test.pub，就打出
ssh-rsa ABIwAAAQ..................DGtYAnCQ== guobamantou@126.com复制这个输出的内容到SSH Public Key的输入框，随便写的这个key值是无效的。
确定提交注册申请。
至此，就注册好了 登录自己的帐号，左边出现如下内容。
Welcome to GitHub! What&amp;rsquo;s next? (36 minutes ago)
 Create a Repository  Find a Repository Peruse the GitHub Guides  点击新建新仓库，名字就是minibios，加上描述
其中的homepage url为minibios
好，minibios的项目就建立了。
之后会弹出一个页面教你如何把你的项目代码提交上去，都是git的常规操作。
我的minibios一直都是使用git管理的，直接做最后几步就行了
在minibios目录下：
git remote add origin git@github.com:guobamantou/clean-pmon.gitgit push origin master这个代码现在有2MB左右，上传大概用了有1分钟吧，要有点小耐心。
如果提交的是一个新项目,比如我提交了一个clean-pmon,在创建项目的时设置项目名clean-pmon
现在就提交试试。
mkdir testcd testvi test.txtgit add test.txtgit initgit add test.txtgit commit -agit remote add origin git@github.com:guobamantou/clean-pmon.gitgit push origin master如果顺利的话，几秒钟之后东西就提交上去了
你也可以使用git clone git;//github.com:guobamantou/clean-pmon.git
下载一遍确认一下。
好了，以后minibios就有了家了
主页是http://github.com/guobamantou/minibios
这个地址可以看到每次的修改
http://github.com/guobamantou/minibios/commits/master
如果要下载源码，有download的按钮可供下载tar.gz和zip两种格式的
如果可以的话，使用
git clone git://github.com:guobamantou/minibios.git
使用git协议可以看到每次的提交。
</content>
    </entry>
    
     <entry>
        <title>三月一夏</title>
        <url>https://farwmarth.com/post/%E4%B8%89%E6%9C%88%E4%B8%80%E5%A4%8F/</url>
        <categories>
          <category>life</category>
        </categories>
        <tags>
          <tag>life</tag>
        </tags>
        <content type="html"> 老实说这个夏天 过得太漫长。
花一三个月的时间把所学忘得差不多，细想只剩一些基本思想 。想换个地方 。
草草地总结一下 二个月的工作，其实还学到了些许东西:
 工作态度要严谨  工作不能像学习环境 一下，对一些东西不能模凌两可。比如对数据库的表设计：
原则是：以角色为出发点，再扩展其他的表，每一张表先设计出最核心的字段。
每一张表都是一个对象，要体现出在它的特征，比如：在一个球馆管理系统的表设计 上，学员有普通学员和特长生，特长生有一些参赛信息，而普通学员并没有，所有我单独列了一张表来储存特长生的参赛信息，王总问我怎么来区分普通学员与特长生，我一想：搜索特长生参赛信息表不就ok,
但细想，一个学员的类型应该属于对象特征，而不应该通过其他表的关联来判断它的类型。所以在学员表加了一个学员类型的字段.
设计初期一个考虑不周的地方是无可避免的，唯一能做的是尽量少的减少这种错误，而这直接跟客户需求挂钩，所以在表设计时，对需求的理解是至关重要的 。 在球馆管理系统中有一处地方是比较纠结的，并不是业务有多复杂，是对需求不清楚 ，客户来了谈了一上午，有一处地方没有听清楚 ，在每日盈利计算的时候就有点迷惑了，球馆每天的的盈利算起来很简单的:收益-支出,收益包括商品销售，学员上课的课时费，客户租场地的场地费等等，支出包括球馆日常消费，教练工资，器材消费，关键是要算出每课时学员的课时费.
课时类型和会员类型又有联系，所以就迷糊了。但后还是王总点拔啊，设计出了比较好的解决方案。
 善于与人沟通  无论从事什么职位，这点都是必需的，个人觉得在这方面需要不断努力 。
两个项目中和客户打了一下交道，第一次是一个信息发布的网站，跑了一趟外面，了解了一下基本情况，我不断地问，还有什么需要新加的功能，现在想起来傻的可以，这是变相地给自己加任务。总结就是：在客户满意的基础上给自己减少工作量。
第二次是客户自己过来的，人比较随和,然后提了一些功能方面的要求 ，我一一答应 ，王总回来 对我说:不要老是学会答应 ，试着改变他们的想法。呃，我又无语了。总结是:尝试引导客户，要阐述自己的观点。共同讨论，记得你是提供者，有发言权。
 ** 客户体验至上，编程语言只是个工具**  写了一段时间程序过后，你会发现自己在编程的时候形成了一种思想：对代码结构会有一定的想法，常常会浪费一些时间来设计这些东西，当然这是个好的习惯，但如果项目时间比较紧急的时候，还是要先把任务完成再说，因为，客户看到的只是操作的流畅性和人性化，可能对界面的美化会有一定的要求，但一般人不会说你这个代码结构设计得要有多优良。他们本身并不懂这个，他们要的是最终产品。
我在做第一个任务的时候 一个多星期时间要完成一个门户网站的后台，还有前台的一部分功能，重复性的工作比较多。有二天的时间我都在总结一个ibatis的通知工具类，还有相当一部分时间来找最佳的文件上传方案,后来草草地结束了这个项目。发布后发现有一个很低级的bug，首页的超链接忘记指向到某个地方 了。别人只是认为你太粗心大意了。
所以在时间紧急的情况下，先把任务完成，再修正成好的解决方案。
 ** 时间估算**  这是最值得学习的一点，在以前很少去列一个这样的工作计划列表出来，一般都是今天做今天的事情，尽量完成。这样的缺点是对工作的趋势没有一个好的把握，不知道什么时候能完成手上的工作，所以以后做一个任务应该先有一个工作列表 ，估算某个时间段应该完成什么东西。现在每天都会写工作日志(被逼的),要记录的是:今天上下午的工作内容，遇到的问题。明天的工作估算。还有一个就是写周报: 对上个星期每一个的工作总结 ，这一周的工作总结，下一周的工作估算 。 虽然可能并不能按估算的精确完成每日的任务，但是起码自己心里有个底，知道每一天需要去干什么。
王总让我写了二个项目的周期预算，对于小型项目的话觉得这个估算还是比较精确的。这个工作对以后做项目组长有帮助，哈哈。
 ** 其实有很多事情是可以做的。**    不断学习新的知识。    保持对行业的关注 ，多看一下资讯，以前总认为这是没必要的事情 。 重在积累 ,积累自己的工具包，可以仿写框架 。 不一定要做开发。 坚持感兴趣的东西。 放假了别老呆在房里，一个问题的解决多不定就是因为在路边看到了某件事情 。 保持健康的体魄，清醒的头脑。这点很重要。 适当游戏 。 </content>
    </entry>
    
     <entry>
        <title>as3一些常用数学公式</title>
        <url>https://farwmarth.com/post/as3%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>as3</tag>
        </tags>
        <content type="html"> 基本三角函数的计算：  角的正弦值 = 对边 / 斜边 角的余弦值 = 邻边 / 斜边 角的正切值 = 对边 / 邻边  角度制与弧度制的相互转换：  弧度 = 角度 * Math.PI / 180 角度 = 弧度 * 180 / Math.PI  计算两点间距离： dx = x2 &amp;amp;ndash; x1;dy = y2 &amp;amp;ndash; y1;dist = Math.sqrt(dx*dx &#43; dy*dy);缓动公式: sprite.x &#43;= (targetX - sprite.x) * easing;//easing为缓动系数变量sprite.y &#43;= (targetY - sprite.y) * easing;弹性公式: vx &#43;= (targetX - sprite.x) * spring;//spring为弹性系数vy &#43;= (targetY - sprite.y) * spring;sprite.x &#43;= (vx *= friction);//friction为摩擦力sprite.y &#43;= (vy *= friction);偏移弹性公式: var dx:Number = sprite.x - fixedX;var dy:Number = sprite.y - fixedY;var angle:Number = Math.atan2(dy, dx);var targetX:Number = fixedX &#43; Math.cos(angle) * springLength;var targetY:Number = fixedX &#43; Math.sin(angle) * springLength;向鼠标旋转(或向某点旋转) dx = mouseX - sprite.x;dy = mouseY - sprite.y;sprite.rotation = Math.atan2(dy, dx) * 180 / Math.PI;波形运动: public function onEnterFrame1(event:Event):void {ball.y=centerScale&#43;Math.sin(angle)*rangeangle&#43;=speed}心跳: public function onEnterFrame1(event:Event):void {ball.scaleX=centerScale&#43;Math.sin(angle)*range;ball.scaleY=centerScale&#43;Math.sin(angle)*range;angle&#43;=speed;}圆心旋转: public function onEnterFrame(event:Event):void {ball.x=centerX&#43;Math.cos(angle)*radius;ball.y=centerY&#43;Math.sin(angle)*radius;angle&#43;=speed;}椭圆旋转: public function onEnterFrame(event:Event):void {ball.x=centerX&#43;Math.cos(angle)*radiusX;ball.y=centerY&#43;Math.sin(angle)*radiusY;angle&#43;=speed;}颜色运算得到透明值: var t:uint=0&amp;amp;times;77ff8877var s:uint=0xff000000var h:uint=t&amp;amp;amp;svar m:uint=h&amp;amp;gt;&amp;amp;gt;&amp;amp;gt;24trace(m)转换进制:  转换为十进制 trace(hexValue); 十进制转换为十六进制: decimalValue.toString(16)  颜色提取: red = color24 &amp;amp;gt;&amp;amp;gt; 16;green = color24 &amp;amp;gt;&amp;amp;gt; 8 &amp;amp;amp; 0xFF;blue = color24 &amp;amp;amp; 0xFF;alpha = color32 &amp;amp;gt;&amp;amp;gt; 24;red = color32 &amp;amp;gt;&amp;amp;gt; 16 &amp;amp;amp; 0xFF;green = color32 &amp;amp;gt;&amp;amp;gt; 8 &amp;amp;amp; 0xFF;blue = color232 &amp;amp;amp; 0xFF;按位计算得到颜色值: color24 = red &amp;amp;lt;&amp;amp;lt; 16 | green &amp;amp;lt;&amp;amp;lt; 8 | blue;color32 = alpha &amp;amp;lt;&amp;amp;lt; 24 | red &amp;amp;lt;&amp;amp;lt; 16 | green &amp;amp;lt;&amp;amp;lt; 8 | blue;过控制点的曲线: // xt, yt是你想要让曲线通过的那一点// x0, y0 和x2, y2 是曲线的终点//PS.发现很多人转帖都是直接复制粘贴，也不翻译一下xt * 2 &amp;amp;ndash; (x0 &#43; x2) / 2;y1 = yt * 2 &amp;amp;ndash; (y0 &#43; y2) / 2;moveTo(x0, y0);curveTo(x1, y1, x2, y2);匀速移动到目标点 public function onEnterFrame(event:Event):void {var X = targetX - ball.x;var Y = targetY - ball.y;var Z = Math.sqrt(X * Y &#43; Y * Y); //求出距离	var t = ball.Speed / Z; //求出时间ball.Speed 为求的运动速度var Vx = X / t; //横向速度var Vy = Y / t; //纵向速度ball.x &#43;= Vx;ball.y &#43;= Vy;if(Z &amp;amp;lt;= ball.Speed){ball.x = targetX;ball.y = targetY;return;}//判断距离}移动到目标点 抖动特效 公式 functiononEnterFrame () :void{v = v &#43; easing * (targetX - ball._x);//easing为缓动系数变量	ball._x = ball._x &#43; v;v = spring * v;//spring为抖动幅度变量}</content>
    </entry>
    
     <entry>
        <title>开始记录</title>
        <url>https://farwmarth.com/post/%E5%BC%80%E5%A7%8B%E8%AE%B0%E5%BD%95/</url>
        <categories>
          <category>life</category>
        </categories>
        <tags>
          <tag>life</tag>
        </tags>
        <content type="html"> 上班十来天了,觉得很有必要写一个这样的博客 ,记录一下所见所学所感.
刚开始找工作的时候感觉是挺容易的事,面试,通过,握手,然后就入职。但事实上并非是一蹴而就的,面试了各种不同的公司,每一轮都会暴露出新的薄弱环,刚开始是觉得没准备好,知识储备不够深厚,有些受挫感,但后来仔细想想其实客观原因的比重更大些,毕竟是刚毕业没有任何实战经验的黄毛小子,而不同公司的技术要求又不尽相同.
初次面试,心情紧张远远超越了兴奋感.有一次学校组织的面试,一个人事妹子让我们自我介绍,我脱口而出:各位面试官下午好,其实那天我们是上午去的.全场暴笑.MM给我打的评语是:比较紧张.完了,我当时心里打着退堂鼓,安排了两轮笔试 ,我都侥幸通过,一起过来的同学刷掉了一批,最后剩下了三个人.
过了几天,来电话催人了,面试也安排了两轮:第一轮,一个技术组长过来面试,感觉也是工作不久的,问的问题也没啥水平,没什么压力通过了.然后经理过来跟我们谈工资,问我们的真实学历 ,当时不知道这是学校和这外包公司的勾当,一五一十地说了,这狗娘养的,立马降工资，谈判失败,拍拍屁股就走人了,后来才知道是外包公司,低价买应届生高价出售的那种.
然后陆续面试了几家公司 ,自己从网上投简历，每家必,大多是在谈工资的时候驾崩了.当时就在想,这批人都他妈的是吸血鬼,后来仔细想想也觉得合乎常理了,这就是降低成本来获得最高的利益是基本原则啊.面试见过各种各样的面试官,打着官腔的,也有真正的大拿,也碰到不少和自己一样面试的人,大多是应届毕业和我们一样像是带宰的羔羊,感想就是一些细节性的东西要处理好,代码的精简性,知识点的深度挖掘度.这可能就决定了你是stay here,还是 say goodbye了。
看的面试题大多雷同,葵花宝典上的东西很多,但是如果你真照着答案写的话,不可能得到认可,面试官也不是傻子,真枪实弹地干过,还是纸片功夫一眼便看穿了.
记得有一家做自己产品的公司问了很多无脑的问题(当时的想法),其实是个人水平太差才有这样的想法.并发,负载平衡,事务,数据库锁机制,表分区,不接触到某一类型的项目根本不会去用这些东西，所以说是水平问题啊，每面一次试就觉得，还有很大很大程度上的提高可能，自己完全站在这个金字塔的最低部。为什么每次在谈工资的时候就崩呢,原因不言而喻,经验不足,想问题不够有深度.
面试发现大小公司对人的要求还不是很高,因为大公司有资源去储存,去培养一批人,所以即使你没有经验,但是思维活跃可能就能入职了,而小公司就不一样,小公司要求的是实时的价值.
昨天和老板聊了会天,他问我上了一个星期的班有什么感触,是不是感觉实际应用经验匮乏,确实,因为有些问题你没有碰到的话,你哪会去考虑这么多,这周刚做了个ajax上传的功能,自我感觉良好的时候老板跑过来指正 ,这样工程重新发布的时候 就会出大问题。原来他以前做一个证券公司的网站时就因为这样发布产生了数据丢失.
软件这行业，技术更新太快了，一不小心就落伍了，今天出这个技术，明天是那个，公司一接新的项目，你又得重新去学习新的东西，可能是全新的一种思想，所以要时刻保持着对行业的第度,其实什么编程语言都是假的,用精简方式来解决问题才是一个好的程序员的衡量标准.所以一个很小的东西就能体现你的真实水平，在那家做自己产品的公司面试的时候，要做就做个最牛b的.
经典的东西永远不会过时 ，程序不管怎么变，解决问题的基本方式是无可逆转的。
老板给的启示是:要有良好的编程习惯，要全面深入地去考虑问题的各种可能性，还有一个方面就是要学会沟通，写程序不是最难的，最难的是一个团队一起来完成一个好的产品.
</content>
    </entry>
    
     <entry>
        <title>NodeJs初探</title>
        <url>https://farwmarth.com/post/node/</url>
        <categories>
          <category>programm</category>
        </categories>
        <tags>
          <tag>nodejs</tag>
        </tags>
        <content type="html"> nodejs node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效
安装 mac node使用 #安装brew install node#升级nodebrew upgrade nodelinux node #ubuntu安装6.xcurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs#升级nodenpm install -g nn stable#升级npmnpm install npm -gnodejs常用命令 #查看版本node -v用例 创建最简单的webserver const http = require(&amp;#39;http&amp;#39;);const hostname = &amp;#39;127.0.0.1&amp;#39;;const port = 3000;const server = http.createServer((req, res) =&amp;gt; {res.statusCode = 200;res.setHeader(&amp;#39;Content-Type&amp;#39;, &amp;#39;text/plain&amp;#39;);res.end(&amp;#39;Hello World\n&amp;#39;);});server.listen(port, hostname, () =&amp;gt; {console.log(`Server running at http://${hostname}:${port}/`);});断言(assert) 当需要在一个值为FALSE时中断当前操作的话，可以使用断言
const assert = require (&amp;#34;assert&amp;#34;)assert(true)//成功assert(1)//成功assert(false,&amp;#34;it&amp;#39;s false&amp;#34;)//触发断言//deepEqual用于比较对象的属性是否相等,但会忽略原型链上的属性,原始值使用==const obj1 = {a : {b : 1}};const obj2 = {a : {b : 2}};const obj3 = {a : {b : 1}}const obj4 = Object.create(obj1);assert.deepEqual(obj1, obj1);//同一对象成功assert.deepEqual(obj1, obj2);//失败,对象值不相等assert.deepEqual(obj1, obj3);//成功,值相等assert.deepEqual(obj1, obj4);//失败,忽略原型链上的值node base64 console.log(new Buffer(&amp;#34;Hello World&amp;#34;).toString(&amp;#39;base64&amp;#39;));&amp;lt;!--SGVsbG8gV29ybGQ=--&amp;gt;console.log(new Buffer(&amp;#34;SGVsbG8gV29ybGQ=&amp;#34;, &amp;#39;base64&amp;#39;).toString(&amp;#39;ascii&amp;#39;))&amp;lt;!--Hello World--&amp;gt;npm NPM的全称是Node Package Manager，如ruby的gem，Python的PyPL、setuptools，PHP的pear，NPM就是Nodejs的包管理器
npm常用命令 #版本npm -v#升级模块npm update modulenamesudo npm install npm -gnpm 使用新资源库 #以资源库安装npm --registry &amp;#34;http://npm.hacknodejs.com/&amp;#34; install underscore#默认资源库为淘宝npm config set registry &amp;#34;http://npm.taobao.org/&amp;#34;Node-sass 安装失败解决方案 #macSASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass --save-dev/usr/bin/env: ‘node’: No such file or directory ln -s /usr/bin/nodejs /usr/bin/nodenode调试 sudo npm install supervisor -g #安装supervisor index.jsnode后台运行 nohup node app.js &amp;gt; /foo/log.txt 2&amp;gt;&amp;amp;1 &amp;amp;#或者sudo npm install forever -g #安装forever listforever start app.jsforever stop app.jsforever start -l forever.log -o out.log -e err.log app.js #输出日志和错误</content>
    </entry>
    
     <entry>
        <title>read-the-docs托管学习笔记</title>
        <url>https://farwmarth.com/post/readthedocs/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>sphinx</tag><tag>github</tag><tag>readthedoc</tag>
        </tags>
        <content type="html"> Sphinx Sphinx是一个基于Python的文档生成项目,采用了reStructuredText作为文档写作语言 ,不过也可以通过模块支持其他格式. (Sphinx标记结构)[http://www.pythondoc.com/sphinx/markup/]
Sphinx安装 pip install sphinx sphinx-autobuild快速开始 #创建目录cd /path/to/projectmkdir docs#sphinx工作目录基本配置cd docs#可以回车按默认配置来写sphinx-quickstart#quickstart 后生成的目录结构readthedocs│ make.bat│ Makefile├─build└─source│ conf.py│ index.rst├─_static└─_templates# 默认会有一个index.rst,make html用来生成html页面make html添加一篇文章 在source目录下新建hello.rst:
hello,world======================================index.rst修改如下:
Contents:.. toctree:: :maxdepth: 2 hellomake html后效果如下: toctree 支持多级目录,有时候要区分同文件比如python.rst,swift.rst笔记在不同的目录,toctree这样设置:
Contents:.. toctree:: python/python swift/swift支持markdown编写 pip install recommonmark更改conf.py:
from recommonmark.parser import CommonMarkParsersource_parsers = {&amp;#39;.md&amp;#39;: CommonMarkParser,}source_suffix = [&amp;#39;.rst&amp;#39;, &amp;#39;.md&amp;#39;]更改主题 sphinx_rtd_theme pip install sphinx_rtd_theme更改conf.py:
import sphinx_rtd_themehtml_theme = &amp;#34;sphinx_rtd_theme&amp;#34;html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]Github托管, read_the_docs发布 doc
 github上push用sphinx-quickstart生成的项目,build目录可以设置到.gitignore中 登录readthedocs,注册账号,Connected Services中授权github dashboard中Import a Porject导入github中的项目然后build  Webhooks监听github提交  在文档项目的setting中选中Webhooks &amp;amp; Services, 在Services项中点击Add service 选择ReadTheDocs,点击Active  make nonlocal image URI found waring gone 更改 conf.py
import sphinx.environmentfrom docutils.utils import get_source_linedef _warn_node(self, msg, node, **kwargs):if not msg.startswith(&amp;#39;nonlocal image URI found:&amp;#39;):self._warnfunc(msg, &amp;#39;%s:%s&amp;#39; % get_source_line(node), **kwargs)sphinx.environment.BuildEnvironment.warn_node = _warn_node</content>
    </entry>
    
     <entry>
        <title>reStructuredText简明语法</title>
        <url>https://farwmarth.com/post/restructuredtext%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>reStructuredText</tag><tag>rst</tag>
        </tags>
        <content type="html"> pandoc pandoc 转换rst 为markdown
pandoc rest.rst -f rst -t markdown -s -o rest.md摘录 https://github.com/xunxuny/zh-sphinx-doc/blob/master/rest.rst
本章节介绍 reStructuredText (reST) 的概念和语法，为文档生成者提供足够的信息. reST 被认为是简单，实用的标记语言，因此学习它不会花太多时间.
段落 段落 (ref &amp;lt;paragraphs&amp;gt;) 是reST 文件的基本模块. 段落是由空行分隔的一段文本. 和Python一样, 对齐也是reST的操作符, 因此同一段落的行都是左对齐的.
内联标记 标准的reST 内联标记相当简单:
 星号: *text* 是强调 (斜体), 双星号: **text** 重点强调 (加粗), 反引号: text 代码样式.  星号及反引号在文本中容易与内联标记符号混淆，可使用反斜杠符号转义.
标记需注意的一些限制:
 不能相互嵌套, 内容前后不能由空白: 这样写* text* 是错误的, 如果内容需要特殊字符分隔. 使用反斜杠转义，如: thisis\ *one*\ word.  这些限制在未来版本可能会被改善.
reST 也允许自定义 &amp;ldquo;文本解释角色&amp;rdquo;&#39;, 这意味着可以以特定的方式解释文本. Sphinx以此方式提供语义标记及参考索引，操作符为 :rolename:`content.
标准reST 提供以下规则:
* :durole:emphasis` &amp;ndash; 写成 *emphasis* * strong &amp;ndash; 写成 **strong** * literal &amp;ndash; 写成 literal * subscript &amp;ndash; 下标 * superscript &amp;ndash; 上标 * title-reference &amp;ndash; 书、期刊等材料的标题
详情请查看 inline-markup .
列表与引用 列表标记 (ref &amp;lt;bullet-lists&amp;gt;) 的使用最自然: 仅在段落的开头放置一个星号和一个缩进. 编号的列表也可以;也可以使用符号 # 自动加序号:
* 这是一个项目符号列表.* 它有两项，第二项使用两行.1. 这是个有序列表.2. 也有两项.#. 是个有序列表.#. 也有两项. 列表可以嵌套，但是需跟父列表使用空行分隔 :
* 这是* 一个列表* 嵌套列表* 子项* 父列表继续 定义列表 (ref &amp;lt;definition-lists&amp;gt;) :
术语 (term 文本开头行)定义术语，必须缩进可以有多段组成下一术语（term）描述. 一行仅能写一个术语.
引用段落 (ref &amp;lt;block-quotes&amp;gt;) 仅使用缩进（相对于周围段落）创建.
行模块 (ref &amp;lt;line-blocks&amp;gt;) 可以这样分隔 :
| 这些行| 在源文件里| 被分隔的一模一样. 还有其他有用的模块:
 字段列表 (ref &amp;lt;field-lists&amp;gt;) 选项列表(ref &amp;lt;option-lists&amp;gt;) 字面引用模块 (ref &amp;lt;quoted-literal-blocks&amp;gt;) 文档测试模块 (ref &amp;lt;doctest-blocks&amp;gt;)  源代码 字面代码块 (ref &amp;lt;literal-blocks&amp;gt;) 在段落的后面使用标记 :: 引出. 代码块必须缩进(同段落，需要与周围文本以空行分隔):
这是一段正常文本. 下一段是代码文字::它不需要特别处理，仅是缩进就可以了.它可以有多行.再是正常的文本段. 这个 :: 标记很优雅:
 如果作为独立段落存在,则整段都不会出现在文档里. 如果前面有空白，则标记被移除. 如果前面是非空白，则标记被一个冒号取代.  因此上面的例子第一段文字将变为&amp;quot;下一段是代码文字:&amp;quot;.
表格 支持两种表格. 一种是 网格表格 (ref &amp;lt;grid-tables&amp;gt;), 可以自定义表格的边框. 如下:
&#43;------------------------&#43;------------&#43;----------&#43;----------&#43;| Header row, column 1 | Header 2 | Header 3 | Header 4 || (header rows optional) | | | |&#43;========================&#43;============&#43;==========&#43;==========&#43;| body row 1, column 1 | column 2 | column 3 | column 4 |&#43;------------------------&#43;------------&#43;----------&#43;----------&#43;| body row 2 | ... | ... | |&#43;------------------------&#43;------------&#43;----------&#43;----------&#43; 简单表格 (ref &amp;lt;simple-tables&amp;gt;) 书写简单, 但有一些限制: 需要有多行，且第一列元素不能分行显示，如下:
===== ===== =======A B A and B===== ===== =======False False FalseTrue False FalseFalse True FalseTrue True True===== ===== ======= 超链接 外部链接 使用 `链接文本 &amp;lt;http://example.com/&amp;gt;`_ 可以插入网页链接. 链接文本是网址，则不需要特别标记，分析器会自动发现文本里的链接或邮件地址.
可以把链接和标签分开 (ref &amp;lt;hyperlink-targets&amp;gt;), 如下:
段落里包含 `a link`_... _a link: http://example.com/ 内部链接 内部链接是Sphinx特定的reST角色, 查看章节 ref-role.
章节 章节的标题 (ref &amp;lt;sections&amp;gt;) 在双上划线符号之间（或为下划线）, 并且符号的长度不能小于文本的长度:
=================This is a heading================= 通常没有专门的符号表示标题的等级，但是对于Python 文档，可以这样认为:
 # 及上划线表示部分 * 及上划线表示章节 =, 小章节 -, 子章节 ^, 子章节的子章节 &amp;quot;, 段落  当然也可以标记（查看 reST 文档), 定义章节的层次，但是需要注意输出格式(HTML, LaTeX)所支持的层次深度 .
显式标记 显式标记&amp;quot;Explicit markup&amp;rdquo; (ref &amp;lt;explicit-markup-blocks&amp;gt;) 用在那些需做特殊处理的reST结构中, 如尾注，突出段落，评论，通用指令.
显式标记以 .. 开始，后跟空白符，与下面段落的缩进一样. (在显示标记与正常的段落间需有空行，这听起来有些复杂，但是写起来会非常直观.)
指令 指令 (ref &amp;lt;directives&amp;gt;) 是显式标记最常用的模块. 也是reST 的扩展规则, 在 Sphinx 经常被用到.
文档工具支持以下指令:
  警告: attention, caution, danger, error, hint, important, note, tip, warning 及通用标记 admonition. (大多数模式仅支持 &amp;ldquo;note&amp;rdquo; 及 &amp;ldquo;warning&amp;rdquo; )
  图像:
 image (详情可看下面的 图像_ ) figure (有标题及可选说明的图像)    额外的主体元素:
 contents &amp;lt;table-of-contents&amp;gt; (本地，仅是当前文件的内容表格) container (自定义容器，用来生成HTML的 &amp;lt;div&amp;gt; ) rubric (和文档章节无关的标题) topic, sidebar (高亮显示的主体元素) parsed-literal (支持内联标记的斜体模块) epigraph (可选属性行的摘要模块) highlights, pull-quote (有自己的类属性的摘要模块) compound ( 复合段落)    专用表格:
 table (有标题的表格) csv-table (CSV自动生成表格) list-table (列表生成的表格)    专用指令:
 raw (包含原始格式的标记) include (包含reStructuredText标记的文件) &amp;ndash; 在Sphinx中,如果包含绝对文件路径，指令会以源目录地址做为参照 class (将类属性指派给下一个元素) 1    HTML 特性:
 meta (生成HTML &amp;lt;meta&amp;gt; 标签) title (覆盖文档标题)    影响标记:
 default-role (设置新的默认角色) role (创建新的角色)  如果仅有一个文件，最好使用 default_role.
  设置不使用指令 sectnum, header 及 footer.
Sphinx 新增指令可查阅 sphinxmarkup.
指令有名字，参数，选项及内容组成. (记住这些，在下面一小节中自定义指令里会用到).来看一个例子:
.. function:: foo(x)foo(y, z):module: some.module.name返回用户输入的一行文本. function 是指令名字. 在第一行和第二行给出了两个参数, 及一个选项 module (如你所见，选项在参数后给出，由冒号引出). 选项必须与指令有一样的缩进.
指令的内容在隔开一个空行后，与指令有一样缩进.
图像 reST 支持图像指令 (ref &amp;lt;image&amp;gt;), 如下:
.. image:: gnu.png(选项) 这里给出的文件名( gnu.png) 必须是源文件的相对路径，如果是绝对路径则以源目录为根目录. 例如，在文件 sketch/spam.rst 引用图像 images/spam.png ，则使用 ..https://farwmarth.bestnewbee.com/images/spam.png 或者 https://farwmarth.bestnewbee.com/images/spam.png.
Sphinx 会自动将图像文件拷贝到输出目录的子目录里，( 输出HTML时目录为 _static )
图像的大小选项 (width 及 height) : 如果没有单位或单位为像素, 给定的尺寸信息仅在输出通道支持像素时才有用 ( 如输出LaTeX 没用). 其他单位在输出(如 pt )HTML、LaTeX 时被用到.
Sphinx 延伸了标准的文档化行为，只需在后面加星号:
.. image:: gnu.* 上面这样写，Sphinx 会搜索所有名字匹配的图像，而不管图像类型. 每个生成器则会选择最合适的图像. 一般，在源文件目录里文件名 gnu.* 会含有两个文件 gnu.pdf 和 gnu.png , LaTeX 生成器会选择前者，而HTML 生成器则匹配后者.
尾注 尾注 (ref &amp;lt;footnotes&amp;gt;), 使用 [#name]_ 标记尾注的位置, 尾注的内容则在文档底部红色标题&amp;quot;Footnotes&amp;quot;的后面 , 如下:
Lorem ipsum [#f1]_ dolor sit amet ... [#f2]_.. rubric:: Footnotes.. [#f1] 第一条尾注的文本... [#f2] 第二条尾注的文本. 你也可以使用数字尾注 ([1]_) 或使用自动排序的([#]_).
引用 支持标准的reST 引用 (ref &amp;lt;citations&amp;gt;) , 且新增了&amp;quot;global&amp;quot;特性, 所有参考文献不受所在文件的限制. 如:
Lorem ipsum [Ref]_ dolor sit amet... [Ref] 参考文献, 书,URL 等. 引用的使用同尾注很相近，但是它们没有数字标签或以 # 开始.
替换 reST 支持替换 &amp;ldquo;substitutions&amp;rdquo; (ref &amp;lt;substitution-definitions&amp;gt;), 有一小段文本或标记被关联到 |name|. 定义与尾注一样需有明确的标记块，如下:
.. |name| replace:: replacement *text* 或者:
.. |caution| image:: warning.png:alt: Warning! 详情查看 reST reference for substitutions &amp;lt;substitution-definitions&amp;gt; .
如果想在所有文档中使用这些替换, 需把它们放在 rst_prolog 或一个单独文件里， 然后在使用它们的文档文件里包含这个文件，包含指令 :rstinclude . (请给出包含文件的扩展名，已区别于其他的源文件，避免Sphinx将其作为独立的文档文件.)
Sphinx 定义了一些默认的替换, 请查看 default-substitutions.
评论 有明确标记块但又不是有效的结构标记的标记 (像上面的尾注）都被视为评论 (ref &amp;lt;comments&amp;gt;). 例如:
.. 这是一个评论. 可以通过缩进产生多行评论:
..这整个缩进块都是一个评论.仍是一个评论. 源编码 在reST使用Unicode字符可以容易的包含特殊字符如破折号，版权标志. Sphinx 默认源文件使用UTF-8 编码; 你可以通过 source_encoding 的配置值改变编码.
常见问题 具体使用中可能会遇到一些问题:
 内联标记的分离 如上面所讲，内联标记需与周围的文本使用空格分隔, 内联标记内部则使用反斜线转义空格. 查看详情: the reference . 内联标记不能嵌套 像这样写 *see :func:`foo`* 是不允许的.  Footnotes
  当默认主域里包含指令 :rstclass , 这个指令将被隐藏 因此, Sphinx使用 :rstrst-class. &amp;#x21a9;&amp;#xfe0e;
  </content>
    </entry>
    
     <entry>
        <title>ubuntu,centos 备忘</title>
        <url>https://farwmarth.com/post/ubuntu%E5%A4%87%E5%BF%98/</url>
        <categories>
          <category>ubuntu</category>
        </categories>
        <tags>
          <tag>ubuntu</tag>
        </tags>
        <content type="html"> 安装常用软件:  subversion svn 版本命令行 lua5.2 lua版本 ssh ssh 连接 nautilus-open-terminal 终端 fcitx-table-wbpy 五笔 avant-window-navigator 启动器位置  常用操作 # 查看版本cat /etc/issue# 修改密码sudo passwd 用户名# 查看端口占用lsof -i:80# 所占端口netstat -antp | grep skynet# 查看环境变量env# 查看当前系统版本信息cat /etc/issue# 查看端口数据tcpdump -s 0 -X &amp;#39;tcp dst port 8888&amp;#39;# 卸载程序sudo dpkg -l sub*sudo dpkg -r sublime-text# 查看磁盘占用 du -sh /* #查找内存rsz为实际内存ps -e -o &amp;#39;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&amp;#39; |grep skynetps -e -o &amp;#39;pid,comm,rsz&amp;#39; |grep skynet#查找最后多少行信息tail -n 50 nohup.out查找文件 #按时间反序排序当前文件夹中文件（-r反序）ls -ltr#按时间ll -t -time-style=full-iso#在当前文件夹内查找最近一天内更改的文件（包括子文件夹）：find . -type f -mtime -1#1天以前更改的文件：find . -type f -mtime &#43;1#最近10分钟内状态变化的文件：find . -type f -cmin -10#一天内修改过的文件find . -atime -1#查找指定名字的文件find . -name &amp;#34;*.xmind&amp;#34; # 按大小查找find . -size &#43;1000c -print #删除目录下所有的pycfind . -name &amp;#34;*.pyc&amp;#34; -exec rm -f {} \;#tree :生成目录结构tree . -L 1 #设置层次#linux 修改时间同步时间date -s 14:36:00clock -w/usr/sbin/ntpdate –u 0.asia.pool.ntp.org#按名称查找 find / -name mysql#查看glibc版本ldd --version#指定前后行数cat a.txt |grep -C 5 xx#统计字符串出现次数cat logging.2016-11-19--01-03-29-31812.log |grep -c _recv_pay_data安装jdk   在Ubuntu下安装jdk 出现./install.sfx.2354: not found无法安装成功 sudo apt-get install g&#43;&#43;-multilib 
  安装
  sudo chmod u&#43;x jdk-6u23-ea-bin-b03-linux-i586-18_oct_2010.bin ./jdk-6u23-ea-bin-b03-linux-i586-18_oct_2010.bin sudo gedit ~/.bashrc export JAVA_HOME=/home/far/Develop/tools/jdk1.6.0_38 source ~/.bashrc 改变键盘布局ctrl win grep -e &amp;#34;ctrl:\|:ctrl&amp;#34; /usr/share/X11/xkb/rules/evdev.lstsetxkbmap -option altwin:ctrl_winsetxkbmap -printpython sudo apt-get install python-pycurlsudo apt-get install python-pip--dabiansudo yum install gcc python-develpython setup.py buildpython setup.py install查看已安装的python模块: help(&amp;#34;modules&amp;#34;)给alias添加命令行参数 alias pc=&amp;#39;commit() { git add .; git commit -m &amp;#34;$1&amp;#34;; git push origin source }; commit&amp;#39;putty  上传文件   备份 PuTTY 配置文件  开始-&amp;gt;运行(Win&#43;R)-&amp;gt;regedit 找到 HKEY_CURRENT_USER/Software/SimonTatham 在 SimonTatham 这个节点上点击右键，选择导出，保存即可 putty在登录之后自动切换到目录  ssh---&amp;gt;remote command 添加cd /my/path ; /bin/bashubuntu 常见问题 Ubuntu无法找到add-apt-repository问题的解决方法 apt-get install python-software-propertiesapt-get install software-properties-common应用菜单栏消失 initctl restart unity-panel-service</content>
    </entry>
    
     <entry>
        <title>将内网终端分享给其他人使用</title>
        <url>https://farwmarth.com/post/ttyd/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>ttyd</tag>
        </tags>
        <content type="html">  起因是某人要学习下linux,但是不想用虚拟机装linux,在网上也找了几个在线的shell练习网站,感觉不是很满意,于是想把自己内网主机上的终端share一下,github搜索了一下还真有这样的项目.
ttyd ttyd是一个把自己的终端通过web方式共享给其他人操作的工具
https://github.com/tsl0922/ttyd
sudo ttyd login#默认端口是7681 用login方式要输入账号密码#http://localhost:7681ngrok ngrok服务可以分配给你一个域名让你本地的web项目提供给外网访问，特别适合向别人展示你本机的web demo 以及调试一些远程的API.
 qydev : http://qydev.com/  ./ngrok -config=ngrok.cfg -hostname farwmarth 7681#http://farwmarth.tunnel.qydev.com/frp frp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, udp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发
一键安装 wget --no-check-certificate https://raw.githubusercontent.com/clangcn/onekey-install-shell/master/frps/install-frps.sh -O ./install-frps.shchmod 700 ./install-frps.sh./install-frps.sh installfrp配合ttyd的配置 #frpc.ini[common]server_addr = frp.lu8.winserver_port = 7000log_file = ./frpc.loglog_level = infolog_max_days = 3privilege_token = frp888[http_mode]#注意修改上方[]内的内容，不要与其他隧道名称重复#privilege_mode特权模式privilege_mode = truetype = http#local_ip本地服务IPlocal_ip = 127.0.0.1#local_port本地服务端口local_port = 7681custom_domains = farwmarth.frp.lu8.winfrp配合nginx 域名解析到服务器frptest.xxx.com
服务器frp配置 [common]bind_addr = 0.0.0.0bind_port = 7000vhost_http_port = 5999[frptest]type = httpauth_token = xxxcustom_domains = frptest.xxx.comnginx配置 upstream frptest{server 127.0.0.1:5999;}server{listen 80;server_name frptest.xxx.com;location / {proxy_pass http://frptest;proxy_http_version 1.1;proxy_read_timeout 7200;proxy_set_header Connection &amp;#34;&amp;#34;;proxy_set_header Host $host;proxy_set_header X-Real-Ip $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}}客户端frp配置 [common]server_addr = 服务器ipserver_port = 7000auth_token xxxlog_file = ./frpc.loglog_level = infolog_max_days = 3[frptest]local_ip = 127.0.0.1local_port = 8080type = httpauth_token = xxx```### 用frp做ssh转发时序图大致如下:![](https://farwmarth.bestnewbee.com/14904631822511.jpg)#### 外网服务器配置```shell#frps.ini[common]bind_addr = 0.0.0.0bind_port = 7000log_max_days = 7max_pool_count = 100log_file = frps.loglog_level = info[ssh]listen_port = 6000type = tcpauth_token = 通讯加密tokenuse_encryption = trueuse_gzip = true内网客户端配置 先要安装ssh服务开启并将端口设置为22022
#frpc.ini[common]server_addr = 外网服务器ipserver_port = 7000auth_token = 通讯加密tokenlog_file = ./frpc.loglog_level = infolog_max_days = 3[ssh]local_ip = 127.0.0.1local_port = 22022type = tcpuse_gzip = trueuse_encryption = true本机连接 ssh -oPort=6000 内网客户端ssh用户@外网服务器ip外网服务器访问内网web服务 #frps.ini[common]bind_addr = 0.0.0.0bind_port = 1234log_max_days = 7max_pool_count = 100log_file = frps.loglog_level = infovhost_http_port = 1235[web]type = httpauth_token = xxxcustom_domains = xxx.xxx.com#frpc.ini[common]server_addr = m1-test-pub2.m1.ejoy.comserver_port = 1234auth_token = xxxlog_file = ./frpc.loglog_level = infolog_max_days = 3[web]type = httplocal_port =10003custom_domains = xxx.xxx.com通过http://xxx.xxx.com:1235可以访问内网web服务
socket-pipe node写的,直接看作者的介绍
 https://joyqi.com/javascript/socket-pipe.html https://github.com/joyqi/socket-pipe </content>
    </entry>
    
     <entry>
        <title>微信开发调试</title>
        <url>https://farwmarth.com/post/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>微信开发</tag>
        </tags>
        <content type="html"> 接入文档 http://mp.weixin.qq.com/wiki/home/index.html
申请免费公众号 无需公众号,普通微信既可申请测试公众号: http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;amp;t=sandbox/index
JS接口安全域名: http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html OpenID: 针对每个公众号会产生一个安全的OpenID UnionID: 对所有这些同一开放平台账号下的公众号和应用，只有一个UnionID access_token: 众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新
本地调试 内网穿透 原理是通过外网服务转发至内网端口达到本地调试:
 https://ngrok.com/ https://natapp.cn 教程:https://natapp.cn/article/wechat_local_debug http://qydev.com/ http://www.ittun.com/ http://www.ngrok.cc/ http://getfrp.yzxx-soft.com/ https://diannaobos.com/frp/  下载调试工具 http://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html
禁止微信缓存 &amp;lt;meta http-equiv=&amp;#34;Cache-Control&amp;#34; content=&amp;#34;no-cache, no-store, must-revalidate&amp;#34; /&amp;gt;&amp;lt;meta http-equiv=&amp;#34;Pragma&amp;#34; content=&amp;#34;no-cache&amp;#34; /&amp;gt;&amp;lt;meta http-equiv=&amp;#34;Expires&amp;#34; content=&amp;#34;0&amp;#34; /&amp;gt;http://www.zhihu.com/question/25456655
</content>
    </entry>
    
     <entry>
        <title>恶补键盘知识</title>
        <url>https://farwmarth.com/post/%E6%81%B6%E8%A1%A5%E9%94%AE%E7%9B%98%E7%9F%A5%E8%AF%86/</url>
        <categories>
          <category>life</category>
        </categories>
        <tags>
          <tag>键盘</tag>
        </tags>
        <content type="html"> 引用  http://www.pcpop.com/doc/0/836/836084_all.shtml  键盘类型 薄膜 机械  红轴   红轴，它的力度比较轻，与黑轴塑料部分相同，直上直下爽快自然，入门者可能会觉得它比较滑。这是一种备受争议的轴，由于力度太轻，导致个别用户手搭载键盘上误触，而且它的造价是所有轴里最高的。因此很多人认为他是失败品，在国外的销量并不理想。但是国内不少玩家给予好评，如果搭配得当使用者可感受到丝绸般顺滑，无论是游戏还是打字亦或其它应用都可以，只是价格略高 茶轴   最全面的茶轴。有段落感却不像青轴那样张扬，手指的感觉非常舒适，力度适中适合多种环境，最看好的进阶轴，无论是游戏还是大字都不错。不过不是所有人都喜欢这种钝色式的多段感，购买前最好体验一下。 青轴   青轴是一款最风骚的轴，声音清楚酷似拨片开关，只有当声音响起的时候按键才被触发，因此打字的时候噼里啪啦，无论是指尖还是心理上都得到了极大满足，特别适合文字工作者。但是不可否认的噪音太大，很多环境不合适，比如安静的办公室，容易影响他人。 黑轴   黑轴是这四种主流轴里最大力的，被成为最原始最纯粹的机械轴，广泛适用于各种人群，由于它有着超短触发距离与最长使用寿命，因此被游戏玩家推崇。当你在激烈的游戏环境下，手指按下键盘即可快速反映，先于敌人一步作出反映在游戏玩家看来至关重要，哪怕只是零点几秒。当然打字和日常应用也不错。不过刚刚入门的朋友可能会觉得力度太大，手指肌肉紧绷，一旦你适应了黑轴，那么其它任何轴都不会再有困难，入门首选静电容 键位 标准键位 87键位 少了小键盘而已 厂商  cherry flico hhkb realforce </content>
    </entry>
    
     <entry>
        <title>我的mac配置</title>
        <url>https://farwmarth.com/post/%E6%88%91%E7%9A%84mac%E9%85%8D%E7%BD%AE/</url>
        <categories>
          <category>mac</category>
        </categories>
        <tags>
          <tag>mac</tag>
        </tags>
        <content type="html"> mysql记录 brew 安装mysql brew install mysql初始化mysqlsudo mysql_install_db --verbose --user=`whoami` --basedir=&amp;#34;\$(brew --prefix mysql)&amp;#34; --datadir=/usr/local/var/mysql --tmpdir=/tmp --explicit_defaults_for_timestamp或者mysql_install_db --basedir=/usr/local/Cellar/mysql/5.6.10开启mysqlmysql.server startmysql.server stop初始化超级管理员mysqladmin -u root password绿色版安装启动 #http://www.widlabs.com/article/mac-os-x-install-mysql-with-tar-gzcd /usr/local/mysql# 启动sudo support-files/mysql.server start# 重启sudo support-files/mysql.server restart# 停止sudo support-files/mysql.server stop# 检查 MySQL 运行状态sudo support-files/mysql.server statusMYSQL缺少libmysqlclient文件 MYSQL缺少libmysqlclient文件ln -s /usr/lib/mysql/libmysqlclient.18.dylib /usr/lib64/mysql/libmysqlclient.18.dylibln -s /usr/local/Cellar/mysql56/5.6.32/lib/libmysqlclient.18.dylib /usr/local/lib/libmysqlclient.18.dylibln -s /usr/local/Cellar/mysql/5.7.16/lib/libmysqlclient.20.dylib /usr/local/lib/libmysqlclient.18.dylib#http://www.jianshu.com/p/e196d25a8e31setting  轻击替代点击  inconsolata brew tap caskroom/fonts # you only have to do this once!brew cask install font-inconsolatamac m2cryto brew install swigxcode-select --install#然而里面还是没有 openssl#然后另外安装openssl 的时候会发现并没有把头文件ln到 /usr/include 里面，无卵用，/usr/include 还是一个不可更改的系统目录#但是我们留意到安装​M2Crypto的时候报错的地方是提示 swig 语句有问题，于是可以修改swig 的寻址路径，如下，妥了：brew install opensslsudo env LDFLAGS=&amp;#34;-L$(brew --prefix openssl)/lib&amp;#34; \ CFLAGS=&amp;#34;-I$(brew --prefix openssl)/include&amp;#34; \ SWIG_FEATURES=&amp;#34;-cpperraswarn -includeall -I$(brew --prefix openssl)/include&amp;#34; \ export EXTRA_CFLAGS=-I/usr/local/opt/openssl/include &amp;amp;&amp;amp; export EXTRA_CXXFLAGS=-I/usr/local/opt/openssl/include &amp;amp; export EXTRA_LDFLAGS=-L/usr/local/opt/openssl/libpip install m2crypto#http://stackoverflow.com/questions/33005354/trouble-installing-m2crypto-with-pip-on-el-capitaniterms2 终端 How To Enable Shell Integrationcurl -L https://iterm2.com/misc/install_shell_integration.sh | bashhttps://www.iterm2.com/documentation-shell-integration.htmlzsh 终端 https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overviewzsh配置
#git aliasalias gp=&amp;#34;git pull origin master&amp;#34;alias gs=&amp;#34;git status&amp;#34;alias gd=&amp;#34;git diff&amp;#34;alias gc=&amp;#34;git checkout&amp;#34;alias ga=&amp;#34;git add&amp;#34;alias gm=&amp;#34;git commit -m&amp;#34;pyenv python版本管理 pyenv命令:commands 列出所有pyenv命令local 设置或者显示local的python版本global 设置或者显示global的python版本shell 设置或者显示shell的python版本install 安装一个python版本uninstall 卸载一个python版本rehash Rehash pyenv shims (run this after installing executables)version 显示当前版本versions 显示所有python版本which 显示可执行python的路径whence 显示带执行路径的所有版本########安装其他版本的python#依赖sudo brew install homebrew/dupes/zlibbash brew install readline; brew link readline;#安装CFLAGS=&amp;#39;-g -O2&amp;#39;CFLAGS=&amp;#34;-I$(xcrun --show-sdk-path)/usr/include&amp;#34;CFLAGS=&amp;#34;-I$(brew --prefix openssl)/include&amp;#34; \ LDFLAGS=&amp;#34;-L$(brew --prefix openssl)/lib&amp;#34; \ pyenv install 2.7.5#环境变量export PYENV_ROOT=&amp;#34;$HOME/.pyenv&amp;#34;export PATH=${PATH}:$PYENV_ROOT/bin:$PATHeval &amp;#34;$(pyenv init -)&amp;#34;#移除版本rm -rf .pyenv/versions/2.7.5virtualenvwrapper virtualenv jenv java版本管理 jenv一些命令:commands 列出所有命令local 设置或者显示local的java版本global 设置或者显示global的java版本shell 设置或者显示shell的java版本rehash Rehash jenv shims (run this after installing executables)version 显示当前版本versions 显示所有版本which 显示当前带执行目录whence 显示所有带执行目录的java##安装jenvbrew install jenvecho &amp;#39;export PATH=&amp;#34;\$HOME/.jenv/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profileecho &amp;#39;eval &amp;#34;$(jenv init -)&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.bash_profile或者是.zshrc$ exec $SHELL -lnginx brew install nginx#Docroot : /usr/local/var/www#conf :/usr/local/etc/nginx/nginx.conf to 8080 so that#To have launchd start nginx at login:ln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgents#Then to load nginx now:launchctl load ~/Library/LaunchAgents/homebrew.mxcl.nginx.plistln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgents/Users/weiz/Library/LaunchAgents/homebrew.mxcl.nginx.plist -&amp;gt; /usr/local/opt/nginx/homebrew.mxcl.nginx.plistsudo chown root:wheel /usr/local/Cellar/nginx/1.4.4/bin/nginxsudo chmod u&#43;s /usr/local/Cellar/nginx/1.4.4/bin/nginxvim /usr/local/etc/nginx/nginx.confsudo nginx#html改权限sudo chmod 755 -R /Users/vont/www/public_htmllanchRocket brew服务管理` aria2 下载管理 打开webui-arai2界面管理aria2
#!/bin/bashstouch /Users/far/Downloads/session.txt &amp;amp;&amp;amp; aria2c --enable-rpc --rpc-listen-all --save-session=/Users/far/Downloads/session.txt --input-file=/Users/far/Downloads/session.txt -x16 -s16 -k1M --dir=/Users/far/Downloads&amp;amp;open -a &amp;#34;Google Chrome&amp;#34; /Users/far/Develop/git/webui-aria2/index.htmlwget 下载 boot2docker docker tomcat 检查是否安装成功catalina -h启动catalina run根目录(CATALINA_HOME)/usr/local/Cellar/tomcat/7.0.33/libexec/webapps/ROOT/操作  清除appstore缓存  rm -r /private/var/folders/*/*/*/com.apple.appstore  finder底部的可编辑白边 这个是输入法引起的按esc键可消除
  隐藏文件
  #显示Mac隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true#隐藏defaults write com.apple.finder AppleShowAllFiles -bool false 如何删除iOS模拟器上的应用程序  ios模拟器--还原内容和设置 键盘修饰键  系统偏好设置--键盘--修饰键---更改commond和control键的位置 乱码  iconv -f GB2312 -t UTF-8 文件名&amp;gt; 新文件名 mac 删除svn  find . -type d -name &amp;#34;.svn&amp;#34;|xargs rm -rf dock上添加空白  defaults write com.apple.dock persistent-apps -array-add &amp;#39;{&amp;#34;tile-type&amp;#34;=&amp;#34;spacer-tile&amp;#34;;}&amp;#39;;killall Dock --左defaults write com.apple.dock persistent-others -array-add &amp;#39;{tile-data={}; tile-type=&amp;#34;spacer-tile&amp;#34;;}&amp;#39; ;killall Dock --右 mac Sierra 允许“任何来源” 的应用  sudo spctl --master-disableAndroid  sdk图形界面  命令行进入tools目录如**/Users/far/Develop/devtools/adt-bundle-mac-x86_64-20140702/sdk/tools**然后输入 ./android sdk 请出SDK Manager的图形界面 eclipse android content loader 0% 解决方案:  删除.metadata/.plugins/org.eclipse.e4.workbeach 内容 eclipse中设置默认签名key方法  Eclipse: Window-&amp;gt;Preferences-&amp;gt;Android-&amp;gt;Build-&amp;gt;Custom debug keystoreC:\Users\&amp;lt;用户名&amp;gt;\.android\debug.keystore这个key的密码是：android我们可以输入如下命令来查看其详细信息：keytool -list -keystore debug.keystore输入密码：android connection to adb is down, and a severe error has occured. You must restart adb and Eclipse  在命令行下运行 adb start-server* daemon not running. starting it now *ADB server didn&amp;#39;t ACK* failed to start daemon *已经确认adb.exe的路径没有问题，重启了几次模拟器和eclipse还是不行，上网查了下资料~解决办法：(1)查看任务管理器，关闭所有adb.exe(2)重启eclipse即可(3)豌豆荚 ，wandoujia.exe 腾讯手机管家，也有同样的问题。它会产生个tadb.exe; 杀掉即可 金山助手 sjk_demonAlfred  工作流，快捷启动 workflow目录:~/Library/Application Support/Alfred 2/Alfred.alfredpreferences/Workflows/
 Alfred 3 支持 iterm3 on alfred_script(q)tell application &amp;#34;iTerm&amp;#34;activateset the clipboard to qdelay 0.5tell application &amp;#34;System Events&amp;#34; to tell (name of application processes whose frontmost is true) to keystroke &amp;#34;v&amp;#34; using command downtell application &amp;#34;System Events&amp;#34; to tell (name of application processes whose frontmost is true) to keystroke returnend tellend alfred_scriptmac 上使用f1 f2按键 fn&#43;f1iterms的ssh保持session profiles -&amp;gt; sessions -&amp;gt; When idel, send ASCII codehttp://simplyy.space/article/56c2d71f6ba384e02299f9b9 http://www.dreamxu.com/mac-terminal/
</content>
    </entry>
    
     <entry>
        <title>给shadowsocks插上tcptun,bbr这对翅膀</title>
        <url>https://farwmarth.com/post/vultr/</url>
        <categories>
          
        </categories>
        <tags>
          <tag>vultr</tag><tag>shadowsocks</tag><tag>tcptun</tag><tag>bbr</tag>
        </tags>
        <content type="html"> 最近vultr 搞活动充五刀送五刀.之前用的服务商速度有点不给力.想着撸个ss玩玩,晚上折腾到一点多, 易票联的全球付卡在vultr一直刷不了.又不想用paypal绑银行卡.试着把全球付的卡绑到paypal上。然后用paypal一刷居然成功了.
vultr比linode同等配置价格更便宜.500G的流量绝对够用了.知乎上看了一下好像日本的线路速度比较快.自己也测试了一下.然后开了个实例准备试用几个月看效果如何.
速度测试   国内线路测试vps速度ping http://ping.chinaz.com/45.76.185.184
  speedtest测试带宽
  wget https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.pypython speedtest.pyShadowsocks安装 安装Shadowsocks-go #安装wget --no-check-certificate -O shadowsocks-go.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.shchmod &#43;x shadowsocks-go.sh./shadowsocks-go.sh 2&amp;gt;&amp;amp;1 | tee shadowsocks-go.log#默认配置文件在/etc/shadowsocks/config.json安装后脚本提示： Congratulations, Shadowsocks-go install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local Port:1080Your Encryption Method:aes-256-cfb安装完成后即已后台启动`Shadowsocks-go`运行：#启动：/etc/init.d/shadowsocks start#停止：/etc/init.d/shadowsocks stop#重启：/etc/init.d/shadowsocks restart#状态：/etc/init.d/shadowsocks status多用户多端口配置文件示例： 配置文件路径：/etc/shadowsocks/config.json
{&amp;#34;port_password&amp;#34;:{&amp;#34;8989&amp;#34;:&amp;#34;password0&amp;#34;,&amp;#34;9001&amp;#34;:&amp;#34;password1&amp;#34;,&amp;#34;9002&amp;#34;:&amp;#34;password2&amp;#34;,&amp;#34;9003&amp;#34;:&amp;#34;password3&amp;#34;,&amp;#34;9004&amp;#34;:&amp;#34;password4&amp;#34;},&amp;#34;method&amp;#34;:&amp;#34;aes-256-cfb&amp;#34;,&amp;#34;timeout&amp;#34;:600}BBR 介绍 BBR是google开源的一个TCP BBR拥塞控制算法,可以进行单边加速
安装 #手动安装要更新内核,用这个一键安装#https://blog.kuoruan.com/115.htmlwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod &#43;x bbr.sh./bbr.sh#验证是否成功sysctl -a|grep tcp_congestion_control#net.ipv4.tcp_congestion_control = bbr#验证2lsmod | grep bbr#tcp_bbr 16384 5kctrun Kcptun介绍 Kcptun 是一个非常简单和快速的，基于 KCP 协议的 UDP 隧道，它可以将 TCP 流转换为KCP&#43;UDP 流。而 KCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低30%-40%，且最大延迟降低三倍的传输效果。
Kcptun 是 KCP 协议的一个简单应用，可以用于任意 TCP 网络程序的传输承载，以提高网络流畅度，降低掉线情况。由于 Kcptun 使用 Go 语言编写，内存占用低（经测试，在64M内存服务器上稳定运行），而且适用于所有平台，甚至 Arm 平台。
简易原理 安装 https://raw.githubusercontent.com/kuoruan/kcptun_installer/master/kcptun.shchmod &#43;x ./kcptun.sh/kcptun.sh#查看kcptun日志./kcptun.sh log#配置文件/usr/share/kcptun/server-config.json#kcptun服务器/usr/share/kcptun/server_linux_amd64#Kcptun 日志文件目录:/var/log/kcptun/#开关kcptun#Supervisor 命令:service supervisord {start|stop|restart|status}{启动|关闭|重启|查看状态}#Kcptun 相关命令:supervisorctl {start|stop|restart|status} kcptun&amp;lt;id&amp;gt;{启动|关闭|重启|查看状态}Mac上kcptun和ss配置 https://github.com/xtaci/kcptun/releases 下载 kcptun-darwin-amd64-20170308.tar.gz
shell sudo ./client_darwin_amd64 -l &amp;#34;:kcptun加速端口&amp;#34; -mode fast -r &amp;#34;vps的ip:kcptun对外端口&amp;#34; --crypt &amp;#34;加密方式(aes)&amp;#34; --key &amp;#34;kcptun密码&amp;#34;gui win: https://github.com/dfdragon/kcptun_gclient mac: https://github.com/dfdragon/kcptun_xclient 截图是windows的ui,mac配置差不多 supervisord /etc/supervisor/supervisord.conffiles = /etc/supervisor/config.d/*.ini参考 配置参考  https://teddysun.com/486.html https://blog.kuoruan.com/110.html http://hohothink.com/fq http://xn--rgvu79ah1g.com/ios%E4%B9%8B%E8%B7%AF/speed-up https://miaocode.tk/hello-kcp/  算法参考  http://blog.csdn.net/dog250/article/details/52830576 </content>
    </entry>
    
     <entry>
        <title>语音服务器的选型</title>
        <url>https://farwmarth.com/post/%E8%AF%AD%E9%9F%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%89%E5%9E%8B/</url>
        <categories>
          <category>audio</category><category>skill</category>
        </categories>
        <tags>
          <tag>游戏</tag>
        </tags>
        <content type="html"> 前言 最近游戏要接入一下语音服务器,调查了一下融合的语音sdk 腾讯云GVoice:https://www.qcloud.com/document/product/556/7673 好像只有这个比较靠谱,但是收费好像有点贵,还是决定基于原有的免费的百度语音识别造一个轮子
选型 要解决几个问题
 语音转文字翻译 高效的web服务器 分布式的文件存储 与游戏服务器沟通的消息队列选择  语音转文字翻译 这个真没法自己造轮子,选择了百度的语音服务 语音识别50000次/日配额 支持的语音时长上限为60s
 auth文档 http://developer.baidu.com/wiki/index.php?title=docs/oauth/client 刷新access_token http://developer.baidu.com/wiki/index.php?title=%E4%BD%BF%E7%94%A8Refresh_Token%E8%8E%B7%E5%8F%96Access_Token 语音识别接口 http://yuyin.baidu.com/docs/asr/57  local new_timer = ngx.timer.atlocal access_tokenlocal refresh_tokenfunction M.timer_refresh_token(resp)local expires_in_sec = resp.expires_in - 3600expires_in_sec = expires_in_sec &amp;lt; 0 and 1 or expires_in_sec--过期前一天刷新token new_timer(expires_in_sec,M.refresh_token)endfunction M.gen_token()if not access_token thenlocal data = { grant_type=&amp;#34;client_credentials&amp;#34;, client_id = Config.AppKey, client_secret = Config.AppSecret}local resp,err = http_util.get_baidu_token(Config.TOKEN_URL, data)access_token = resp.access_tokenrefresh_token = resp.refresh_tokenM.timer_refresh_token(resp)endendfunction M.refresh_token()if refresh_token thenlocal data = { grant_type=&amp;#34;refresh_token&amp;#34;, client_id = Config.AppKey, client_secret = Config.AppSecret, refresh_token = refresh_token }local resp,err = http_util.get_baidu_token(Config.TOKEN_URL, data)access_token = resp.access_tokenrefresh_token = resp.refresh_tokenM.timer_refresh_token(resp)elseM.gen_token()endendfunction M.translate_voice(voice)local len = string.len(voice)local base64_str = ngx.encode_base64(voice)local data = {cuid = Config.CUID, token= access_token, channel = 1, format = &amp;#34;amr&amp;#34;, rate = 8000,len = len, speech = base64_str }local resp,err = http_util.post_ret_json(Config.VOICE_URL, data)if not err thenlocal err_no = resp.errnoif ERR_TBL[err_no] thenreturn ERR_TBL[err_no]endreturn resp.result[1]endreturn errendweb服务器 所有的结构是在python在Flask上构建的,怕运行效率不行想重新写一个.几经比较之后,没有选择比较熟悉的java语言和tornado,而是选择了openresty,主要是基于几点考虑
 是否是经过验证的框架 是否是熟悉的开发语言 开发和部署是否简便快捷  openresty 是在nginx的基础上嵌入了lua的支持,兼备了Python快速开发和Nginx C模块的高性能
文件存储 前期小规模的文件存储直接单机就可以了.而且语音这种是有时效性的,通过ttl过期即可清除,磁盘空间不会无限增长. 但为了做个新的尝试,也调查了一下分布式的小文件存储
 tfs : http://tfs.taobao.org/ tfs淘宝的开源方案年久失修,果断弃之 mogilefs : https://github.com/mogilefs 要加入mysql弃之 fastdfs : https://github.com/happyfish100/fastdfs c编写,用的人比较多,但是看了几篇对比文章之后也没有做为最终的选择 seaweedfs : https://github.com/chrislusf/seaweedfs bilibfs : https://github.com/Terry-Mao/bfs 借鉴了seaweedfs和fastdfs,这篇文章可以对bfs有个大概的了解,没有用这个的原因是加加入 baidubfs : https://github.com/baidu/bfs c&#43;&#43;编写,不熟悉  最终使用了seaweedfs go语言编写,简单易用
参考: http://blog.qiniu.com/archives/2546 http://wenjun.org/?p=1087 http://www.simlinux.com/books/FastDFS.pdf
消息队列 游戏内auth和后台gm通信中间件使用的rabbitmq,为了保持一致性也使用了这个
架构 流程 由玩家发起语音聊天,将语音压缩成amr上传到中心主机nginx上,由nginx反代seaweedfs集群完成语音文件的存储,然后将返回的文件id加上内网的集群ip组合成语音id将消息信息push到rabbitmq队列中,游戏服务器作为mq的订阅者实时处理队列内容将消息按频道和语音id广播给对应的游戏客户端,游戏客户端用语音id请求中心主机nginx再从代理的seaweedfs集群中取语音文件.整个语音聊天的过程就完成了.
关于百度语音识别部分 百度语音识别api并不支持流式上传数据,而且把识别这部分放到上传语音的过程中加重了rpc调用的负担.所以这部分可以放到游戏客户端直接请求百度api
</content>
    </entry>
    
</search>